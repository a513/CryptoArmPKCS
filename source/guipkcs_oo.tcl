#!/usr/bin/tclsh
package require Tk
package require textutil
package require http
package require ip
source [file join [file dirname [info script]] classtoken.tcl]

array set ::tokenlist []
set ::tokenls11sw0 "tokenls11sw0"

variable typesave
set typesave 0
variable vars
#ttk::style theme use clearlooks

switch -- $::tcl_platform(platform) {
  "windows"        {
    encoding system utf-8
    #    encoding system cp1251
  }
  "unix" - default {
    encoding system utf-8
  }
}
set ::I 0

image create photo verchlefttoright_22x24 -data {
  iVBORw0KGgoAAAANSUhEUgAAABYAAAAYCAYAAAD+vg1LAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4wsCCSkSOfPvOgAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABA0lEQVRIx+2VPU7DQBBGnyMjIEYiUWoatgLOQpEiVzCHyg2iSC64gqsUbhKgWpp0UbLCMrsGYTEU
  QRRBNsTCUgSMNNpiPr1dzc4PIkKZx3EsVfEqb9GQ/TJwURS1wZ6IlAattQRB8PPg3c/xPEUWFlMmXljMPEW2BhsH4yndpWO0KVw6RuMpXeNqvPikw1WvDdGMgckJPy7M
  CaMZg157ran1eekTXN8hL6/Qv0ABRDfovRZcnuEdH4DW+lM6lFLel1XxkHMa3aK9d6kI9M9RnUPu4Xvg0iGychIOJyLDicjKSbjtEKqs48fn9Xm0/+caZNOyLGsGnCSJ
  NAL2ff9/g+ww+A0jlOBr1hYU8QAAAABJRU5ErkJggg==
}
image create photo verchlefttoright1_24x24 -data {
  iVBORw0KGgoAAAANSUhEUgAAABYAAAAYCAYAAAD+vg1LAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4wsCCSERaCM0iAAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAh0lEQVRIx+2UTQqAIBCFNTpTLQTrZHW2N+i+TvRatarsRyaIFGY18iHfzNOQNEcVQmCqn6rKKJ0C
  1gdbku+9WEQoIlRRMQ6DyYIfLTgA9l1HAI9CkmzmwE8vAGDbNJyn6Ra8fqIvxrhx75yzlxyrqVAZXi6U5H7y1v313ttvRDo1/fIf/wC8ALIT6A9a9x29AAAAAElFTkSu
  QmCC
}

image create photo vgrlines_v -data {
  iVBORw0KGgoAAAANSUhEUgAAACUAAAAYCAYAAAB9ejRwAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4wsBDi4wtCiBcgAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAQklEQVRIx+3SwQ0AIAgEQWLs6tqHuqAD48MYorsFHPPAcpG758l294Y1DBQoUKBAvYKatw9GRC+U
  JH4KFChQoL5CFY+RlT0tsM7RAAAAAElFTkSuQmCC
}
image create photo sw_token -data {
  iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wsKDzoIZEcDjwAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAFEElEQVRIx5WVaWxUVRTHf/e9N9ubactMmWJbkEJTFsHSImCAsAmpgBEIiCFoVQQCiiuoaCK7EkNM
  jAqYCJGA8EFIUElAiEZME5VSgQqlteyklG6UTmdjZt5y/VAQEIVyP917c87533PO/3+u4D6WHOKg6/kpovUqLmQfo1+g8hmXkLNbkurcy1Ff66AuIfPP0AHzVh+ts8G3
  5D+K+KOcFfl/ug5l9Nk8MP2IWp8Ug9NU2Qz2dilDodqrbCbEXn9gKm1XvwdA3Ctw/4zJ1LTv++ec7p1S5XHSt7duavIWu4QlqGxzXkART3Ft95Eb93cBmAzsA+Zok/vX
  LyjOTL52Ka54xnhljzmF7WApd7qY8HplxpUubjPcbqn1Z1u0l8S9izNtRdmGppUFQYNTVx2Uf6HLt4eFBOadru0JwY+5boYMTpDuhdUb087eswdPj4qNGdo3yaKPsnY1
  R7QKV33Tuq+PGCTtGwASEAggZsKBCt+W3YeCtS9Ma1ub8in59wRwu8A0JRMnPTFz5ozHZm4vr5cpUwjlRoGjMYTXBwp4LJtN/TLmyJTJ8cPLAdk5FkkkpqZyNmQxesAD
  IidTR3M5oKGJ1JK1OEtnw+DBkBWEpMnFhnbk/dBUCEFjS4xTHy+ntTWFNX0uz5eOJfzOAozyYzg8PnxFxSjXDLBtsG/yS+msDixp443GSbSHMQ0DbInx628Ir47+3tso
  XTM7gv9rdRJA4nYo/CB7c8WfR1qGDqaJ/tbryFiM8PRZmCerweW6w7NzPZACf4bO0DeeJZUyKcoPglCIfbIexeUGyyLyzvv41q7BMaAf8n4yECCFgMaWCJteXs1nL77P
  l98epTkUIbl4MUl/wBZZQRxFhYR37qahtZ1oPIEQdwEYdnObkzSM7kKAKgTDswUz8m0cqTg7tx9kB7nUDJ8gFdvGPFjGX2GLbbsO8Vv5aRyaemeJRgBTV6xh6apljHS7
  S0a/tmRHrOFyJvIoTqfKYUceihVjQp/uzJj4CCgqxMernJ0Bts3IvJ6M9Hm5dK6R479sux1AbtiMWDSP8lXL0mY9XLgy+/GSxSPHjuXnXd8gJfgzdNZtfBPLshDSpOyn
  X7jc3Iymabg9Oj1zumHW/MX5i3X0zitAVRTARpsC7AHEonnkw9BxpaWbRpeUDHqgWzcMC9wuN0LA5ZYoe15dQiQUw/3cQsYVP0hWZjZOh4YQAsuyMDDo16sPcUMir7da
  23M9g17+wCdL134439+1qzcQCKCqKg/m9uSww9FhKCRJQ9LDY9BqJLkUNkgkDJCpjpEhrzNCSixDov6LpumL3l06Ld3v9+q6jsfjwel0cvJkNaFQW4eFquLPzaY91gVP
  IMCoop5gWv+pmUuNEY7XXc9gaHpGnp2TvXXv/v153XNzGT9hAlJKotEotWcu0BaOAJCdqTNp/jIs2yJNk2CY3Eb421R/i9DsYLAs2KtXj0g4zImqKiLRKAUFBVyLx4mn
  JKlkCikFhgW6o0N08i7/lJAgkFhWR820NK83p6i4mOqqKnRdp6KiAp/Ph5FKyQs1Z37v7nV103U1v+ZkJQsXn0P837Nvlz4vl5hI24kWcDmXBHy+dQMLC53rP/2UdFWt
  PF1bWxdpbDxWXVe3ojnw5FfnG5ryP5hVjSVVOhNfCDCMa1hRZ7UAmPjQQwNNt/u70ydObA0q6ud/JBNJIAHIEYwLZBdrr2R57eESjE4OX2FZItl0RSz7G8RkHM2jxn02
  AAAAAElFTkSuQmCC
}
image create photo cloud_token -data {
  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
}
image create photo vgrlines_cloud -data {
  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
  RU5ErkJggg==
}
image create photo vgrlines_24x24 -data {
  iVBORw0KGgoAAAANSUhEUgAAACUAAAAYCAYAAAB9ejRwAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4wsBDhggIIMAYwAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAQklEQVRIx+3SwQ0AIAgEQWLs6tqHuqAD48MYorsFHPPAcpG758l294Y1DBQoUKBAvYKatw9GRD+U
  JH4KFChQoL5BFYzNlT06EPrbAAAAAElFTkSuQmCC
}
image create photo endfunc_24x24 -data {
  iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4wsBDwsoTnWj9AAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAPUlEQVRIx+3RsQ0AIAgFUTRuxfow13cCoTA25q6F8ApMRRGh26Y9DgAA4AdgdQuZ2R5x9+NsSBI/
  AAAAqNsNUWYbXBgwIgAAAABJRU5ErkJggg==
}
image create photo rabota_24x24 -data {
  iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4wsCCR4KupjXWAAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAADiUlEQVRIx41WPUgrWxD+5uxulCVieAYhRhQhoCmU6DWKkFo7C0kTbCzkPlS0UfsQG5FAQFC4ICnF
  n05EEAu1sBSjKa2CQYyCATUQ3J95heyymmTfHdhi95wz33wz38xZymQy+D8jIhARDMMAACiKAsMwYJrmt33MDCHEt3fZzTEzg4iQy+X48PAQlUoFABCJRDA1NUVer7cm
  EOc5AI0BmBmGYSCdTnOpVPq2dnt7i1wux6urq+jo6CCnQ2YGM9t7RSPnzIybmxt+fn62D/9ktr29DY/H882hk0lDAGvT/v5+TUROkEqlguvra3bm3aqX9TQEqFardlHd
  rFgsNgzClcHfmsfjqVHTN4BG6KqqwufzuUpXCIFwOGxLs56fhgxM08Tc3FzZyqUzv0IItLS0YHh4GJ2dneRcawjgZEJEYGb4/f5/4vF4TWSKoiAYDCIej5NhGHUdWyY3
  kpflKBaL0cDAAM7Ozvjh4QE+nw9DQ0MYHBwkXdftjpYkqT6AFa1T3xabg4MD7u7uRjQapcnJSSoUCtzV1UWSJIGZkc1meXx8HMFgkFwZ1OvCZDLJHx8fUFUVRITz83M+
  OTmBqqqcSqWIiHB3d4d8Po/p6WmORCIEoIaJ/HN2CCGQSqXYmjsWo4mJCSoUCpxIJMgSQXNzM6rVKnZ3d6HrOo+OjpKzXkQEymQydtSSJGFtbY1fX18RCASQSCRQKpVg
  FVIIAdM0baYejweSJCGbzQIAZmdn0d/fT5qm2ftlZ/6TySS/vb0BANra2rC3t4disejaaIuLi3a0Ozs7WFhY4FAoRFYgwkrNxsYGl8tlWxVuynAb0VtbWygWiyyE+AKQ
  JAlHR0f21HQ2ldsIcDak0yRJwubmJhRF+UqTruu4uLiAqqrw+/1gZszMzGB+fp7cGsiy9vZ2Wl9fp9bWVvvW0zQNp6enzMwQsiwjFouBiPDy8oKenh6MjY2RpmnQNO2v
  Bp6iKFhaWvrXYuPz+RCNRomIQOl0Gp+fn2BmPD4+clNTEwKBADEz3t/ffz89Pf2px8S6f3t7e8ka6/f39+z3+69VVR32er1fd7Isyzg+PubLy0tb80TEpmliZGQE4XC4
  YS2ICMvLyz9H6C9JkjiTyZCu65CFECgUCgiFQjXKKJfLuLq6ck2Pdc45ckzTRD6f576+PpJ1XcfKyordnQ4WNpDFwCnJeneA9d36YTBNE/8BNQX5joKJN78AAAAASUVO
  RK5CYII=
}

image create photo ::img::view_18x16 -data {
  iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wUXCSwOiHJe/AAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAADQklEQVQ4y22TS2hcZRiGn/8//7nMOZnMTDIzpqmYIU2KtVIvRBRERImoUNu4K4qCFxAqirhx78aN
  C0HES7GC6MKi4EakggsRKRSVWKOLhmAMaNKYnDO3c2bmXP7fRUJE9Nu9i++B7+X5RLcTmfWoYC3KASiylE6nQ1ByGeUaYTTSdvGDAAz/GiGgLvu0ajZqPSp48+eMk3dM
  kecZ/SgkmGiRFxlkOW4QEAQ+E56hMKCNwZICz3T5dVPwxjc9Xrm1j7oaZjy8MMX7y4a830MqHwOYTKP8KsqzKTsQt0N+i0ZsbsYs3dXgre/qvLqQU6TrxIwjPv1xy+hG
  ndcv/MSZW2o4SpKkGWO+j+WV9qCAPrhH0m2H2MpCS8MXq5JnWl2UzjPauzsU0uX0zRW2eyk3HpqkGowddBFrw9WtEeO+xaQ/IjN1Cl3w+8jhs+U1KrU6qh1FuEfmKIot
  zl3a5sMrA748e5yXLv6BpyRHGg5PnKjw6EcbPDQrcCR0BiO0cHn23jKq3EBIiQoCn14yAK1ZPDZJ63rFdFnx7ulpCkALiHN4bsFlrmFz+2EX5XnEcZ/Yr6NFCGjUcJRi
  LAm2ww3NCpab41rgWgKAHLiWdLmpaVPxJePlEoPhgMONBqtDSWEAAcpRFiMkllfmg+8j3rkU8vXZWS4sd3CUZEINWZz3ePrjDZZum6S12qUnApSzy2P3NND7bqm0MJTG
  x4GQ++fLVEsW02Wb1xabxMWA/lCxk2heuO86moHhybtbWEgMsDLgH1C1WiXSYAzMTtiU7ABbScI0YZRm5NpgK4sThyymp+rkSNJ9JQR7IKNBGcxeAM5fjjh/OeKTx5uc
  +/ZPPCWZaficPF7ixc87LC041PyEMM7RwPMPTqGBdriL4oAueGB+jHGVMuFkvH1mBi0k/cGQ2Hi8vKiYqTucmh+j2N9ZSSDt7OKXPJQA0gLuPFYnsgXNKY9fhg5XNgzZ
  sIdfqeG6DnNHfQRwcXffUgM/rIVgl+gnXcTKxo556qsR3WFBMYxBCKSlKEYJaqyGUC7/eXsg74Xg+NjJX7z3SBPR7bTN6rU+a9s9sgJKrk0yGFKpVLAc5/8YtKMQz7Xp
  9xOOTldp2CP+BgHpZjZpGm3KAAAAAElFTkSuQmCC
}

image create photo icon11_24x24 -data {
  iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wsBDSwt514xcAAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAFGklEQVRIx6WVbWyV5RnHf/fzck5Pzzm0hZ51uK6bdGhk0CzaaJTBLMYXdJFh4wdIzbIPbAsmLGGO
  WbMXNNvMxj5hSdmGSGSwKESc6JbqEmeTisjRrJGOs4LVzUpfqBQ8BXqel/u/D31JsWVx25U8ee7nzpP/77qvtxs+YZKm3uWS7pZ0SNIpSUclPSTpqql//mubIZ6T1CFJ
  AwMDyufzKhQKCoJAkgattWsk8f+AOuM41s6dO1VdXa1sNqvKykqtW7dOQ0ODkjQs6er/Vfw+SeOdnZ1aunSpduzYocbGRgEC1NzcrPHxcUn69acVXCTpUUm1k9+/kKQN
  GzZo+/btkqT+/n4B8jxPmUxG+XxekkY/jb4DPAv8BHhT0hLAB+jt7aWrqwuAXbt2XZankZERgMr/JBxE8cQiiiLt3r1bPT09klSU9KIktba2TocFkO/7cl1XuVxOhUJB
  kvoAipeC6/51prjq3cHzTYUPzzWNFMdXScpMk6IoGt64caPq6urU0dGhKSsUCqqvr78MAmjr1q2y1krSZoCX3vrnb1r3HdUj+47aTbu79Nu/nJCk62ceeVN3d7eWLVum
  qqoq7d+/X5JkrdXJk6f00A+2aOWKFVq7dq0OHDgwVap5SdWSnMcP/a2t8eHntPpnL+mmRw7pW+1/vQzgAXsbGhoeaG9vb9y2bRvr16/HWktz832cPf0ONzXUcv7cEm65
  +XpWNX0N3/cj4A/AWUALskkV3h8hHwuCmC9UZwDsNMAYMyppy/Llyw8aY+aXSiVaWlp489W7eOzrr1BfnuCpD75KbslrvPPHZ1my5nkvtyCzAdgDLLqjofa6n66/Ed91
  8F2Xa6+qAPiypBLwnpkRqtXA7wcGBuY/vXc/xw63cvBRwLW88JrPnTeEhKWYv6cep3H1wzhwwwcfjX3nsYNvf3vk43EuBREXSxHFSyGfrSy/sOfBW/trKlNrvKnSM8b8
  WVLTwoULD/1wy/cXHU48x7HjR/jKYo97V4QoMIxdgGq/j+IFqEhz69mxUvTCkT6GRy+CO+mrMSyurUpfCqIUYJyJPTM1V04Ab0dRTP8/XsdP+BgjCAyS4cSHPuUJO7EH
  yYTnKpNOQMIFb/JxHCQRxna60ZiCGGNCoNvzXBav3sVQMY0zIYYxYK3hYuADBuC46xgv4bqzmiyORfBJwAz7FdDTuHItdXWLQQIDxhEvHwvo6KllXjkA93uu4yQ9Z6JD
  pj2FyIogjGcDJnMRAPskGAuSXAwcRsc8zo85zKu7jT+9epy2ticIw/CBbJn/DeYY2WFsKUVznMCY6aJ6KpOtiE779/NMV5YHnxB7O3O0bPode55sIwhCRkdH8V0nl/Bm
  hyiKLeHkLPLmGlTGmEFJ225uam5973P18KV3qclVULWgxqZS5X2bN2/+jLV2XrEUkfBmRzm2Iow1dw5m3FJ9rp9irPgRH585RTpdSTKZcoAfAysdx/mRRHc6OdvHyIpS
  GM0NmCzZNPDL8VLE1aU2aortVNCL4xiAFqDXGPNza5VPJ2YDZC1BdOUqAnjSWju/v+cwR07AybHlvNH5PMNDQwC3AbcDJHzHqcwk8R1DmWMocx1SrkMm6ZMu850r5gDI
  RVFIdl6G27/5NPdkv8j5069jiAGSQBognfQHv3v3svfra6vGy3yPVNIl6TnUVKTMLdfUDCMF5grX6Oclfc9aFrmu6QEKwI1AHZAHdhhjzkmqArKlMLYJ38Vc1g2K4lhn
  /g1uPt1CX20OBgAAAABJRU5ErkJggg==
}

image create photo ::img::update_18x16  -data {
  iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAIAAACUZLgLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wUXCQUsGVSA8wAAAmZJREFUKM9Vk0FIFFEYx//fzI67
  zi5JUXhyobXVqEAwEUQEWzJELIR0ofAoLVaHwEMkKEtFnSTo0CHqUlcXxRbKc0gkkRKFoh6DDpLuwjrvzcyb93WYUbcfvMP7v+//wf+975GUkpkBEBEAbG0Z5XLs3fvf
  HbmBtRepE+bozWB4OMhmiZmZ2TAMZoYIkVJI6RUKOpHQAKebZm58g8mABnQioScmPKXEEZFN7u351waiKoCbrDf5cix+JGhA9/f71aqMbFJKoZQ3Pa3rS4DK1aG+noP/
  NT015TFLIQSk68rNzfq2QVeXt7DgVvYdIUslr7MzqDvkjQ3pugLC81Q+f+zp7RVCCKWk60opwjzd3erIOTKilBIQ1WqQzerD7HJlRQSBqMP3xeqqtKyopLU1qFSEQbUa
  HAchZ04jk4Hr4hAi8n20tKC5OVIcB0KQwTiGGWBG+ICRwkRgZq25XjSQSsFORr13d+OOqrcRERlw9xONbDQlCIBtI5mEQbatL3cCIKDWceHe+mNPeZZpEZFBhmVaSqmZ
  H3czDwtDc8/TaX3xkk6lEOMgCIrF2F5VnW153SFf/Xr79e/6dO+jwcwgM5e3Pzxdebb257tpwjLN/P30g9wtpUBCCNO0Xn6Zm/38xCOlfBeaTTOWakgBXPMOgkDBIAAI
  uHhlZrav6CqPwlE+8J3xxfFPPz/CDoMxwiugaEFyrj1XGp1vtGxmNsLxTzUkF8cWJvsmE0YcAYMBAghgIOCEEb/TU1i+vdwYs6Pv4jgOERFRuN+p7CxtLs1vlrb3twC0
  nWofOz863Hb93MlWAoGgtSaif7CvjZ1AETa3AAAAAElFTkSuQmCC
}

image create photo creator_small -data {
  R0lGODlhPABOAOf/ABQUHBwTExYVGBgUHhkVEh8UEB0WGygVFxkaIRkbGRwbFSAaFSQYHiQZFxgcHhwbHh8bGiQdFCgcFB8gJx8hHyUgGiMgIx0iIyofGyQhICkgISMj
  HDIgHjcgGyskGTAjGjEiJy0kJC8kIDUjHColKSomJSwmICUoJzsoGEEnHjspHUAnIzItGDgqJzsqIzYsHi4tMTEtLDQtJzUsMi8vKDguLy8yL08qIkssJEUtL0MvJEcu
  JEIvKTkyLEguKT4xKjY0KDczMjU1LTM1OlExKE4zKT43MTs5LUo2JTc7Ljo6MjU6QT86Kkc3MUs3K1szJE81Pl8yLkE5RFQ3Iz87OjU9STs9OlM3M0M9Jz48QDk+QFo3
  Jlw2Llo2NUY8P1g5L2E2OD1BSGE9NmM9MWA9PFpANGc8PWw9N0VHSlFERUlHRUNIUGdBME1GTnE/MlRHQlRGT0tKQ2NFMFxGQXNBRGxFPGpFQ2JJPHJGMXpCR09OUVJP
  TYZHOXpKQlpSV3ZMQnlNPXJOTXBQRIFNP2RTYV1XVntROlZaV19YUXZTP2xVT1hZY1laXY5TWIlWUYtXSYhbQG9gYH9eUGpjX2NlYIhcTWtkWHZhWZFbSHFhbGBna4Rg
  TGZmbIZfXGtlcZViVpRnWmxybn1ubJBpaJVqUXZve5JsXnJ0d4tvYXJ0fpVuWnt0bmx4gX97jKR1ZK10X595WKF5X5p7bXyChJ97ZaF6boWBfJx7d32Di3iEk5CAfLiD
  eqyJbKmIhayKcrCIe5qOiYmSoa2Lfa+NaI2Sm46TlqWOiKiPfrmTdrKWj8WShLeWhr2UibyYgZqfqJyho5mhsaefnL+dj7Khlrmgj7qfmMaio6WstMGmn8elmcKnmM6k
  l6qvsbKuqL6tpKmywciun8+toMqupsyxtcW4r7S8zNq1o9i2qda2sNK4qdG5sNe5pb6+wLvAyb3E1N/BrN/DtOPDvd7GvcPM28zMzM7P2crT5OzQx9DZ4dHc7dfk9vrf
  0+Pq6eDt/ebz+////yH+EUNyZWF0ZWQgd2l0aCBHSU1QACH5BAEKAP8ALAAAAAA8AE4AAAj+ABMkeGBAAwYNGg5oCFEhw4YEDhxYsCBAAIUYMnrIMFGiB5AeIIGIBCKk
  JJAjST4eYXLkCBAlQjYEMFDRQQIBDxJMzLAQoQYRIkqUoCAgwQaiFmnQiME0RpAeT0H2cFmyJUqVTE4eUQJkAwECRQVCTECBZwiEGESYCGEiwwMKZB9UpEBDho0YNIRI
  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
}
image create photo egais_83x36 -data {
  iVBORw0KGgoAAAANSUhEUgAAAFMAAAAkCAYAAAD1lQZ5AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wgFCBE4LmKySQAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAUr0lEQVRo3q2aeZhcVZXAf/e+tbaurt5DQmcjiIRASAgkRg0GJIMDOOAC6sC46ycjo+MyjhsIo844
  nxuDiqJ+Os4MmnEZ3BAX1oAETFgiYEwgna076S3p7lreeu/88aqqX3V3QvTzfd/7XtWr+27d97vnnHvuOUcopTTPc2it/6zfZ95/vn7+3LbHelZr3TyVUgDNa6ONEKLl
  WdM0m/cbvx3vc+MQQiBmwtRaI4SYE8TM++l7jWvjc/pl0s+lX2JmX+mB/Tkw54I4E+j0d0EyzOS7lBIpDWo1xbx57VRrPl7Nw3VtAKSUcwKVUk6PuwHzRKRrrjbPJ33H
  e36uiflzpXLmZDXgNQAqpYjjuAlz9MAk1WrAglM6yGaz5HI5LMsCBE9u28uBXYfY+DdnEIZxHbRsQkyfabgijmN9IoM7UTjHav980GvVEMNMpCUZvPiTVH4mxLQ0NkDG
  cdz8DhppSEqlTtoKhWY/u3ce5OCBw5y5ehFxpDAMAyFEC9CZ16bkpmGeCLiGzZkJb662c/engdkSuGPbAWrlgEzOpNSVZ8GiUh2GRkqB0hqBOI4GKbQmBXE2yCiKUCom
  jhVaK4b2T1EotHPe+tNa+vI8j3K5jG3beF6AlGAYRhNe+nOLxMZxrI8HYqYdmmnE57JTx7aHuv7C1KHW1bt+Df0IEEgpMB2D8bEapQ6XiaM1Sh1thKE/pylo9NlqGxVC
  QBBERFGMUjFhGBJFURPqwd2TXHjJi2grZpoTDBDHcfN/RodHiLTCNIwmRNM0W6S1CTSKIn0sAz4TUgPksYz77D5okcTp/xGAapFQrVW9rWaadfLsoaFJfC+if1EJISCO
  G9ohmhAbY1NKYZoWR0YnefKxEVau6UaTSGUYhsRxjGVZ1Go1Vq1eST6XP6758IOAQ0NDmKaJaZoYdahGCm5DWkUURfr5IM4E2Rh02sDHsUIpTbFYwHEcdjz5LB0dWSzb
  nAWzcSilsG0Tx7WJohitoFqrIZieCA1UJqoQm0xVQ7xKjf6lHcRKI8RskFpp/rDtMIWeHAtPzjBRq6FiTTab5ciRIyxduoT5808ijiMMwzyhxe3w4UOUy1PYtotlWU2o
  pmkipZyGGoahPp47MdOtSBvxxBZpwjDAdV06OtoRwsC2LcbHJhgeHsYwZcvKl6iRwjAEi5f28/MfPsmhPw5SKNi0d2VZtLKvCWl6YkGjqE369Mzrw/PLOI7N2Ng4hmGk
  JlmjVEyt7BNFEQefHWftBWdjSMWixQuJogjLsmb5lrPtL6Sb7PrjGPv372fR4gKWZTeBNs4GUBGGoT6WGs/lWiQwEyMex4pyWdFe7Ma0skwc2Y8mS3upg8mjRxkde5ZM
  1kaIZHUWQqK1QVtbNweeO8T23z7FmrUn07OkiyiOiQJFGEQti5XnCcAik3GQwqKntxfLtFFacfjQs0xOjdYnSFOtirq5CdAo4ijCNU5izYtWEEXxcQEm8BKCriv59L98
  n2uv20Q2V+CJhx9Eypj2eV1kXBfbToBaltWUUNM0EEEQ6LQEWraBIQ3KlSpxlJbCCMOIKZdjhoZ8fB+Gh+GGG7oZ2Ouw6owdXHjRKLv/2M5P78zwiguOsvZlPcRRyKkv
  CCmXTRYuDHjwAZObrg/40R2aQqdDFMa4dsDjjzv0dHsUSxIBmKamPKV517XLmZzKYEiFRia2VUuy2UOcs+o5li5rp1J1yGZ9br99CSqWXLhxO7YZsHtgGbt2l9DaAqGR
  aYEU05cmSJF8FhpMRzD43J10zFvH1VfezwUXLyKXtcjl8rgpoKZpYlomWkuE7/u6IZFCwG9+9Qy3fe1J/uPmTWTbrMSW6ZgojLn3PshmBVdd1U0uJwlDQbksAcGbrn6E
  Z/f2UCrF7HrK5JLLD/Pc04dY0C+ZvzBDrRKx+jwQWrLjccnqdQqtJJHS3HXnSXz9G4u57JJHufrqgMFBi+vesw7HiRgfz8yUIWCSxf072T+4EiEFcSSwLI3vG3XJ8sln
  Jxgd7216ESd+CMAjKzYTsZhAz+clLzFZveJe3vj2ZRhGgUwmg+M42LadwJQmE0fCBOa0OisOH67y2su2cs9Da6lUY6Io5IknBG9+S4Hhw0UgQgiDVndPAxKI6tfGFisA
  rPoAB7j69YOcf2GFn/+kxOnLFWev2svNXzyTe+97AcsWPUKx4PO7HafQ1RHje4qpan/St9CgxfS18dJCpb4f1wrWxzDbs2jeblF5heYgpfYKy5c8xpZtr+HCCwZZ/+Kj
  bNigmH9SFrRDvs3FcSxMy8QyTYTneXqmPbRkxGQlQsqQr9xqc+MnOgF7jhnWdPcoLFPMaYOqVThyVFIsxuRzBp4nkMInk1McPerwhqu2cu99/Tzzhx7OOfu3/O6Jl1Jq
  r+I6GQxDc/Soolw2mn1KCb29iQ/oeZrxcaMJo7cvxpCCONIcHjbSPgO9vYq+PoVSMHhQMjZu1H3h40nnFBdc+BOuuOxxPvuZv+O5A8sBWLH8OX5+Z5mRQzZdfQVcN6Xu
  6RU6jhPHthpHhEGIbQfs3xUnIIWexdI04Yf/pzj9VIvE9ZueecuC7/2PxzuvdfjY9Yq3vskkCHR9Uqi3OZcv3xxz/Y0TiOggqAHuvGs+SxeBYQiefFxx/sZpMB0dmoe2
  Kop5mzt/GvKGawAtWLhkip1P55iakhzcG7DyHIGQBlr5/OZezVlnOBiGri9UgvvvqXLFa2wQ5mzBbR4FekqDVHybBV2/r8PUPL1zIZdcOsU3vzkCJMwaHoVMuzyN3UHg
  BygVcv99gh/87KQ5QdZlhVJJ0NEp6O6CJGaim6OSIrkW8lAsQne3oFiEQkFTaINCwcAyB3nZ+q/z6O9fzbqX2pxxuklXl6BUEmx4mQHUmhMkJHR2CkolKLTVJ8T1GXg2
  i+NIurqgo1Tno3z2D8HGDS6dnfU9vwEdHYLLX53jq1+JmCWaAgQxve0/ZcPKL7Bw2UEqZYs3X7uHgvEEIIhjyciISxzFxHGU2uuDOdf+VciIH3xfs+WBEpMT7gkZcKWh
  r2+yvjWrt9ezHfabPuHx+6ctDCNR26GDBlt++0HQ8PrXdpPLCianIo5OKPoX2HzjVnjLO/UM+9c4Im6/HcCYpaY3fhIW9DkA/OgHHp/8dGJzb/+uybKlBv39mp7uiOER
  KyUaARlzN2vWb+OFp49iiFLiM1dcPv2pR/jPbwY8snMVg4Mut92W558+5KHUtCdkaq2bEhlFERDxxNYqH3h/P45TPOGVUAj48Y+z2I4EDVJqPvoRySOPtra77x7BA79N
  v/zJIDTFdsVZK5P/emhLzI6nNR94H2y6xMWyIsLQbPFptIKL/kpz+WX2nAvOmtVG02Z+7vOSbdsSaBdsjEBHTE44TJVlaq5jpH6WhcseY8nSYRyni1wuRybjYlsWbpvB
  +z6+h9F9Y3zsn/u47esrecPV+1iyOG764jJtL6MooloNOH2V5mUvruL78vgeRAtMwaWXOmy6yGLTJouXv9yku1vMkiU5c62qm5BTTol4yfoE2O3/FbNzp0msNMV22LhB
  zZLMzi7FF24GKQWjwxHjR6KWbp1EKJk4EjE5Mf2n+/eZ7N9vMjEpUSo1OG3iFkIu2nQ/+XwHhUKBQqFAPl8gly/gulnsjM0LzrO5f3uZt1/+IDd/NiKfn44PmOmdThiG
  COmz+Xs292yZXzfKYk73AZ04QjoVJLnmzTG5XCPsL3n8qYZsyJRiGq0zUe/g7/9BNV2qQhssPwtUDPmc5FWvhrvuFsSp59a/xAYEtQDWv1Sx5cH0PtvAC5MJKLYbWHac
  qI6GjS/3OGu5wfbtii0PO8TB9BiuuPx/yWa6aGtro1AokM1mmw66aZrYtoVlmFQih4/cnOf+zXsYGXsB7W11mGmpDMMQ3/fpLNVYxz1kRdR8by1FY7+AJgn7axQ5zgUs
  tIKHvrWZbor1sQlORrKILPPEUmA+AGeJx4jwMQ2B0gKBYFJ5vP5vNzZRfPFL2WTBqP/3pX8t2NSzjZqKMcTKFtX4zOu30j1k4ZorAImlfXrYird3GdAHwuANV9bwtt+L
  YRT49E2rWXOuwcSY4t2XPM2ORwM0gljBSX0+2VxnU72z7UUcIbFtOwXUxrYsylOaNZsWUJ3wKBUTUyMOHz6sfd+nVqtRrVaZmpriaBSw9o1vpHvfgeOrtwFqx07kaafO
  5Q7D4O9hwQq47evwlrck9158Bjz4VKu0v+da+PwtiRTv2Y0MoiQekM9jLDg5aXPmYjg0RrR3DDOT2L/gv7+D/cZrIGei940h2tqIdu3APPXMZPswMYlsK8xppcLN38W6
  8nXTg9bw0etvoCOTo5RxyZW6EXc9ROmqixDZHHZ9L97YRiaATYgEuWIOyzLrkllffPwgwBMaNTzGyJJT6d53YPby03LDJAwCjDCAWLW2Mwzi4RoWgjBUmFqhhSRWTuJp
  6oYJgPj9H0b6PkrHiBVnQqWGAKJFS9F7doNSeF+8lcxlryHyaiAVemwEcdON6AjQWULPR2ZCQj8xJCbgn70K+dVbketfBJlMMn/VCvGP70Bcd13zVYSG0fYSpz2zk0lR
  4NxnHqGtkOPJQcWy4Z3s+/CHka6DKWQzsJGE3UzMrETUrZg4ePCgrng+Za9KuHuA0rXvoa92hNz4GELPEMi0NIm6R9nVnXjvcx1RBKMj0NYOuSwCUKMjyCBsdQN6etBS
  gooRIyONmBsYBvT2TifbDg2he3qTZ+IIMTwy3UdvLzqJdsPIyLTLlski2ovTY4xC9Pg40g9aXTspUaaBLy2cMMCKI444eX5mncErxTPs2ryZ+KT5uIKmyluWhSENdKjI
  l3KIvQMDOn7wIdxvfIO+u3+DlhKRyvMIoCwzfLu4msVBmV9kX0goK7xrcisrvOHWFC3gCZNYGJhaIRBINMnSojB0PPdidqy9svgTYxQnEsPQf1rbP3zog9z9UIV33v8l
  Bq6/keqrrsBxnKb9NAwD00jsqtgzMKDzn/wUXbd9bc7/EcB7T7+U7UtdMr4kdMZQWlKYsNn8wC9wiZra7+Pw7cLZbJ1n0BOFWErjxjERmkBJbhx8DKnVXxaCmCOOoY9h
  5/Vsu67naJPuQyN4+JavMPTjJ+jKSAo3vIuca2LXgVqmSTjl09ZbxFRao/KZ406Y2RMzr2hjapByHkJA2K64QV9K6YDmygMPsiga4d9PO49tC4oETsywYSAQKKUJo4Co
  bPC7oVM4jz82B3zC6XF9Ar/p47TVDV4GP7NX8kCug3wE76hso1uNp3JOs/uQaFa9993cd+e9yK/eTuHJbciLNqKrIdKQjO46TEc0gehbiamV4tApZ1Jw8rh+uWUyYww8
  BDW7n65OE1s6zcyc1jF+b8TA2ojNT13IuY/u5DRgYOlJ2PXMHci6/+rjBx4f7TuHV/56KeWcz9ojBzm/uvMvqsXPd9zReTIfP9XFMY8SAzsOncvn9vyO+dHoLI4iFWVw
  wxDTm2DwlVfQ9ua38dz7Ys65bhMoMCWExc4kqLxr1y49EcWIf7uFVd+6pSnlv+xbx4FF3ZTdNvat76dg2ThOBtu2kVI2cy5xFBAIRaAlVBW2FSKlgZRGPTAQJzB9j1q1
  xlG/wpHKFG37Qr5z/49mw/xL28lUv/vyBT62di2T2VxS+IBHYbCN9z+9nbYKdDJFL4cBeGDZmSwcOEh/OAbA1htuJLrsYoYeHefsTcsQSpDJZhn4+TZWvG4DOogxAWSt
  ytF3vI7Hdu/n7C13MEGOX19zGW7WxzRM5mVcMpkMrutiWU6zyiEdJJkuMKAOkpZolO971GpV2ioVSpOTjGSq7NneweLyOPp4Kj1X8HYu3uIYfaRELMi45Pvmk81mmnmt
  oN3n1oVr0WGEUTFYv32Ec73dfO/8F3PFLx+mf28Cs3Prw+y76CIWn9ONX/HJZDLoWLHk4tWENT+JaTZyvk4Mk/94NWy5gy+f8S5OPbVEGGhM08BxnOZpWQ6macyqyphO
  yrVWbDRipEEQUKvVyOWqZLM5nMkJ7lq3ntfdfQ9GHOMQYDI76SV0io+AsuFw0CrQFvm0xT55FbQAnMlxUmRRhkQqTWS10dPRiS4WEEI0I2Vh6BMGEVEc8+gLO3mE5eRt
  g+2nr2Lj3u2J6+RmEVImHkqzigMMUzaLt8yGE+q4DsLO8CzdrHzbMirFUjO53thOpXPGSbpUHrcSJC2Zja1qtVrFdV1cx2VwfYabupfh7hnj7KE/8KqBrS0gpyiy326n
  MyzTq8dAw2/au/nX004jH1ucP1Tm2oGnqEiboUyBeZVJFtTVFGCn289X1l2AmcuTx8Fcmifb34ZrJlnFRvVGo9KjUaSglMK0LXraxygDeUDncpgzKzgErcVb+/bt057n
  4XkegecRD41Ty9vE9Tk2DKOZ1myATO5LtE5SuOlVOQ2zof6N8J7v+3ieR61Wo1yeolwuMzk1wcTkJP7oBBsGNWte2EmxmOFXW0b4ifccZVdheXDxaDttlmRsnsvP3CNg
  aEwNpZqiZoKvBZaIWbnFJV+LObSiwMRZJrq9SCGXJZfLk81kybjZpt1vgGiADMOQMIpQcYRftXjr4FNQrWGpmH3nrWPynDXkHZtMxm3ZWjYFbGhoSHueRxAEzU4btrBR
  TzO9fZouVkpmw5izGi1Z7VWzeCqKopTtnAZaqVQolyepVCpUKhWOlCswUSQMParGYVAhAoGQoBAIaWFIiWNJpEgWQQ3oejwRDTgC07LJWDYZK0sm65LNZpsZRcdxMU2r
  peCqoe5pKdVxTG/HWWx4xXIU8MjDD5NzHHK5XDMzObO6QwwPD+u0iDfEfDqJJWeV001XzYrmtVE02rg2ao2SBSo5oyhs2s8Eao1arUK1WmsCDkKPIAyJAoVS8awxNM50
  UWy6YEwI0dzq2badmBTXTQFwWgQjXXjRmHSlFErHVEcgX2xHWjGdvS6O46bWjukihMZppiu6GmrZgJku6my8QLpStrUUWaMULaUt05UgSRo5jqdNhmWZWFYSI8xksvi+
  3wSdfql0aU1iqyVCyGRvMkeWtwG78aJpe5/cM+uum5xVGjmzILaY15iWie24Lf00JmNmAez/A9S2TYdPjiBnAAAAAElFTkSuQmCC
}

image create photo butborder_1 -data {
  iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/4ePzL8A
  AAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfiBwgQIAv+vLqMAAAARElEQVQ4
  y+3UMRXAMAwD0VNegRhGtmLPZhhmolJwlk6+WX+VzHHRK3j1HBdbPZDGqz+HrWJx
  2YABA34FQbo7Tge6vZkPvOMTzlppi8IAAAAASUVORK5CYII=
}

image create photo butborder -data {
  iVBORw0KGgoAAAANSUhEUgAAAFQAAAAYCAYAAABk8drWAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4woCESwgowaRhwAAAB1p
  VFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAABk0lEQVRYw+2Zr0+CURSG33uFKz8dzkGgyLQZKGx2G0IjmggmGv8GhUZyjESksVG0WdzEiWLDYSHA
  DIqg3wXuMSjbF/38Ptp5/oRn73vPObuicfUY+VqYabs3wutMQwoB5u8YIuyFFfLpJAJ+GfXN9WraePnE7umJiQbVBATJmhwgYPSnjtev72RxPzhFrtKhbN9alYe6xXb+
  R3moW9m+tcpVOiTf5hqk1KSaUoXSwOK+O6Q0sEQ1pQqk1ORtriHFz5spAaB2uE2syBk2Z1IIwe+l10gAIOJgumXt8FcoC3Ev1JZQnkRebE/2yguOqOuEClvlwT49MGpL
  6GK5ZCEuWTvktWkza5NhE66nvOGEbi6hPJU8mEnECd1YQjmgHq9NfMt7fMszHlbeEIEAAwBnt2M+6x2ydkaAMUSQsZAf0tLxYnfcamYS3H2HNDMJKnbHLWnpeCzkh6h1
  7uni+QPh4yNjlH8CIn4GnCCEkXoRn908yfODCET98iEys1bTdm+E968lfyM7xBBhJ+BDPp1EeHsr+g3JAqn15VL+ugAAAABJRU5ErkJggg==
}

image create photo icon_openfile_18x16 -data {
  iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wYXCDgNebfI9AAAAgZJ
  REFUOMuNkz9PFUEUxX/3zuxbQAlSkGhhaWEwRhNbY6Extmhi7Kz5CH4P/RZY2FnYEG20sKOSaExEBNTn44+P3Tdzr8U8Hw8k4G0mszvn5PzO7MrrO/PcfLXCSfPm3pXr
  9bnwLtQS8SMvFZqttCwAbxeuznY/9BfcCQcnisL3SDPzE4/mF8/f7cxViEp5bg6tE6ciK0/XiADd1f7Da08uPtOACoK7I5WgAFGQCZE4HQ6Fsex4MthLuHkxcqeuJlVj
  LSK1IB1BRJApxRsjnlXcIXrA1BGHrJABQkkYAVK3az64gHcEiQEUpFLUgQ5IE1B1jIRkcBfwDA4SO2AQt148eD59+fYNjb8LvgqFCeRIqYfqc8j9lv7Hl0gUos7N3a8v
  LY6dEP53rPeN9v3SAVqZ3eFWjokwFgMbWw0VGTfKuPdAAhBOSZYYadgGP2S0A/KjiD2AnIDnBmLFUH7hB7dmwAbwtRhJOAZr1ApIGqZNwC4iERgQsQxs4qwNseQELB8Z
  iifE+5AFHCJmwHfUNgDFVE8xy6g5WAJaDMXxv2hdaDYhhvIRov/6+BANIDlYhpRHNUSJWjaxLSVbUbkabo7j5Uc1QV2LLghEJ2TDg2KND+L+6pfl9fWlW4PeLm030/40
  9rcb0p7R9MCahJ6pqCedaiZQz1R0ZiOdWSVMKe3nwafBjj3+A1B95HRZw8dhAAAAAElFTkSuQmCC
}

image create photo up -data {
  iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAIAAABVpBlvAAAACXBIWXMAAA7EAAAO
  xAGVKw4bAAAAB3RJTUUH4wIKDRkw/Hh6bwAAABVJREFUCNdj/P//PwMqYGLAAPQX
  AgDFpQMNg52XXAAAAABJRU5ErkJggg==
}

image create photo frameFocusBorder -data {
  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
}
image create photo frameFocusBorder_ME -data {
  iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACu0lEQVR4nO2bz2oTURSHv0rQKjGuk4LoSoRCKejCpX8eIZBlFyJU
  ENwJgbyBG4vaRV9BfAI3PoAtunDhzkKbQjdCjNVK4Lg4M2MymZlkJuaeZrwfDMy9M7n87o9zZ+6Qc5ZERChAD9gFjoKjX2SQGagCdaAB3AraRVjKa8A28Ab4DKwGIuoz
  CChKHzW+C3wC1oEm8DjvQDIlL0TkvIh0RIQzenREZFlEXk47KRGZGAGnQAu4BmzlddeIJ8ABGqmVCfdmGrAP3EBNWEQqwFdgJeOec2kX9oGHLO7kAQbABhoNaSRGwClw
  hcWe/DAV4CfJyyExAlqUZ/KgkdBKuTZmwBb6wCsbdeB1Qv/YErgA/HYiyT2XgB+xvpEI2AaeOZPjnqfATqxvJALuAu9dKjLgAfBuqB1FQA/d3padPeBkqB0ZsIvu7cvO
  KvBhqB0ZcIQ+KctOA/2ACvEGhCd93H/SWlBDn3chqd8C/wveAGsB1ngDrAVY4w2wFmCNN8BagDXeAGsB1ngDrAVY4w2wFmCNN8BagDXeAGsB1ngDrAVY4w2wFmCNN8Ba
  gDXeAGsB1ngDrAVY4w0IT6q4T3m3oIf+RR4SGVBHkyTKThdNkgiJDIhnTpSVQ0aTp6M0uT5wFfhmocohl4FjYDlojzwD1i0UOeYOfycPsbdAE+g4leOWNjrHYcZyhS8C
  v5xJcksV+B7rG0uhfw58AV65UOSQTWAtoX9sIxTW25SNY9SEOIkVIwN0KQzmrcohaYVRiVvhsNjo/rzUOOQe2fubzKqxA+A6ix0JXbJTgCfWDYb1NmklJ2eRTXTNv53i
  3olfg5VgoJtoyUl7JmnzpY2+6taYbvJQoHZ4B63I3ENz7xvBUcv60RzooeF9CHxEd3hN4FHOcXIbEHKCFh50g6OXffs/p4YavwLcZnR7m4fCBpSFP3XFbwLEpZMiAAAA
  AElFTkSuQmCC
}
image create photo frameBorder -data {
  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
}
image create photo frameBorder_ME -data {
  iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSqVUHNpBxCFDdbIgKiK4aBWKUCHUCq06mFz6BU0a
  khQXR8G14ODHYtXBxVlXB1dBEPwAcXJ0UnSREv+XFFrEenDcj3f3HnfvAKFRYZoVGAM03TbTyYSYza2KwVcEEEEIMxBkZhlzkpRC1/F1Dx9f7+I8q/u5P0efmrcY4BOJ
  Z5lh2sQbxFObtsF5nzjKSrJKfE48atIFiR+5rnj8xrnossAzo2YmPU8cJRaLHax0MCuZGvEkcUzVdMoXsh6rnLc4a5Uaa92TvzCc11eWuU5zCEksYgkSRCiooYwKbMRp
  1UmxkKb9RBf/oOuXyKWQqwxGjgVUoUF2/eB/8LtbqzAx7iWFE0DPi+N8DAPBXaBZd5zvY8dpngD+Z+BKb/urDWD6k/R6W4sdAf3bwMV1W1P2gMsdYODJkE3Zlfw0hUIB
  eD+jb8oBkVsgtOb11trH6QOQoa5SN8DBITBSpOz1Lu/u7ezt3zOt/n4AVTVym0Un0MQAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAHdElNRQfkBBMLHir1grRtAAAAGXRF
  WHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAX5JREFUaN7t2k9qwkAUBvDvvckiJBRBN8ErCP7Zu/AIHsZjeBiP4MK9VfAKko2CtBHBZl4XEdF2m6ad8n2r
  gcDk/TIzmc0TM8NDSsPu6Lcn2xS2vjw9+sWMYhmk0m9Jr61Onh7JI+D14Be5X53/St3fM05kmumwo18BlxLLvJzvPULIrKuTzMUOAG6UgKoHMN/7ZV5WY612TkDV3w2v
  Bw9AS8MiD6z6KovclwbdHZs7tQZ4oK6Xrc62O/poe7JmSlcgdYgEV0NRQuqYdnsy3RQNfX4RJA4vEWKtbRE2hWmTt5UCcv/x1ZH1xaLGqjfD+wec4Gr17J8qDQEEMOCt
  OsJS5yI0twK3S0d+YM6gQwABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAFhAUaxhFv9KBYdpAEDBqlovxUwoN8S7bV1nARpGCfSa6s6wTQL8ihPM3VV
  69Gwo7NuYIZZ99aAfKt7krmADFXrcTX+L83f9wTXfv8JCp2Yg9lClNkAAAAASUVORK5CYII=
}
image create photo labelframeBorderME -data {
  R0lGODlhDwATAKUuAJaWlpqampubm5ycnKGhoaSkpKWlpaampqenp6mpqaqqqq2tra6urrCwsLi4uL6+vsHBwcLCwsfHx8nJycvLy83Nzc/Pz9DQ0NTU1NXV1dnZ2dzc
  3N3d3eDg4OPj4+jo6Ovr6+7u7u/v7/Hx8fLy8vT09PX19fb29vf39/r6+vz8/P39/f7+/v///+/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w
  8e/w8e/w8e/w8e/w8SH+EUNyZWF0ZWQgd2l0aCBHSU1QACH5BAEKAD8ALAAAAAAPABMAAAZkwFarwxgIjsiDRSWkNECnqPQ0mihUIcNKyO22JpdKxksmISIcshc1gKTV
  XJTADY/P33U5vd7S4+F+fH13goF8hnmEhwISGoImBB4OghsQLAsYLHAfAyUtKQ8ABQekpAYBCSItQQA7
}
image create photo labelframeBorderME_invert -data {
  R0lGODlhDwATAKUuAICAgIiMjYqSloyWm42Wm46Wmo2XnI+aoI+boZGboJCco5OcoJGepZGfppSfpZKgppahppSkrJSlrZipsZmtt5quuKGutJ6wuZuxu6a2vaO+yqO+
  y6nCzqvJ16zL26zM27rO17XQ3bfT4LfU4rPX6LPY6bva6bri9brj9rvl+L7o/L7p/L7p/czt/O/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w8e/w
  8e/w8e/w8e/w8e/w8SH+EUNyZWF0ZWQgd2l0aCBHSU1QACH5BAEKAD8ALAAAAAAPABMAAAZXQJbKE0ksjsiHJsVaYSagn3QqtShQnwt1K81UJCIuN2AQcwED8xatprLb
  0jdc3qar7Wa8WH9Ow38ADCZ/BRsccCENKQgdLWYjByUsJxQCDhCYmQQMJCxBADs=
}
ttk::style element create RoundedLabelFrame image \
{labelframeBorderME focus labelframeBorderME} \
-border 4 -sticky nsew
ttk::style layout RoundedLabelFrame {
  RoundedLabelFrame -sticky nsew
}
ttk::style configure RoundedLabelFrame -padding 10


ttk::style element create RoundedFrame image \
{frameBorder focus frameFocusBorder} \
-border 16 -sticky nsew
ttk::style layout RoundedFrame {
  RoundedFrame -sticky nsew
}
ttk::style configure RoundedFrame -padding 10
ttk::style element create RoundedFrameME image \
{frameBorder_ME focus frameFocusBorder_ME} \
-border 16 -sticky nsew
ttk::style layout RoundedFrameME {
  RoundedFrameME -sticky nsew
}
ttk::style configure RoundedFrameME -padding 10
ttk::style configure RoundedFrameME -background red
ttk::style configure TFrame -background white

# scrollbar: arrows removed; background changes disabled by putting an empty
# list in ttk::style map
global myDir
set mydir [file dirname [info script]]
set dd [encoding dirs]
encoding dirs [list $dd $mydir]
set myDir $mydir
set ::px2mm [winfo fpixels . 1m]
set ::signedCert ""

if {1} {
  package provide ttk::theme::Breeze
  source [file join $myDir breeze.tcl]
  ttk::style theme use Breeze
  #package provide ttk::theme::scid 0.9.1
  #source scidthemes.tcl
  #ttk::style theme use scidblue
}
msgcat::mclocale ru
source [file join $mydir tkfe.tcl]


# 93cee9 меняем на skyblue

ttk::style map MyBorder.TButton -background [list disabled white pressed gray64 active skyblue !active #e2e2e1]

ttk::style configure MyBorder.TButton -background #e2e2e1  -borderwidth 1
ttk::style configure MyBorder.TButton  -font TkFixedFont -padding 2
# ff6a00
#ttk::style map My.TButton -background [list disabled #c0bab4 pressed gray64  active chocolate ] -foreground [list disabled gray64] -relief [list {pressed !disabled} sunken]
#ttk::style configure TButton -background skyblue
#ttk::style configure My.TButton -background skyblue
ttk::style configure My.TButton  -font TkFixedFont  -padding 6
ttk::style configure TButton  -padding 6
set ss [expr int(4)]
ttk::style configure TEntry  -padding -3
ttk::style configure TCheckbutton  -background white
ttk::style configure My.TCheckbutton  -foreground red
ttk::style configure TLabelframe -background  white
ttk::style configure Me.TEntry -background  white
#skyblue
ttk::style configure TLabelframe.Label -background  white
#skyblue
ttk::style configure TRadiobutton  -background white -pad 0

option add *Label.background	white interactive
option add *Labelframe.background	white interactive
option add *Frame.background	white interactive
option add *Entry.background	white interactive
option add *Entry.highlightthickness 1 interactive
option add *Entry.highlightbackground skyblue interactive
option add *Entry.highlightcolor skyblue interactive

set ::pkcs11_status -1

set ::filetypesrc {
  {{File for sign (MS)} {.doc}}
  {{File for sign (MS)} {.docx}}
  {{File for sign (TXT)} {.txt}}
  {{File for sign (BIN)} {.bin}}
  {{File for sign (PDF)} {.pdf}}
  {{File for sign (XML)} {.xml}}
  {{All Files} *}
}
set ::filetypep7s {
  {{PKCS7 (DER)} {.p7s}}
  {{PKCS7 (DER)} {.sig}}
  {{PKCS7 (DER)} {.p7b}}
  {{PKCS7 (PEM)} {.pem}}
  {{All Files} *}
}

#set ::ku_options {digitalSignature nonRepudiation keyEncipherment dataEncipherment keyAgreement keyCertSign cRLSign encipherOnly decipherOnly}
#set ::ku_options {"Digital signature" "Non-Repudiation" "Key encipherment" "Data encipherment" "Key agreement" "Certificate signature" "CRL signature" "Encipher Only" "Decipher Only" "Revocation list signature"}
set ::ku_options {"Цифровая подпись" "Неотрекаемость" "Шифрование ключа" "Шифрование данных" "Согласование ключа" "Подпись сертификата" "Подпись СОС/CRL" "Только шифровать" "Только расшифровать" "Аннулирование списка подписей"}

set ::bc_options {
  {}
  {CA:FALSE}
  {critical, CA:FALSE}
  {CA:TRUE}
  {critical, CA:TRUE}
}
set ::bc ""

set ::oidegais { 1.3.6.1.5.5.7.3.2
  1.2.643.2.2.34.6
  1.2.643.5.1.28.2
  1.2.643.5.1.28.3
  1.2.643.3.6.78.4.5
  1.3.6.1.5.5.7.3.4
  1.2.643.3.6.0.12
}
set ::oidlizfsrar    1.2.643.5.1.28.4
#set ::oidalko "1.2.643.3.6.78.4.4"
set ::prettyTagType  {

  "End of Contents"
  "Boolean"
  "Integer"
  "Bit String"
  "Octet String"
  "NULL"
  "Object Identifier"
  "0x07"
  "0x08"
  "0x09"
  "Enumerated"
  "0x0B"
  "UTF8 String"
  "0x0D"
  "0x0E"
  "0x0F"
  "Sequence"
  "Set"
  "Numeric String"
  "Printable String"
  "T61 String"
  "0x15"
  "IA5 String"
  "UTC Time"
  "Generalized Time"
  "0x19"
  "Visible String"
  "0x1B"
  "Universal String"
  "0x1D"
  "BMP String"
  "High-Tag-Number"
};
#    "0x12" -     "Numeric String"

set ::prettyColumn  0

variable SEC_ASN1_TAGNUM_MASK
set ::SEC_ASN1_TAGNUM_MASK 0x1f
set ::SEC_ASN1_HIGH_TAG_NUMBER 0x1f
set ::SEC_ASN1_CONSTRUCTED 0x20
set ::SEC_ASN1_CLASS_MASK 0xc0
set ::SEC_ASN1_UNIVERSAL 0x00
set ::SEC_ASN1_APPLICATION 0x40
set ::SEC_ASN1_CONTEXT_SPECIFIC 0x80
set ::SEC_ASN1_PRIVATE 0xc0

set ::SEC_ASN1_BOOLEAN 0x01
set ::SEC_ASN1_INTEGER 0x02
set ::SEC_ASN1_BIT_STRING 0x03
set ::SEC_ASN1_OCTET_STRING 0x04
set ::SEC_ASN1_NULL 0x05
set ::SEC_ASN1_OBJECT_ID 0x06
set ::SEC_ASN1_OBJECT_DESCRIPTOR 0x07
# External type and instance-of type   0x08
set ::SEC_ASN1_REAL 0x09
set ::SEC_ASN1_ENUMERATED 0x0a
set ::SEC_ASN1_EMBEDDED_PDV 0x0b
set ::SEC_ASN1_UTF8_STRING 0x0c
set ::SEC_ASN1_NUMERIC_STRING 0x12
set ::SEC_ASN1_T61_STRING 0x14
set ::SEC_ASN1_UNIVERSAL_STRING 0x1c
set ::SEC_ASN1_BMP_STRING 0x1e
set ::SEC_ASN1_PRINTABLE_STRING 0x13
set ::SEC_ASN1_IA5_STRING 0x16
set ::SEC_ASN1_VISIBLE_STRING 0x1a
set ::SEC_ASN1_UTC_TIME 0x17
set ::SEC_ASN1_GENERALIZED_TIME 0x18
#VREMENNO
set ::SEC_ASN1_GENERALIZED_TIME_BAD 0x99

set ::RIGHT_MARGIN 24

#Проверка полей запроса/сертификата
set ::checkfull 0

proc prettyNewline {out} {
  if {$::prettyColumn != -1} {
    if {[catch {$out insert end "\n"} res]} {
      return -1
    }
    set ::prettyColumn -1
  }
  update
  return 0;
}


proc prettyIndent {out level} {
  if {$::prettyColumn == -1} {
    set ::prettyColumn $level;
    for {set i 0} {$i < $level} {incr i} {
      catch {$out insert end "   "};
    }
  }

  return 0;
}

proc prettyPrintByte {out item level tag} {
  if {[catch {$out tag configure rawAsn -foreground red} res]} {
    return -1
  }
  #005400
  if {[catch {$out tag configure asnfix -font TkFixedFont } res]} {
    return -1
  }

  set rv  [prettyIndent $out $level];
  if {$tag} {
    $out insert end [format "%02x "  $item] rawAsn
  } else {
    $out insert end [format "%02x "  $item] asnfix
  }

  incr ::prettyColumn
  if {$::prettyColumn >= $::RIGHT_MARGIN} {
    return [prettyNewline $out];
  }

  return 0;
}

proc prettyPrintStringStart {out str len level} {
  set BUF_SIZE 100
  incr len -1

  if {$len >= $BUF_SIZE} {
    set len  [expr  $BUF_SIZE - 1]
  }

  set rv [prettyNewline $out];
  if {$rv < 0} {
    return $rv;
  }

  set rv [prettyIndent $out $level];
  if {$rv < 0} {
    return $rv;
  }


  set buf [string range $str 0 $len];

  #    $out insert end  [format "\"%s\"" $buf];
  if {[catch {$out insert end  [format "\"%s\"" [encoding convertfrom utf-8 $buf]]} res]} {
    return -1
  }
  return 0;
}

proc prettyPrintString {out str len level raw} {
  set rv [prettyPrintStringStart $out $str $len $level];
  if {$rv < 0} {
    return rv;
  }

  set rv [prettyNewline $out];
  if {$rv < 0} {
    return $rv;
  }

  if {$raw} {
    set rv [prettyPrintLeaf $out str $len $level];
    if {$rv < 0} {
      return $rv;
    }
  }

  return 0;
}



proc prettyPrintLeaf1 {out data_var len lv} {
  upvar 1 $data_var data1
  set data $data1

  for {set i 0} {$i < $len} {incr i} {
    ::asn::asnGetByte data tbyte
    set rv [prettyPrintByte $out $tbyte $lv 0];
    if {$rv < 0} {
      return $rv;
    }
  }
  return [prettyNewline $out];
}
proc prettyPrintLeaf {out data_var len lv} {
  upvar 1 $data_var data
  #    set data $data1

  for {set i 0} {$i < $len} {incr i} {
    ::asn::asnPeekByte data tbyte $i
    set rv [prettyPrintByte $out $tbyte $lv 0];
    if {$rv < 0} {
      return $rv;
    }
  }
  return [prettyNewline $out];
}

proc getInteger256  {data_var nb} {
  set data $data_var

  ::asn::asnGetBytes data $nb lengthBytes

  switch $nb {
    1 { binary scan $lengthBytes     cu length }
    2 { binary scan $lengthBytes     Su length }
    3 { binary scan \x00$lengthBytes Iu length }
    4 { binary scan $lengthBytes     Iu length }
    default {
      binary scan $lengthBytes H* hexstr
      scan $hexstr %llx length
    }
  }
  return $length
}

proc prettyPrintLength {out data_var len_deritem lenp_var indefinitep_var lv raw} {
  upvar 1 $data_var data1 $indefinitep_var indefinitep $lenp_var lenp

  $out insert end " ";

  set indefinitep 0

  set data $data1
  ::asn::asnGetByte data lbyte

  set lenLen  1;
  if {$lbyte >= 0x80} {
    # Multibyte length
    set nb [expr $lbyte & 0x7f];
    if {$nb > 4} {
      return -1;
    }
    if {$nb > 0} {
      if {$nb > $len_deritem} {
        return -1;
      }
      set il [getInteger256 $data $nb];
      if {$il < 0} {
        return -1;
      }
      set lenp $il;
    } else {
      set lenp  0;
      set indefinitep 1
    }
    incr lenLen $nb;
    if {$raw} {
      set rv  [prettyPrintByte $out $lbyte $lv 0]
      if {$rv < 0} {
        return $rv;
      }

      for {set i 0} {$i < $nb} {incr i} {
        ::asn::asnGetByte data di
        set rv [prettyPrintByte $out $di $lv 0]
        if {$rv < 0} {
          return $rv;
        }
      }
    }
  } else {
    set lenp  $lbyte;
    if {$raw} {
      set rv [prettyPrintByte $out $lbyte $lv 0]
      if {$rv < 0} {
        return rv;
      }
    }
  }
  if {$indefinitep} {
    $out insert end "(indefinite)\n";
  } else {
    $out insert end  [format "(%d)\n" $lenp];
  }

  set ::prettyColumn  -1;
  return $lenLen;
}


proc prettyPrintTag {out src_var end codep_var level raw} {
  if {[catch {$out tag configure tagAsn -foreground blue } res]} {
    return -1
  }
  upvar 1 $src_var src $codep_var codep
  if {[catch { ::asn::asnPeekByte src code } res] } {
    #	puts "BEDA=$res"
    return -1
  }
  #    ::asn::asnPeekByte src code
  if {![info exists code]} {
    return -1
  }
  #    puts "PrintTag: ::prettyColumn=$::prettyColumn level=$level, code=[format {0x%02x} $code]"
  set tagnum [expr $code & $::SEC_ASN1_TAGNUM_MASK ]

  #     * NOTE: This code does not (yet) handle the high-tag-number form!

  if {$tagnum == $::SEC_ASN1_HIGH_TAG_NUMBER} {
    return -1;
  }

  if {$raw} {
    set rv [prettyPrintByte $out $code $level 1]
  } else {
    set rv  [prettyIndent $out $level]
  }

  if {$rv < 0} {
    return $rv;
  }

  if { [expr $code & $::SEC_ASN1_CONSTRUCTED]} {
    $out insert end "C-" tagAsn
  }
  set class [format "0x%02x" [expr $code & $::SEC_ASN1_CLASS_MASK ]]

  switch -- $class \
  $::SEC_ASN1_UNIVERSAL  { \
    $out insert end [format "%s " [lindex $::prettyTagType $tagnum]] tagAsn \
  } \
  $::SEC_ASN1_APPLICATION { \
    $out insert end [format "Application: %d " $tagnum] tagAsn \
  } \
  $::SEC_ASN1_CONTEXT_SPECIFIC { \
    $out insert end [format "\[%d\] " $tagnum] tagAsn \
  } \
  $::SEC_ASN1_PRIVATE { \
    $out insert end [format "Private: %d " $tagnum] tagAsn \
  }

  set codep $code;
  return 1;

}
proc prettyPrintObjectID {out  data len level raw} {
  #    First print the Object Id in numeric format
  #    puts " prettyPrintObjectID len=$len level=$level "
  set rv [prettyIndent $out $level ];
  if {$rv < 0} {
    return $rv;
  }

  if {$len == 0} {
    return -1;
  }
  set dataobj [string range $data 0 [expr $len - 1] ]
  set obj [binary format H2a*a* 06 [::asn::asnLength $len] $dataobj]
  binary scan $obj H* obj_hex
  #puts "obj_hex=$obj_hex"

  ::asn::asnGetObjectIdentifier obj oidalgo
  #puts "oidalgo=$oidalgo"

  #    Now try to look it up and print a symbolic version.
  set oiddata ""
  set oiddata [::pki::_oid_number_to_name $oidalgo]
  #puts "oiddata=$oiddata"

  $out insert end "$oidalgo ";
  if { $oiddata != "" } {
    set i [string length $oiddata]
    set i [expr $i / 3]
    incr i
    set pc [expr $::prettyColumn + $i]
    if {$pc > $::RIGHT_MARGIN } {
      set rv [prettyNewline $out];
      if {$rv < 0} {
        return $rv;
      }
    }
    set rv [prettyIndent $out $level];
    if {$rv < 0} {
      return $rv;
    }
    #	set oiddata [string toupper $oiddata]
    set oiddata1 [string toupper $oiddata]
    if {[info exists ::dn_fields($oiddata1)]} {
      set oiddata $::dn_fields($oiddata1)
    }
    $out insert end "\($oiddata\)";
  }

  set rv [prettyNewline $out];
  if {$rv < 0} {
    return $rv;
  }

  if {$raw} {
    set rv [prettyPrintLeaf $out data $len $level];
    if {$rv < 0} {
      return $rv;
    }
  }

  return 0;
}

proc prettyPrintTime {out str len level raw utc} {
  set rv [prettyPrintStringStart $out $str $len $level];
  if {$rv < 0} {
    return $rv;
  }

  $out insert end " ("

  incr len -1
  set str [string range $str 0 $len]
  #    puts "TIME=$str"
  if {$len == 11} {
    set tt_utc [clock scan $str -format {%y%m%d%H%M%S} -gmt $utc]
  } else {
    set tt_utc [clock scan $str -format {%y%m%d%H%M%SZ} -gmt $utc]
  }
  set dateSign [clock format $tt_utc]
  $out insert end "$dateSign"

  $out insert end ")"

  set rv [prettyNewline $out];
  if {$rv < 0} {
    return $rv;
  }

  incr len
  if {$raw} {
    set rv [prettyPrintLeaf $out str $len $level];
    if {$rv < 0} {
      return $rv;
    }
  }

  return 0;
}

proc prettyPrintItem {out data_var lendata lv  raw} {
  upvar 1 $data_var data
  set orig $lendata
  set tdata 0
  #puts "prettyPrintItem START: lv=$lv, ::prettyColumn=$::prettyColumn, length_orig=$orig, lendata=$lendata"
  set slen 0
  set code ""
  while { $lendata > 0} {
    set slen1  [prettyPrintTag $out data $lendata code $lv $raw ]
    #puts  "prettyPrintItem WHILE: lv=$lv, ::prettyColumn=$::prettyColumn, code=$code, slen1=$slen1, lendata=$lendata"
    if {$slen1 < 0} {
      return $slen1;
    }
    set data [string range $data $slen1 end]
    set lendata [expr $lendata - $slen1]
                    	
    set lenLen [prettyPrintLength $out data $lendata slen indefinite $lv $raw]
    #puts "prettyPrintItem: lenLen=$lenLen, lendata=$lendata, slen=$slen, lenData=[string length $data], code=$code";
    if {$lenLen < 0} {
      return $lenLen;
    }
    set data [string range $data $lenLen end]
    if {$slen > $lendata} {
      return -1
    }
                    	
    set lendata [expr $lendata - $lenLen]

    if { [expr $code & $::SEC_ASN1_CONSTRUCTED]} {
      #puts "prettyPrintItem code=$code  ::SEC_ASN1_CONSTRUCTED ::prettyColumn=$::prettyColumn slen=$slen indefinite=$indefinite"
      if {$slen > 0 || $indefinite} {
        #puts "prettyPrintItem slen=$slen lv=$lv  ::SEC_ASN1_CONSTRUCTED ::prettyColumn=$::prettyColumn code=$code"
        set lv1 $lv
        incr lv1
        if {$slen == 0} {
          set slen [prettyPrintItem $out data $orig $lv1 $raw];
        } else {
          set slen [prettyPrintItem $out data $slen $lv1 $raw];
        }
        #puts "prettyPrintItem1 slen=$slen lv1=$lv1  ::SEC_ASN1_CONSTRUCTED ::prettyColumn=$::prettyColumn code=$code lendata=$lendata"
        set lendata [expr $lendata - $slen]

        if {$slen < 0} {
          return $slen;
        }
      }
    } elseif {$code == 0} {
      if {$slen != 0 || $lenLen != 1} {
        return -1;
      }
      break;
    } else {
      set class [format "0x%02x" $code]
      switch -- $class \
      $::SEC_ASN1_PRINTABLE_STRING - $::SEC_ASN1_IA5_STRING - $::SEC_ASN1_VISIBLE_STRING - $::SEC_ASN1_UTF8_STRING - $::SEC_ASN1_NUMERIC_STRING { \
        set lv1 $lv; \
        incr lv1; \
        set rv [prettyPrintString $out $data $slen $lv1 $raw]; \
        if {$rv < 0} { \
          return $rv; \
        } \
      } \
      $::SEC_ASN1_UTC_TIME { \
        set lv1 $lv; \
        incr lv1; \
        set rv [prettyPrintTime $out $data $slen $lv1 $raw 0]; \
        if {$rv < 0} { \
          return $rv; \
        } \
      } \
      $::SEC_ASN1_GENERALIZED_TIME_BAD { \
        set lv1 $lv; \
        incr lv1; \
        set rv [prettyPrintTime $out $data $slen $lv1 $raw 1]; \
        if {$rv < 0} { \
          return rv; \
        } \
      } \
      $::SEC_ASN1_OBJECT_ID { \
        set lv1 $lv; \
        incr lv1; \
        set rv [prettyPrintObjectID $out $data $slen $lv1 $raw]; \
        if {$rv < 0} { \
          return $rv; \
        } \
      } \
      $::SEC_ASN1_BOOLEAN - $::SEC_ASN1_INTEGER - $::SEC_ASN1_BIT_STRING - $::SEC_ASN1_OCTET_STRING - $::SEC_ASN1_NULL - $::SEC_ASN1_ENUMERATED - $::SEC_ASN1_T61_STRING - $::SEC_ASN1_UNIVERSAL_STRING - $::SEC_ASN1_BMP_STRING - default { \
        set lv1 $lv; \
        incr lv1; \
        set rv  [prettyPrintLeaf $out data $slen $lv1]; \
        if {$rv < 0} { \
          return $rv; \
        } \
      }

      set data [string range $data $slen end]
      set lendata [expr $lendata - $slen]
    }
  }

  set rv [prettyNewline $out];

  set ldata [expr $orig - $lendata]

  #puts  "prettyPrintItem: END RETURN4 lv=$lv, ::prettyColumn=$::prettyColumn, lendata=$lendata, return(orig-data)=$ldata,length_data=[string length $data]"
  return [expr $orig - $lendata]

}
proc DER_PrettyPrint {fdout deritem raw} {
  set ::prettyColumn -1;
  set len_deritem [string length $deritem]
  puts "LEN=$len_deritem"
  set rv [prettyPrintItem $fdout deritem $len_deritem 0 $raw];
  if {$rv < 0} {
    return -1;
  }
  return 0;
}
set ::lastFunc 0
set ::wrapup 0
proc changecolorleave {tekbut} {
  set tekfr ".st.fr1.fra82"
  set i $tekbut
  #    set stat [$tekfr.b$i cget  -state]
  #    if {$stat == "disabled"} {
  #	return
  #    }
  if {$i != $::lastFunc} {
    $tekfr.b$i configure  -background white
  } else {
    $tekfr.b$i configure  -background #b4ccea
  }
}
proc changecolorpress1 {tekbut} {
  set tekfr ".st.fr1.fra82"
  set i $tekbut
  set stat [$tekfr.b$i cget  -state]
  if {$stat == "disabled"} {
    return
  }
  $tekfr.b$::lastFunc configure -background white;
  $tekfr.b$i configure  -background #b4ccea;
  set ::lastFunc $i
}
proc wrapunwrap {} {
  set tekfr ".st.fr1.fra82"
  if {$::wrapup == 1} {
    set ::wrapup 0
    pack forget $tekfr.stend
    pack $tekfr.forbut -side top  -padx {0 0} -pady {0 0} -anchor w
    pack $tekfr.stend -side top -padx {0 0} -anchor w
    $tekfr.stfirst.br configure -image verchlefttoright_22x24
  } else {
    set ::wrapup 1
    pack forget $tekfr.forbut;
    $tekfr.stfirst.br configure -image verchlefttoright1_24x24
  }
}

set ::ku0 1
set ::ku1 1
set ::ku2 1
set ::ku3 1
for {set i 4} {$i <= 9} {incr i} {
  set ::ku$i 0
}
set ::pointca ""
set ::typeIdKind 2
set ::rpw ""
set ::pw ""

set ::tokeninfo ""
#"[mc {Token information}]:\nМетка:\nПроизводитель:\nТип:\nСерийный номер:\nНомер слота:"
set ::listtok {}
set ::handle ""
set ::pkcs11_module ""
set ::listx509 {}
set ::listx509S {}
set ::slotid_teklab ""
set ::slotid_tek -1
set ::dercert ""
set ::cert_pkcs11_id ""
set ::pagescsr {}
set ::wizpagecsr 0
set ::pagescert {}
set ::wizpagecert 0
set ::formatCSR 0
set ::dateSign "Дата подписания: ЧЧММДДГГГГ"
set ::dateSignTST "Дата получения штампа TST: Метка времени отсутствует"
set ::dateSignEscTS "Дата утверждения штампа TST: Метка времени отсутствует"
set ::p7s_hex ""
set ::tekTSP ""
set ::tekTSPadd ""
set ::certfrompfx ""
set ::tekdns 0
set ::tekip 0
set ::tekemail 0
set ::Listedns {""}
set ::Listeip {""}
set ::Listeemail {""}
set ::sslcert 0
set ::ssldomen ""
set ::tlssrv 0
set ::tlscln 0
set ::egais 0
set ::certegais 0
set ::lisalko 0
set ::yearcert 1
set ::dayscert 0
set ::dayscert2 0
set ::snforcert [clock seconds]
variable certfor
set certfor 1

global tempDir
set ::pressBut 0
set ::lang "en"

array set ::arrayCer []

proc create_asn_privkey {pubkey_algo par_sign par_hash value_bin} {
  puts "pubkey_algo=$pubkey_algo"
  puts "par_sign=$par_sign"
  puts "par_hash=$par_hash"
  #parse_key(par_hash)       = 1 2 643 7 1 1 2 3
  #parse_key(par_sign)       = 1 2 643 7 1 2 1 2 1
  #parse_key(priv_value_hex) = 0440cdd91e5eb3f682d41138229dc4a471222c6e74243510fd7e1d0b17952019b66d6033e1d879e6cc291ca675b8f909af0b66d4527b78e7f6ba11db4d4e6c1841e3
  #parse_key(pubkey_algo)    = 1 2 643 7 1 1 1 2

#Это отступление от рекомендаций новых правил кодирования открытого ключа:
#для ключей ГОСТ-2012 (256 бит) с параметрами ТК-26-A и
#для ключей ГОСТ-2012 (512 бит) с параметрами ТК-26-A, ТК-26-B, ТК-26-C
#хэш НЕ РЕКОМЕНДУЕТСЯ указывать 
# В оставшихся случаях - для ключей ГОСТ-2012 (256 бит) с параметрами ТК-26-B,
#ТК-26-C, ТК-26-D хэш ДОЛЖЕН ОТСУТСТВОВАТЬ 
#  tk_messageBox -title "create_asn_privkey 0" -icon info -message "[expr int([string map {" " ""} $par_sign])] " -detail "par_hash=[expr int("1264322362")]" -parent .

    set asn_par_hash ""
    if {$pubkey_algo == "1 2 643 7 1 1 1 1" && $par_sign < "1 2 643 2 2 36 2"} {
	set asn_par_hash [::asn::asnObjectIdentifier $par_hash ]
    }

    set prkey [::asn::asnSequence \
    [::asn::asnInteger 0 ] \
    [::asn::asnSequence   \
    [::asn::asnObjectIdentifier $pubkey_algo ] \
    [::asn::asnSequence \
    [::asn::asnObjectIdentifier $par_sign ] \
    $asn_par_hash \
    ] \
    ] \
    [::asn::asnOctetString  \
    [::asn::asnOctetString $value_bin] \
    ] \
    ]

    return $prkey
}

proc create_asn_pubkey_for_cert {pubkey_algo par_sign par_hash value_priv_bin} {
  puts "pubkey_algo=$pubkey_algo"
  puts "par_sign=$par_sign"
  puts "par_hash=$par_hash"
  #parse_key(par_hash)       = 1 2 643 7 1 1 2 3
  #parse_key(par_sign)       = 1 2 643 7 1 2 1 2 1
  #parse_key(priv_value_hex) = 0440cdd91e5eb3f682d41138229dc4a471222c6e74243510fd7e1d0b17952019b66d6033e1d879e6cc291ca675b8f909af0b66d4527b78e7f6ba11db4d4e6c1841e3
  #parse_key(pubkey_algo)    = 1 2 643 7 1 1 1 2
  set par_id [string map {" " "."} $par_sign]

  set signnum [string map {" " ""} $par_sign]

  #puts "par_id=$par_id"
  set asnhash ""
  if {$pubkey_algo == "1 2 643 7 1 1 1 1"} {
    set group [lcc_gost3410_2012_256_getGroupByOid "$par_id"]
    if {$group > 0} {
      set public_key_str [lcc_gost3410_2012_256_createPublicKey $group $value_priv_bin]
    } else {
      error "create_asn_pubkey_for_cert: Unsupported paramset $par_sign"
    }
    #Учет рекомендаций ТК-26 Для 512 это только рекомендуется. Пока оставляем как есть
    if {[expr int($signnum)] > [expr int("12643712111")]} {
      set asnhash ""
    } else {
      set asnhash [::asn::asnObjectIdentifier $par_hash ]
    }
  } elseif {$pubkey_algo == "1 2 643 7 1 1 1 2"} {
    set group [lcc_gost3410_2012_512_getGroupByOid $par_id]
    if {$group > 0} {
      set public_key_str [lcc_gost3410_2012_512_createPublicKey $group  $value_priv_bin]
    } else {
      error "create_asn_pubkey_for_cert: Unsupported paramset $par_sign"
    }

    #Учет рекомендаций ТК-26 Для 512 это только рекомендуется. Пока оставляем как есть
    set asnhash [::asn::asnObjectIdentifier $par_hash ]
  } else {
    set asnhash [::asn::asnObjectIdentifier $par_hash ]
    error "create_asn_pubkey_for_cert: Unsupported pubkey $pubkey_algo"
    #	    return
  }

  binary scan [::asn::asnOctetString $public_key_str] B* pubkey_bitstr

  set asnpubkey [::asn::asnSequence \
  [::asn::asnSequence   \
  [::asn::asnObjectIdentifier $pubkey_algo ] \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier $par_sign ] \
  $asnhash \
  ] \
  ] \
  [::asn::asnBitString  \
  $pubkey_bitstr \
  ] \
  ]

  return $asnpubkey
}

proc create_asn_pubkey {pubkey_algo par_sign par_hash pub_key_str} {
  puts "pubkey_algo=$pubkey_algo"
  puts "par_sign=$par_sign"
  puts "par_hash=$par_hash"
  #parse_key(par_hash)       = 1 2 643 7 1 1 2 3
  #parse_key(par_sign)       = 1 2 643 7 1 2 1 2 1
  #parse_key(priv_value_hex) = 0440cdd91e5eb3f682d41138229dc4a471222c6e74243510fd7e1d0b17952019b66d6033e1d879e6cc291ca675b8f909af0b66d4527b78e7f6ba11db4d4e6c1841e3
  #parse_key(pubkey_algo)    = 1 2 643 7 1 1 1 2
  set par_id [string map {" " "."} $par_sign]

  set signnum [string map {" " ""} $par_sign]

  #puts "par_id=$par_id"
  set asnhash ""
  if {$pubkey_algo == "1 2 643 7 1 1 1 1"} {
    set pub_key [binary format H* [string range $pub_key_str 4 end]]
    #Учет рекомендаций ТК-26 Для 512 это только рекомендуется. Пока оставляем как есть
    if {[expr int($signnum)] > [expr int("12643712111")]} {
      set asnhash ""
    } else {
      set asnhash [::asn::asnObjectIdentifier $par_hash ]
    }
  } elseif {$pubkey_algo == "1 2 643 7 1 1 1 2"} {
    set pub_key [binary format H* [string range $pub_key_str 6 end]]
    #Учет рекомендаций ТК-26 Для 512 это только рекомендуется. Пока оставляем как есть
    set asnhash [::asn::asnObjectIdentifier $par_hash ]
  } else {
    error "create_asn_pubkey: Unsupported pubkey $pubkey_algo"
    #	    return
  }

  binary scan [::asn::asnOctetString $pub_key] B* pubkey_bitstr

  set asnpubkey [::asn::asnSequence \
  [::asn::asnSequence   \
  [::asn::asnObjectIdentifier $pubkey_algo ] \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier $par_sign ] \
  $asnhash \
  ] \
  ] \
  [::asn::asnBitString  \
  $pubkey_bitstr \
  ] \
  ]

  return $asnpubkey
}

proc reverse {args} {
  set res [list]
  if {[llength $args] == 1} {
    set args [lindex $args 0]
  }
  foreach elem $args {
    set res [linsert $res 0 $elem]
  }
  return $res
}

proc setTempDir {} {
  global tempDir
  global myDir
  global p11conf
  global tclpkcs11
  set tcltls32 ""
  switch -- $::tcl_platform(platform) {
    "windows"        {
      global myDir
      set tclpkcs11 [file join $myDir tclpkcs11.dll]
      set lcc [file join $myDir Lcc.dll]
      set lrnd [file join $myDir Lrnd.dll]
      set alloids [file join $myDir alloids.tcl]

      set tempDir $::env(TEMP)
      set pwdt [pwd]
      if {$::tcl_platform(bits) == 32} {
        set tcltls [file join $myDir tcltls32.dll]
#Не смог собрать для 32-х разрядной пакет tcltls
#пока оставляем из tclexecomp_v1.0.4 старый без tls1.3
	package require tls 
#	load $tcltls32 Tls
      }
    }
    "unix" - default {
      global myDir
      set tclpkcs11 [file join $myDir tclpkcs11.p11]
      set lcc [file join $myDir Lcc.p12]
      set lrnd [file join $myDir Lrnd.p12]
      set alloids [file join $myDir alloids.tcl]
      set tempDir "/tmp"
      if {$::tcl_platform(bits) == 32} {
        set tcltls32 [file join $myDir tcltls32.so]
	load $tcltls32 Tls
      }
    }
  }
  if {$tcltls32 == ""} {
    package require tls
  }
  load $tclpkcs11 Tclpkcs11
  load $lcc Lcc
  load $lrnd Lrnd
  source $alloids
  return $tempDir
}
set tempDir [setTempDir]
lappend auto_path GostPfx
#package require GostPfx
source [file join $myDir "GostPfx.tcl"]
#namespace import ::GostPfx::*

package require pki
rename ::pki::x509::parse_cert ::pki::x509::parse_cert_old
proc ::pki::x509::parse_cert {cert} {
  array set parsed_cert [::pki::_parse_pem $cert "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]
  set cert_seq $parsed_cert(data)

  array set ret [list]

  # Decode X.509 certificate, which is an ASN.1 sequence
  ::asn::asnGetSequence cert_seq wholething
  ::asn::asnGetSequence wholething cert

  set ret(cert) $cert
  set ret(cert) [::asn::asnSequence $ret(cert)]
  binary scan $ret(cert) H* ret(cert)

  ::asn::asnPeekByte cert peek_tag
  if {$peek_tag != 0x02} {
    # Version number is optional, if missing assumed to be value of 0
    ::asn::asnGetContext cert - asn_version
    ::asn::asnGetInteger asn_version ret(version)
    incr ret(version)
  } else {
    set ret(version) 1
  }

  ::asn::asnGetBigInteger cert ret(serial_number)
  ::asn::asnGetSequence cert data_signature_algo_seq
  ::asn::asnGetObjectIdentifier data_signature_algo_seq ret(data_signature_algo)
  ::asn::asnGetSequence cert issuer
  binary scan [::asn::asnSequence $issuer] H* ret(issuer_hex)

  ::asn::asnGetSequence cert validity
  ::asn::asnGetUTCTime validity ret(notBefore)
  ::asn::asnGetUTCTime validity ret(notAfter)
  ::asn::asnGetSequence cert subject
  binary scan [::asn::asnSequence $subject] H* ret(subject_hex)

  ::asn::asnGetSequence cert pubkeyinfo
  binary scan $pubkeyinfo H* ret(pubkeyinfo_hex)

  ::asn::asnGetSequence pubkeyinfo pubkey_algoid
  ::asn::asnGetObjectIdentifier pubkey_algoid ret(pubkey_algo)
  ::asn::asnGetBitString pubkeyinfo pubkey

  set extensions_list [list]
  while {$cert != ""} {
    ::asn::asnPeekByte cert peek_tag

    #add		"0x81"
    #add		"0x82"
    switch -- [format {0x%02x} $peek_tag] {
      "0x81" {
        ::asn::asnGetContext cert - issuerUniqueID
        binary scan $issuerUniqueID H* ret(issuerUniqueID)
      }
      "0x82" {
        ::asn::asnGetContext cert - subjectUniqueID
        binary scan $issuerUniqueID H* ret(subjectUniqueID)
      }
      "0xa1" {
        ::asn::asnGetContext cert - issuerUniqID
        binary scan $issuerUniqueID H* ret(issuerUniqueID)
      }
      "0xa2" {
        ::asn::asnGetContext cert - subjectUniqID
        binary scan $issuerUniqueID H* ret(subjectUniqueID)
      }
      "0xa3" {
        ::asn::asnGetContext cert - extensions_ctx
        ::asn::asnGetSequence extensions_ctx extensions
        while {$extensions != ""} {
          ::asn::asnGetSequence extensions extension
          ::asn::asnGetObjectIdentifier extension ext_oid

          ::asn::asnPeekByte extension peek_tag
          if {$peek_tag == 0x1} {
            ::asn::asnGetBoolean extension ext_critical
          } else {
            set ext_critical false
          }

          ::asn::asnGetOctetString extension ext_value_seq

          set ext_oid [::pki::_oid_number_to_name $ext_oid]

          set ext_value [list $ext_critical]

          switch -- $ext_oid {
            id-ce-basicConstraints {
              ::asn::asnGetSequence ext_value_seq ext_value_bin

              if {$ext_value_bin != ""} {
                ::asn::asnGetBoolean ext_value_bin allowCA
              } else {
                set allowCA "false"
              }

              if {$ext_value_bin != ""} {
                ::asn::asnGetInteger ext_value_bin caDepth
              } else {
                set caDepth -1
              }
                            						
              lappend ext_value $allowCA $caDepth
            }
            default {
              binary scan $ext_value_seq H* ext_value_seq_hex
              lappend ext_value $ext_value_seq_hex
            }
          }

          lappend extensions_list $ext_oid $ext_value
        }
      }
    }
  }
  set ret(extensions) $extensions_list

  ::asn::asnGetSequence wholething signature_algo_seq
  ::asn::asnGetObjectIdentifier signature_algo_seq ret(signature_algo)
  ::asn::asnGetBitString wholething ret(signature)

  # Convert values from ASN.1 decoder to usable values if needed
  set ret(notBefore) [::pki::x509::_utctime_to_native $ret(notBefore)]
  set ret(notAfter) [::pki::x509::_utctime_to_native $ret(notAfter)]
  set ret(serial_number) [::math::bignum::tostr $ret(serial_number)]
  set snstr [::asn::asnBigInteger [math::bignum::fromstr $ret(serial_number)]]
  binary scan $snstr H* ret(serial_number_hex)

  set ret(data_signature_algo) [::pki::_oid_number_to_name $ret(data_signature_algo)]
  set ret(signature_algo) [::pki::_oid_number_to_name $ret(signature_algo)]
  set ret(pubkey_algo) [::pki::_oid_number_to_name $ret(pubkey_algo)]
  set ret(issuer) [_dn_to_string $issuer]
  set ret(subject) [_dn_to_string $subject]
  #My
  #  set ret(issuer_bin) $issuer
  #  set ret(subject_bin) $subject

  set ret(signature) [binary format B* $ret(signature)]
  binary scan $ret(signature) H* ret(signature)

  # Handle RSA public keys by extracting N and E
  switch -- $ret(pubkey_algo) {
    "rsaEncryption" {
      set pubkey [binary format B* $pubkey]
      binary scan $pubkey H* ret(pubkey)

      ::asn::asnGetSequence pubkey pubkey_parts
      ::asn::asnGetBigInteger pubkey_parts ret(n)
      ::asn::asnGetBigInteger pubkey_parts ret(e)

      set ret(n) [::math::bignum::tostr $ret(n)]
      set ret(e) [::math::bignum::tostr $ret(e)]
      set ret(l) [expr {int([::pki::_bits $ret(n)] / 8.0000 + 0.5) * 8}]
      set ret(type) rsa
    }
  }
  return [array get ret]
}



namespace import ::msgcat::mc
set ::listtsp [list "http://sp2.ekey.ru:90/tsa" "http://ca.rzd.ru/tsp-3/tsp.srf"]
set ::listkind [list "0 - personal (Личное присутствие)" "1 - remote_cert (Электронная подпись)" "2 - remote_passport(Биометрический загранпаспорт)" "3 - remote_system (ЕСИА и ЕБС)" "Не включать в сертификат"]

set ::oidData			"1 2 840 113549 1 7 1"
set ::oidSignedData		"1 2 840 113549 1 7 2"
set ::oidEnvelopedData		"1 2 840 113549 1 7 3"
set oidSignedAndEnvelopedData	"1 2 840 113549 1 7 4"
set oidDigestedData		"1 2 840 113549 1 7 5"
set oidEncryptedData		"1 2 840 113549 1 7 6"
set ::oidAttributeContentType	"1 2 840 113549 1 9 3"
set ::oidAttributeMessageDigest	"1 2 840 113549 1 9 4"
set ::oidAttributeSigningTime	"1 2 840 113549 1 9 5"
#timeStamp
set ::oidtimeStampToken             "1 2 840 113549 1 9 16 2 14"
#Второй штамр времени
set ::oidesctimeStamp           "1 2 840 113549 1 9 16 2 25"
set ::oidCertificateRefs        "1 2 840 113549 1 9 16 2 21"
set ::oidrevocationRefs         "1 2 840 113549 1 9 16 2 22"
set ::oidcertValues             "1 2 840 113549 1 9 16 2 23"
set ::revocationValues       	"1 2 840 113549 1 9 16 2 24"
set id-ct-TSTInfo		     "1 2 840 113549 1 9 16 1 4"
set id-aa-signingCertificate         "1 2 840 113549 1 9 16 2 12"
set ::oidsigningCertificateV2        "1 2 840 113549 1 9 16 2 47"

#---------------------------------------------------------------------------
# asnT61String: encode tcl string as UTF8 String
#----------------------------------------------------------------------------
proc asn::asnT61String {string} {
  return [asnEncodeString 14 [encoding convertto utf-8 $string]]
}
#------------------------------------------------------------------------
# asnGetT61String: Decode T61 string from data
#------------------------------------------------------------------------
proc asn::asnGetT61String {data_var print_var} {
  upvar 1 $data_var data $print_var print
  asnGetByte data tag
  if {$tag != 0x14} {
    return -code error \
    [format "Expected T61 String (0x14), but got %02x" $tag]
  }
  asnGetLength data length
  asnGetBytes data $length string
  #there should be some error checking to see if input is
  #properly-formatted utf8
  set print [encoding convertfrom utf-8 $string]
          	
  return
}	


set ::pki::oids(2.5.4.42)  "givenName"
set ::pki::oids(1.2.643.100.1)  "OGRN"
#Для физическлого лица
set ::pki::oids(1.2.643.3.131.1.1) "INN"
set ::pki::oids(1.2.643.100.3) "SNILS"
#ВВЕДЕНЫ Приказом ФСБ России от 29.01.2021 N31
#Для юридического лица
set ::pki::oids(1.2.643.100.4) "INNLE"
#Для ИП
set ::pki::oids(1.2.643.100.5)  "OGRNIP"
#IdentificationKind - как выдавался сертификат
#set ::pki::oids(1.2.643.100.114) "IDKIND"

#Для КПП ЕГАИС
set ::pki::oids(1.2.840.113549.1.9.2) "UN"
#set ::pki::oids(1.2.840.113549.1.9.2) "unstructuredName"
#Алгоритмы подписи
#    set ::pki::oids(1.2.643.2.2.19) "ГОСТ Р 34.10-2001"
set ::pki::oids(1.2.643.2.2.3) "GOST R 34.10-2001 with GOST R 34.11-94"
set ::pki::oids(1.2.643.2.2.19) "GOST R 34.10-2001"
set ::pki::oids(1.2.643.7.1.1.1.1) "GOST R 34.10-2012-256"
set ::pki::oids(1.2.643.7.1.1.1.2) "GOST R 34.10-2012-512"
set ::pki::oids(1.2.643.7.1.1.3.2) "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256"
set ::pki::oids(1.2.643.7.1.1.3.3) "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512"
set ::pki::oids(1.2.643.100.113.1) "KC1 Class Sign Tool"
set ::pki::oids(1.2.643.100.113.2) "KC2 Class Sign Tool"


#source [file join $myDir "GostPfx.tcl"]
#source "AllOIDS.tcl"
array set ::payoid1 {
  1.2.643.6.3.1.2.2 "МЭТС"
  1.2.643.6.7 "B2B и B2G"
  1.2.643.6.15 "Фабрикант"
  1.2.643.6.14 "Центр реализации"
  1.2.643.100.2.1 "Росреестр"
  1.2.643.3.8.100.1.113 "Росреестр"
  1.2.643.2.2.34.25 "Росреестр"
  1.2.643.2.2.34.26 "Росреестр"
  1.3.6.1.5.5.7.3.1 "TLS Web Server Autentication Certificate"
  1.3.6.1.5.5.7.3.2 "TLS Web Client Autentication Certificate"
  1.3.6.1.5.5.7.3.3 "Code Signing Certificate"
  1.3.6.1.5.5.7.3.4 "Email Protection Certificate"
  1.3.6.1.5.5.7.3.8 "Time Stamping Certificate"
  1.3.6.1.5.5.7.3.9 "OCSP Responder Certificate"
}
array set dn_fields {
  C "Country" ST "State" L "Locality" STREET "Adress" TITLE "Title"
  O "Organization" OU "Organizational Unit"
  CN "Common Name" SN "Surname" GN "Given Name" INN "INN" INNLE "INNLE" OGRN "OGRN" OGRNIP "OGRNIP" SNILS "SNILS" EMAIL "Email Address"
  UN "KPP"
}
array set dn_fields_ru {
  C "Страна" ST "Регион" L "Местность" STREET "Адрес" TITLE "Название"
  O "Организация" OU "Подразделение"
  CN "Общепринятое имя" SN "Фамилия" GN "Имя, отчество" GIVENNAME "Имя,отчество" INN "ИНН" INNLE "ИННЮЛ" OGRN "ОГРН" OGRNIP "ОГРНИП" SNILS "СНИЛС" EMAIL "Адрес эл.почты"
  UN "unstructuredName"
}
# GOST R 34.10-2012 TC 26 parameter sets: (0~Test, 1~A, 2~B, 3~C, 4~ExA, 5~ExB)
# TC26 GOST R 34.10-2012 512 parameter sets: (0~Test, 1~A, 2~B, 3~C)
# GOST R 34.10-2001 Crypto-Pro parameter sets: (0~Test, 1~A, 2~B, 3~C, 4~ExA, 5~ExB)
array set param3410 {
  "1 2 643 2 2 35 1"	"id-GostR3410-2001-CryptoPro-A-ParamSet"
  "1 2 643 2 2 35 2"	"id-GostR3410-2001-CryptoPro-B-ParamSet"
  "1 2 643 2 2 35 3"	"id-GostR3410-2001-CryptoPro-C-ParamSet"
  "1 2 643 2 2 36 0"	"id-GostR3410-2001-CryptoPro-XchA-ParamSet"
  "1 2 643 2 2 36 1"	"id-GostR3410-2001-CryptoPro-XchB-ParamSet"
  "1 2 643 7 1 2 1 1 1"	"id-tc26-gost-3410-2012-256-paramSetA"
  "1 2 643 7 1 2 1 1 2"	"id-tc26-gost-3410-2012-256-paramSetB"
  "1 2 643 7 1 2 1 1 3"	"id-tc26-gost-3410-2012-256-paramSetC"
  "1 2 643 7 1 2 1 1 4"	"id-tc26-gost-3410-2012-256-paramSetD"
  "1 2 643 7 1 2 1 2 1"	"id-tc26-gost-3410-2012-512-paramSetA"
  "1 2 643 7 1 2 1 2 2"	"id-tc26-gost-3410-2012-512-paramSetB"
  "1 2 643 7 1 2 1 2 3"	"id-tc26-gost-3410-2012-512-paramSetC"
}

wm iconphoto . icon11_24x24
font configure TkDefaultFont -family helvetica
#font configure TkFixedFont -family helvetica
font configure TkTextFont -family helvetica
font configure TkDefaultFont -size 10
font configure TkFixedFont -size 10
font configure TkTextFont -size 10
option add *Dialog.msg.wrapLength 6i
option add *Dialog.dtl.wrapLength 6i
##################
global typesys
set typesys [tk windowingsystem]
set tlib ""
global myHOME
set myHOME ""
global macos
set macos 0
switch $typesys {
  win32        {
    set myfont [font configure TkDefaultFont]
    set myfont [lreplace $myfont 5 5 bold]
    set com "font create TkDefaultFontBold $myfont"
    set com [subst $com]
    eval $com
    set myfont [lreplace $myfont 3 3 12]
       set com "font create TkFontForFirst $myfont"
    set com [subst $com]
    set tlib "dll"
    set myHOME $::env(USERPROFILE)
    wm geometry . 910x580+300+105
  }
  x11 {
    set myfont [font configure TkDefaultFont]
    #puts "myfont=$myfont"
    set myfont [lreplace $myfont 5 5 bold]
    set com "font create TkDefaultFontBold $myfont"
    set com [subst $com]
    eval $com
    set myfont [lreplace $myfont 3 3 12]
    set com "font create TkFontForFirst $myfont"
    set com [subst $com]
    eval $com
    set tlib "so"
    set myHOME $::env(HOME)
    catch {tk_getOpenFile foo bar}
    set ::tk::dialog::file::showHiddenVar 0
    set ::tk::dialog::file::showHiddenBtn 1
    wm geometry . 850x575+300+105
  }
  classic - aqua {
    set tlib "dylib"
    set myHOME $::env(HOME)
    wm geometry . 850x550+300+105
    set macos 1
  }
}

if {[tk windowingsystem] == "win32"} {
    #Перекодируем путь из кодировки ОС
    #Для MS Win это скорей всего cp1251
    set ::lastDir [encoding convertfrom cp1251 $myHOME ]
    #Заменяем обратную косую в пути на нормальную косую
    set ::lastDir [string map {"\\" "/"} $::lastDir]

    set ::lastDoc [encoding convertfrom cp1251 $myHOME ]
    set ::lastDoc [string map {"\\" "/"} $::lastDoc]

    set ::lastSave [encoding convertfrom cp1251 $myHOME ]
    set ::lastSave [string map {"\\" "/"} $::lastSave]
} else {
    set ::lastDir $myHOME
    set ::lastDoc $myHOME
    set ::lastSave $myHOME
}
#В МАС теперь всё хорошо, отключаем его
#set macos 0

##################

wm title . "Криптографический АРМ на базе стандартов с открытым ключом (Russian cryptography)"
image create photo logoLC -file [file join $myDir "card_and_token_pero_509x316.png"]
image create photo ::img::ru_32x32  -data {
  iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACgElEQVR4nO1XMW7bQBCcuVsxlm0IYBpLfkJe4FRJmSrII5zSvYtU+UYekL+4SOHKQMrAAgIVMWyAoGTe
  bgqS4lGmlciilSZbcA+n5c1wNLdHEg+DHXN9hT0Gtpq7anoDjeZMjo6O6L0nyT8ReWrEa7XIzOdz4+XlJff39ydJkgycc3zkxj7CAMDKwGKxuM2y7Jfc3Nx8Go/Hn5Mk
  6RlvDRMzZFmWX11dvZXr6+s3JycnEJGdEQCAJEn2Li4uXgtJTxKVB3YWJDGbzcTtFLUj/hP45wRkPjdkmZr34UkLWFefWxO11/NckedmcnoKnJ0BIoRzZUGd6+J4g5gB
  IZRZdT2B+LfV+hCIoiAEIFQdVV0LbDWrNsCb7lizBrgmokqEAEpXkWqpQj1WbRbru13IKngdNfBz9Kd4zVb/jRXYVWNsKVBL3WW+PiNW28WTXY7edJttGlIe02Zm2jwx
  sfXbwDreJY5BUJh8kY/2Pjkz7xzAqAH0dUIaYLBGYlNADXMNONccMnxxz9EBnXdt8MYIy8vmyFFqCJRmy1UxLBYUN3TAyFftDysEenLh0mA1AYJKMCeEBw5IH8oPcIun
  b6HXb4MtBWgEb11NwHcQiMCfysGigcVECKqBPwlxhw58KdFTxwTaPP6OiXUOW4cBCKiBw0gBQ9/SdxBb+oAgDNijybfcfrxLfdWROuTvlUCVYcgLC99vbcp0dPgq3cMH
  8UzoHAjQ1UdhpcZWFqguZrb8KFFVZPeYKdxXTiYTknRmxtFoxOPjYwwGA3jv6b3fuhmpKkIICCFYlmWYTqfI87z6LxBaeqdp2titAt6GgFXGs+hAKYrC7u7uliXrVn+W
  b8PV+A25Z0BSvbyERAAAAABJRU5ErkJggg==
}

image create photo ::img::us_32x32  -data {
  iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAHDElEQVRYhcWXfXAU9RnHP7+9zeXucgdJLuRIwuUFmoCUYIWEl4BCm4CNCBVMywRqZyyjHVERplTaTrFO
  qWUmo9NSpR2ndVpbbW1HO60vFWrVAj0FK5ggBkiwgQTSvF28l9ze7d7t/vrHHSGhHVFpJ8/M7rPP7s1+n9/v+d7zfVZIKZlIUzNemQBsa2wC1gQkAIDa1z+AJbKKk0bK
  bloSKSU2RVGEIrAsC0tKFCFQFCUdWxJFGROPeS4tSY7LTn5uDpb1H6Udt0hFUUb6+vqGxMZNW7ce6lC+K6Swz6/2s3p5NXueOkB0JEFVRSEbVtXw2G8OMDQco7Qkn03r
  FvH47wP0DkTwed1sbr6eJ//0Fl3nh7FSKdbdeB0PfX0tWtz40JULiGzfvn2jeuzUQHPW5Fm5c2aXgU3hzLCBr6KMUtWGqip0DuoU+P0UlStI4MygTl5xMd6SElKWpHNQ
  J6fQx5wCHwOhEXylfux2J3a780q777K7nI2CSTcEGjduqLuzaTFf2fUc0ZDGstoZfOPLS7hz9/P0DoSpmT2NXV+r595HXuJMT5DZFVP44X2N3L93P22d/ZQV5fLT+1fz
  7ScOMCs8TMt0FzriEpTMnCQg094yEjx44I8Pi6LqdQH7tOvqfIW5hCIa00vyeL9nGJ/XzVAoRqXfy+lzQ0wt8NAfjFJVVkDHuSGmej30BaNUlRbQ2RPEl++mI6ixvPuf
  fPPMu2iKbUwCMpODBMtCSEFSC/OwdbZFWb6wkrCW4K3j3VQUTWbzugVocZ3A8W58eTlsvnUBUkoCbd1Mctm559aFOOw2Am3d2BS4u2kh+R4Hb77bQySi4SgqwNVQi7u+
  BvfnMsfodS3u+gW462vxrKwju6QYYfffGLh26Yq6hkVVPPnSO5imRXlRLo2Lq3hqXytxPYkv38Mty67hmf3HiWg6uR4H6xuqefb19wiGNHIcdjZ8/lp+u7+NlYur2LNj
  3ZXqD8C9W7a0KEbcIMum4J3sIpVMEUsY2BRBQa6LVMoknkgikBTkujAtCy1hIC0Lb24OwpJoCQPLMpmS50K1CaTy0XuaUG2INRu3BQI9zrpgOEHDghnc/oUaduz5M/3D
  MRbPmcY9zUv4zmP7OdcXovpTPnbc/lm+/7PXOH1ukOnFeTx410oe+eXrtJ7uxebMpilXsNMn0aUAkSaiEAIQCNL3hBRYSZ1dh19uUc9eCGK3lVLpz6dvKMy+wClURTCz
  1MtwSGPf308hLcnMsgJimsHLh9qJjWhU+DzEIiM8/8o7DA2GKCt0869YimhHF8G/tKIpKqM6c9FbEhAoQoBpEqcXW39o8qbrb1jo33lHPb968RhHWs9RO8fP9zav4Nm/
  HudvR7uYVe5l95ZGXni1jVcPtFOY7+bH31rLwX+c4ZWD7Xg8TvY+8CWOnbqAV5qsmj+drJkVuGZW4Kwqxznqy3FUleGsLMVZVc5hIxwQFbXrA4ansm5SjgOJZM6MqRxt
  P88kdzaGYTK3ciqHW7twu+xocYN5n/Zz9EQPblc2kViC2upSWtvP43TaOXs+yG1rF/GTB5o/Ege2bL2vRamdW85ILMHJjl6KvB6aVsxFi+u0nbyAx6HStKIaM2XxXkcf
  Toed5ptqyMqycaKjF0URNN9Ug8ft4ERnH7F4EkV8HGEVCFvxysD8pfV1q5bN5tGnD5EwUswsLWBtQzV7nz7EiKbjL8rjtjW1PP67NwiGYhR63dzxxcX84g9H6B2IkDvJ
  yV3NS3nixaPMiwTZVSjRMxCjkiTluENI+MHxgy2qGTcIR+MMh2OEo3GSCYNQxEkoohGN6YzEDaIxnVBUIxqLE9V0nA6VDyJxorEEUU3HZhOEIhojeorw+z2E3zhJLNMJ
  xxHRtJASBCYCSYJBRO3KTYHi6fPqkikTV7aKEGmy6noSl9OOEALLkiT0JE6HHSHSL40nkjgcWWlGS9ASBsKRzcJklCatH310xpGXtMBKt2QhJUJKHnr7tRZ15903s3rN
  LR+jbv87m7JtG4phTtgwhDRN1K7dj9L26xcyXSvTvTIdLK2oIu0vsumiyv63+PJnYwM5Vo4lAhhqexM12dFOovc8UggQSvotyhjgsbr+ydY5bg4ACywLG2CGB1DzGpbg
  m30NkjErHwW/2gTkZZdyNBFFkeTs249asumrlDfefBUgn9zytDiq1OOXxGJ88f6PltnVpIEafuZH6sCJ5zBNLivDpd+NLYL8kPhKPBzbE7KzQD96TFXf7jzZvXRKcIGC
  kk5gFPFqyXe5XQJXgJFUilPdFy4Ij8f9mVK3XG8T0qUoCkJR0qODEJnNuLpEZIZ4Usr0TCotsExFl1mDXR8kfy4OHz6CnrIwkknFZrOlgQFEZnC4Skv/A+WoJliWhWma
  uHNclpHQEBP9dTwRX8Xj7N+2ai+CDrtU9gAAAABJRU5ErkJggg==
}

image create photo exitCA_16x16 -data {
  R0lGODlhEAAQAMYAAP///5gBAfz398+Hh6AVFdJSUsMAANMAAMYAANJRUdNVVcgA
  ANAAANQAANRYWNFOTtBCQtBISNBEROmjo9A/P9VcXOq5ueuysuyKiuq4uOqwsJwH
  B9E8POmpqe/Bwe6jo/jk5NxyctdiYs4aGuSFhfvw8NcaGuyFhdaamthqavHJycMJ
  CeOJiccXF8kfH841Nfba2twaGtEuLtkpKeqYmPCUlLYYGONaWuJsbNciIt1KSt5C
  Qvne3uFhYd57e8sqKrk2Nv//////////////////////////////////////////
  ////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////
  /////////////////yH+EUNyZWF0ZWQgd2l0aCBHSU1QACwAAAAAEAAQAAAHgIAA
  goOEhYaHhiUEi4yNAYQDFRUOlBoKBQUJHZAOCpcFAAkPo5uDA5kiAA8AAgAREaWC
  A6MAKREAEoIQE5ARKrgSEBAUABy8phCCFCsGzQAGJJAUHM8GCNcAC9Gm2NkLCwAq
  DCeQ3wyEHgwH5KYM7uoHDfIN7IMC9/j5rYj8/YaBADs=
}
image create photo logoTok -file [file join $myDir "tokens_tcl_pero_85x45.png"]
set g_iso3166_codes {
  Австралия AU Австрия AT Азербайджан AZ {Аландские о-ва} AX Албания AL Алжир DZ {Американское Самоа} AS
  Ангилья AI Ангола AO Андорра AD Антарктида AQ {Антигуа и Барбуда} AG Аргентина AR Армения AM Аруба AW
  Афганистан AF {Багамские о-ва} BS Бангладеш BD Барбадос BB Бахрейн BH Беларусь BY Белиз BZ Бельгия BE Бенин BJ
  {Бермудские о-ва} BM Болгария BG Боливия BO {Босния и Герцеговина} BA Ботсвана BW Бразилия BR
  {Британская территория в Индийском океане} IO {Британские Виргинские о-ва} VG {Бруней Даруссалам} BN
  {Буркина Фасо} BF Бурунди BI Бутан BT Вануату VU Ватикан VA Великобритания GB Венгрия HU Венесуэла VE
  {Виргинские о-ва (США)} VI {Внешние малые острова (США)} UM {Внешняя Океания} QO {Восточный Тимор} TL Вьетнам VN
  Габон GA Гаити HT Гайана GY Гамбия GM Гана GH Гваделупа GP Гватемала GT Гвинея GN Гвинея-Бисау GW Германия DE
  Гернси GG Гибралтар GI Гондурас HN {Гонконг (особый район)} HK Гренада GD Гренландия GL Греция GR Грузия GE
  Гуам GU Дания DK {Демократическая Республика Конго} CD Джерси JE Джибути DJ Диего-Гарсия DG Доминика DM
  {Доминиканская Республика} DO {Европейский союз} EU Египет EG Замбия ZM {Западная Сахара} EH Зимбабве ZW
  Израиль IL Индия IN Индонезия ID Иордания JO Ирак IQ Иран IR Ирландия IE Исландия IS Испания ES Италия IT
  Йемен YE Казахстан KZ {Каймановы острова} KY Камбоджа KH Камерун CM Канада CA {Канарские о-ва} IC Катар QA
  Кения KE Кипр CY Киргизия KG Кирибати KI Китай CN {Кокосовые о-ва} CC Колумбия CO {Коморские о-ва} KM Конго CG
  Коста-Рика CR {Кот дИвуар} CI Куба CU Кувейт KW Лаос LA Латвия LV Лесото LS Либерия LR Ливан LB Ливия LY Литва LT
  Лихтенштейн LI Люксембург LU Маврикий MU Мавритания MR Мадагаскар MG Майотта YT {Макао (особый район)} MO
  Македония MK Малави MW Малайзия MY Мали ML {Мальдивские о-ва} MV Мальта MT Марокко MA Мартиника MQ
  {Маршалловы о-ва} MH Мексика MX Мозамбик MZ Молдова MD Монако MC Монголия MN Монтсеррат MS Мьянма MM Намибия NA
  Науру NR Непал NP Нигер NE Нигерия NG {Нидерландские Антильские о-ва} AN Нидерланды NL Никарагуа NI Ниуе NU
  {Новая Зеландия} NZ {Новая Каледония} NC Норвегия NO ОАЭ AE Оман OM {Остров Буве} BV {Остров Вознесения} AC
  {Остров Клиппертон} CP {Остров Мэн} IM {Остров Норфолк} NF {Остров Рождества} CX {Остров Святого Бартоломея} BL
  {Остров Святого Мартина} MF {Остров Святой Елены} SH {Острова Зеленого Мыса} CV {Острова Кука} CK
  {Острова Тёркс и Кайкос} TC {Острова Херд и Макдональд} HM Пакистан PK Палау PW {Палестинские территории} PS
  Панама PA {Папуа Новая Гвинея} PG Парагвай PY Перу PE Питкэрн PN Польша PL Португалия PT Пуэрто-Рико PR
  {Республика Корея} KR Реюньон RE {Российская Федерация} RU Руанда RW Румыния RO Сальвадор SV Самоа WS Сан-Марино SM
  {Сан-Томе и Принсипи} ST {Саудовская Аравия} SA Свазиленд SZ {Свальбард и Ян-Майен} SJ {Северная Корея} KP
  {Северные Марианские о-ва} MP {Сейшельские о-ва} SC {Сен-Пьер и Микелон} PM Сенегал SN {Сент-Винсент и Гренадины}
  VC {Сент-Киттс и Невис} KN Сент-Люсия LC Сербия RS {Сербия и Черногория} CS {Сеута и Мелилья} EA Сингапур SG
  Сирия SY Словакия SK Словения SI {Соломоновы о-ва} SB Сомали SO Судан SD Суринам SR США US Сьерра-Леоне SL
  Таджикистан TJ Таиланд TH Тайвань TW Танзания TZ Того TG Токелау TK Тонга TO {Тринидад и Тобаго} TT
  Тристан-да-Кунья TA Тувалу TV Тунис TN Туркменистан TM Турция TR Уганда UG Узбекистан UZ Украина UA
  {Уоллис и Футуна} WF Уругвай UY {Фарерские о-ва} FO {Федеративные Штаты Микронезии} FM Фиджи FJ Филиппины PH
  Финляндия FI {Фолклендские о-ва} FK Франция FR {Французская Гвиана} GF {Французская Полинезия} PF
  {Французские Южные Территории} TF Хорватия HR ЦАР CF Чад TD Черногория ME Чехия CZ Чили CL Швейцария CH Швеция
  SE Шри-Ланка LK Эквадор EC {Экваториальная Гвинея} GQ Эритрея ER Эстония EE Эфиопия ET ЮАР ZA
  {Южная Джорджия и Южные Сандвичевы Острова} GS Ямайка JM Япония JP
}
set rfregions  {{Республика Адыгея (Адыгея)} {Республика Башкортостан} {Республика Бурятия} {Республика Алтай}
{Республика Дагестан} {Республика Ингушетия} {Кабардино-Балкарская Республика} {Республика Калмыкия}
{Карачаево-Черкесская Республика} {Республика Карелия} {Республика Коми} {Республика Марий Эл}
{Республика Мордовия} {Республика Саха (Якутия)} {Республика Северная Осетия - Алания}
{Республика Татарстан} {1Республика Тыва} {Удмуртская Республика} {Республика Хакасия} {Чеченская Республика}
{Чувашская Республика - Чувашия} {Алтайский край} {Краснодарский край} {Красноярский край} {Приморский край}
{Ставропольский край} {Хабаровский край} {Амурская область} {Архангельская область и Ненецкий автономный округ}
{Астраханская область} {Белгородская область} {Брянская область} {Владимирская область} {Волгоградская область}
{Вологодская область} {Воронежская область} {Ивановская область} {Иркутская область} {Калининградская область}
{Калужская область} {Камчатский край} {Кемеровская область} {Кировская область} {Костромская область}
{Курганская область} {Курская область} {Ленинградская область} {Липецкая область} {Магаданская область} 15
{Московская область} {Мурманская область} {Нижегородская область} {Новгородская область}
{Новосибирская область} {Омская область} {Оренбургская область} {Орловская область} {Пензенская область}
{Пермский край} {Псковская область} {Ростовская область} {Рязанская область} {Самарская область}
{Саратовская область} {Сахалинская область} {Свердловская область} {Смоленская область} {Тамбовская область}
{Тверская область} {Томская область} {Тульская область} {Тюменская область} {Ульяновская область}
{Челябинская область} {Забайкальский край} {Ярославская область} {г. Москва} {г. Санкт-Петербург}
{Еврейская автономная область} {Ханты-Мансийский автономный округ - Югра} {Чукотский автономный округ}
{Ямало-Ненецкий автономный округ} {Иные территории, включая, г. Байконур}}

global wizDatacsr
global wizDatacert
array set wizDatacsr {
  type "Физическое лицо"
  O ""
  OU ""
  C ""
  ST ""
  L ""
  CN ""
  INN ""
  INNLE ""
  SNILS ""
  OGRN ""
  OGRNIP ""
  UN ""
  street ""
  title ""
  givenName ""
  SN ""
  E ""
  U ""
  emailAddress ""
  keypassword ""
  keypassword2 ""
  capassword ""
  exit "cancel"
  username ""
  caname ""
  wizardtype ""
  role ""
  typekey "gost2012_256"
  parkey "1.2.643.2.2.35.3"
  dn ""
  ckzi "Наименование СКЗИ пользователя"
  expkey 0
  selfca 0
  selfssl 1
  token ""
  cwapi ""
  libp11_fn "Выберите библиотеку PKCS#11"
  csr_fn ""
  key_fn ""
  keypassword ""
  keytok 1
}
array set wizDatacert {
  type "Физическое лицо"
  O ""
  OU ""
  C ""
  ST ""
  L ""
  CN ""
  INN ""
  INNLE ""
  SNILS ""
  OGRN ""
  OGRNIP ""
  UN ""
  street ""
  title ""
  givenName ""
  SN ""
  E ""
  U ""
  emailAddress ""
  keypassword ""
  keypassword2 ""
  capassword ""
  exit "cancel"
  username ""
  caname ""
  wizardtype ""
  role ""
  typekey "gost2012_256"
  parkey "1.2.643.2.2.35.3"
  dn ""
  ckzi "Наименование СКЗИ пользователя"
  expkey 0
  selfca 0
  selfssl 1
  token ""
  cwapi ""
  libp11_fn "Выберите библиотеку PKCS#11"
  csr_fn ""
  key_fn ""
  keypassword ""
  keytok 0
}


set defaultkey $wizDatacsr(typekey)
set defaultpar $wizDatacsr(parkey)

proc wizard {tpage toplevel pages func} {
  puts "WIZARD=$toplevel"
  set j 0
  for {set i 1} {$i <= $pages} {incr i} {
    set finish {}
    set page $toplevel.p$i
    frame $page -bg #f5f5f5 -relief flat -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue -padx 2 -pady 2
    frame $page.page -bg #f5f5f5 -relief flat -highlightthickness 2 -highlightbackground skyblue -highlightcolor skyblue -padx 2 -pady 2
    lappend page_list $page.page
    lappend page_list [lindex $func $j]
    incr j

    ttk::button $page.p -text "< Предыдущее" -command [list move $tpage $page.page -1] -style MyBorder.TButton -padding 1
    ttk::button $page.n -text "Следующее >" -command [list move $tpage $page.page 1] -style MyBorder.TButton -padding 1
    ttk::button $page.f -text "Завершение" -command [list ::finalizeCSR $tpage ] -style MyBorder.TButton -padding 1
    if {$i == 1} {
      $page.p configure -state disabled
    }
    if {$i == $pages} {
      $page.n configure -state disabled
      $page.f configure -state normal
      set finish $page.f
    }
    grid $page.page  -columnspan 4  -sticky nsew
    grid $page.p $page.n {*}$finish -pady 3 -padx {3 0}

    grid columnconfigure $page 3 -weight 1
    grid rowconfigure $page 0 -weight 1
  }
  return $page_list
}

proc move {tpage page {offset 0}} {
  #puts "MOVE_PAGE=$page"
  #puts "offset=$offset"

  set page [winfo parent $page]
  regexp {^(.*\.p)([0-9]+)$} $page -> root number
  set newnumber [expr {$number + $offset}]
  if {$newnumber == 0} {
    cmdssl $page
  }

  set next [nextStep $tpage $newnumber]
  if {$next != 1} {
    return
  }
  pack forget $page
  set childold [winfo children $page]
  set newpage "$root$newnumber"
  pack $newpage -fill both -expand 1
  set childnew [winfo children $newpage]
  set PP [lindex $childnew 0]
  #puts "PP=$PP"
  if {$tpage == "csr" } {
    set pages $::pagescsr
  } elseif {$tpage == "cert" } {
    set pages $::pagescert
  } else {
    return
  }

  if {$newnumber != 111} {
    eval destroy [winfo children $PP]
    ##########
    foreach {p func} $pages {
      #puts "P=$p"
      if {$p == $PP} {
        #puts "PAGEforFUNC=$page"
        #puts "FUNC=$func"
        #puts "TPAGE=$tpage"
        $func $tpage $p $newnumber
        break
      }
      incr j
      #puts "CSR=[winfo children $page]"
    }
  }
  ###########
  #puts "NEW_PAGE=$newpage"
  #puts "NEW_NUMBER_PAGE=$newnumber"
  #puts "NEW_CHIL=$childnew"
  #puts "OLD_CHIL=$childold"
  if {$tpage == "csr" } {
    set ::wizpagecsr 1
  } else {
    set ::wizpagecert 1
  }
  #puts "wizpagecsr=$::wizpagecsr"
}
## Procedure:  Digit
proc ::Digit {ent len text size} {
  #puts "DIGIT $ent $len $text $size"
  set length [string length $text]
  if {$length != $len} {
    #    $ent configure -background white
    $ent configure -foreground black
  }
  if {$length > $size} {
    #    $ent configure -background #00ffff
    $ent configure -foreground blue
    return 0
  }

  if {[regexp {[^0-9]} $text]} {
    #    $ent configure -background red
    $ent configure -foreground red
    return 0
  }
  if {$length == $size} {
    #    $ent configure -background #00ffff
    $ent configure -foreground blue
    return 1
  }
  if {$len >= $size} {
    #    $ent configure -background #00ffff
    $ent configure -foreground blue
    return 0
  }
  #  $ent configure -background white
  $ent configure -foreground black
  return 1
}

set ::emailpat {
  ^
  (  # local-part
  (?:
  (?:
  (?:[^"().,:;\[\]\s\\@]+)   # one or more non-special characters (not dot)
  |
  (?:
  "  # begin quoted string
  (?:
  [^\\"]  # any character other than backslash or double quote
  |
  (?:\\.) # or a backslash followed by another character
  )+   # repeated one or more times
  "  # end quote
  )
  )
  \.   # followed by a dot
  )*    # local portion with trailing dot repeated zero or more times.
  (?:[^"().,:;\[\]\s\\@]+)|(?:"(?:[^\\"]|(?:\\.))+")  # as above, the final portion may not contain a trailing dot
  )
  @
  (  # domain-name, underscores are not allowed
  (?:(?:[A-Za-z0-9][A-Za-z0-9-]*)?[A-Za-z0-9]\.)+ # one or more domain specifiers followed by a dot
  (?:[A-Za-z0-9][A-Za-z0-9-]*)?[A-Za-z0-9]     # top-level domain
  \.?           # may be fully-qualified
  )
  $
}

proc verifyemail {emailtest} {
  set rc NG
  #puts "verifyemail=$emailtest"
  if { [regexp -expanded $::emailpat $emailtest emailaddr local domain] } {
    set rc OK
  }
  return $rc
}

proc CreateMenu {w label def} {
  global tcl_platform
  global config

  MakeMenu $w $label $def
  switch [tk windowingsystem] {
    win32 {
      $w.$label add cascade -label System -menu $w.$label.system
      menu $w.$label.system -tearoff 0

      # Add the 'Show Log' item to the system menu
      $w.$label.system add checkbutton \
      -label {Show Message Log} \
      -variable ::Log::mapped(.log) \
      -command "::Log::WindowToggle .log"
    }
    classic - aqua  {
      $w.$label add cascade -label System -menu $w.$label.apple
      menu $w.$label.apple -tearoff 0

      # Add the 'Show Log' item to the system menu
      $w.$label.apple add checkbutton \
      -label {Show Message Log} \
      -variable ::Log::mapped(.log) \
      -command "::Log::WindowToggle .log"
    }
  }	
}


namespace eval cagui {

  variable img_cert
  set img_cert img_cert

  variable status {}  ;# status displayed in progress

}


proc cagui::FileEntry {w args} {
  ttk::style map My1.TButton -background [list disabled gray85  active #00ff7f] -foreground [list disabled gray64] -relief [list {pressed !disabled} sunken]
  ttk::style configure My1.TButton -borderwidth 2

  set validopts {-dialogtype -width -defaultextension -filetypes -title -variable -initialdir -command -parent -typewd}

  set passingopts {-dialogtype -defaultextension -filetypes -title -variable -initialdir -command -parent -typewd}
  set entryopts {-width}

  # parse arguments
  array set opts_in $args
  foreach opt $validopts {
    if {[info exists opts_in($opt)]} {
      set opts($opt) $opts_in($opt)
    }
  }
  upvar $opts(-variable) variable
  upvar $opts_in(-variable) variable
  if {$variable == ""} {
    set opts(-initialfile) ""
    if {[info exists opts_in(-initialdir)]} {
      set opts(-initialdir) $opts_in(-initialdir)
    }
  } else  {
    set opts(-initialfile) [file tail $variable]
    set opts(-initialdir) [file dirname $variable]
  }

  # build buttoncommand
  if {![info exists opts(-typewd)]} {
    #      set opts(-typewd) "window"
    set opts(-typewd) "frame"
  }
  if {![info exists opts(-dialogtype)]} {
    set opts(-dialogtype) "open"
  }
  if {![info exists opts(-defaultextension)]} {
    if {$opts(-dialogtype) != "directory"} {
      set opts(-defaultextension) "*"
    }
    set opts(-defaultextension) "*"
  }
  if {$opts(-dialogtype) == "directory"} {
    set opts(-dialogtype) "dir"
  }
  set randw [expr int(rand() * 10000)]
  set rr ".w$randw"
  if {[tk windowingsystem] == "win32"} {
    #Перекодируем путь из кодировки ОС
    #Для MS Win это скорей всего cp1251
    set tekdir [encoding convertfrom cp1251 $opts(-initialdir) ]
    #Заменяем обратную косую в пути на нормальную косую
    set opts(-initialdir) [string map {"\\" "/"} $tekdir]
  }

  set buttoncommand "catch {destroy {.hhh}}; feselectKDE $opts(-dialogtype) $rr $opts(-typewd) {\"$opts(-title)\"} {$opts(-initialdir)} $opts(-variable) {$opts(-defaultextension) *}"

  #  set entrycommand [list entry $w.entry -textvariable $opts(-variable) -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue]
  set entrycommand [list ttk::entry $w.entry -textvariable $opts(-variable)]
  #  set entrycommand [list entry $w.entry -textvariable $opts(-variable) -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue -relief flat]
  #puts "entrycommand : $entrycommand"
  foreach opt $entryopts {
    if {[info exists opts($opt)]} {
      lappend entrycommand $opt $opts($opt)
    }
  }
  #puts "entrycommand : $entrycommand"

  frame $w
  #label $w.label -text $opts(-text)
  eval $entrycommand
  button $w.but -image icon_openfile_18x16  -compound center -command $buttoncommand -bd 0 -background white -activebackground white -highlightthickness 0

  pack $w.but -side right -padx {1mm 1mm}
  pack $w.entry -side right -expand 1 -fill x
}
#Создание сертификата ГОСТ
proc ::pki::x509::create_self_cert {signreqlist cakeylist serial_number notBefore notAfter extensions {encodePem 0} {algo "sha1"}} {
  variable ::tlssrv
  variable ::tlscln
  #    variable certfor
  global certfor
  # Parse parameters
  array set cakey $cakeylist
  array set signreq $signreqlist
#tk_messageBox -title "Самоподписанный сертификат ОТЛАДКА" -icon info -message "cakeylist=$cakeylist" -detail "signreqlist=$signreqlist" -parent .
  # Process extensions
  set extensions_list $extensions
  unset extensions
  array set extensions $extensions_list

  # If we are generating a CA cert, add a CA extension

  # Determine what version we need to use (default to 1)
  if {[array get extensions] == ""} {
    set version 1
  } else {
    set version 3
  }
  set version 3

  set certlist [list]

  # Create certificate to be signed
  ## Insert version number (if not version 1)
  if {$version != 1} {
    lappend certlist [::asn::asnContextConstr 0 [::asn::asnInteger [expr {$version - 1}]]]
  }
  ## Insert serial number
  lappend certlist [::asn::asnBigInteger [math::bignum::fromstr $serial_number]]


  ## Insert data algorithm
  if {[info exists cakey(group)] } {
    set pubkeyinfo_bin [ binary format H* $cakey(pubkeyinfo) ]
    lappend certlist [::asn::asnSequence \
    [::asn::asnObjectIdentifier $algo ] \
    [::asn::asnNull] \
    ]
  } else {
    set type $signreq(type)
    lappend certlist [::asn::asnSequence \
    [::asn::asnObjectIdentifier [::pki::_oid_name_to_number "${algo}With${type}Encryption"]] \
    [::asn::asnNull] \
    ]
  }

  ## Insert issuer
  if { $certfor == 0 } {
    lappend certlist [::asn::asnSequence [string_to_dn_tc26 $signreq(subject)]]
  } else {
    lappend certlist [::asn::asnSequence [string_to_dn_tc26 $cakey(issuer)]]
  }

  ## Insert validity requirements
  lappend certlist [::asn::asnSequence \
  [::asn::asnUTCTime [::pki::x509::_native_to_utctime $notBefore]] \
  [::asn::asnUTCTime [::pki::x509::_native_to_utctime $notAfter]] \
  ]

  ## Insert subject
  #Решить как выпускать одним сертификатом или двумя ??!!!
  #Для SSL-сертификата меняем CM= на $cakey(subject)

  #tk_messageBox -title "Самоподписанный сертификат" -icon info -message "signreq(subject)=$signreq(subject)\n"  -parent . -detail "signreq(extensions)=$signreq(extensions)"
  lappend certlist [::asn::asnSequence [string_to_dn_tc26 $signreq(subject)]]

  set idis ""
  if { $certfor == 0 } {
    set xx $signreq(extensions)
    array set xxr $xx
    set xx $xxr(id-ce-subjectKeyIdentifier)
    set xx [lindex $xx 1]
    set idissuer [binary format H* [string range $xx 4 end]]

    #	        id-ce-subjectKeyIdentifier
    #id-ce-authorityKeyIdentifier = 2 5 29 35
    #tk_messageBox -title "Самоподписанный сертификат" -icon info -message "$xx"  -detail "$idissuer" -parent .
  } else {
    set idissuer $cakey(issuer_id)
  }
  set idis [::asn::asnSequence \
  [::asn::asnObjectIdentifier [::pki::_oid_name_to_number "id-ce-authorityKeyIdentifier"]] \
  [::asn::asnOctetString \
  [::asn::asnSequence \
  [::asn::asnContext 0 $idissuer] \
  ] \
  ] \
  ]
  ## Insert public key information
  if {[info exists cakey(group)]} {
    #GOST
    lappend certlist $pubkeyinfo_bin
  } else {
    switch -- $type {
      "rsa" {
        set pubkey [::asn::asnSequence \
        [::asn::asnBigInteger [::math::bignum::fromstr $signreq(n)]] \
        [::asn::asnBigInteger [::math::bignum::fromstr $signreq(e)]] \
        ]

        set pubkey_algo_params [::asn::asnNull]
      }
    }
    binary scan $pubkey B* pubkey_bitstring

    lappend certlist [::asn::asnSequence \
    [::asn::asnSequence \
    [::asn::asnObjectIdentifier [::pki::_oid_name_to_number "${type}Encryption"]] \
    $pubkey_algo_params \
    ] \
    [::asn::asnBitString $pubkey_bitstring] \
    ]
  }
  ## Insert extensions
  #ADD id-ce-authorityKeyIdentifier
  append signreq(extensions_bin) $idis

  set extku ""
  if { $certfor == 2 } {
    #Расширения для SSL-сертификата
    set tlsser ""
    set tlsoid ""
    if {$::tlssrv} {
      set tlsoid [::asn::asnObjectIdentifier "1 3 6 1 5 5 7 3 1"]
    }
    if {$::tlscln} {
      append tlsoid [::asn::asnObjectIdentifier "1 3 6 1 5 5 7 3 2"]
    }
    if {$tlsoid != ""} {
      set tlsser [::asn::asnSequence \
      [::asn::asnObjectIdentifier "2 5 29 37"] \
      [::asn::asnOctetString \
      [::asn::asnSequence $tlsoid] \
      ] \
      ]
      set extku $tlsser
    }
  }
  append signreq(extensions_bin) $extku
  #	lappend certlist [::asn::asnContextConstr 3 [::asn::asnSequence $signreq(extensions_bin)]]
  set extsan ""
  if { $certfor == 2 } {
    #SSL-сертификат
    set j 1
    foreach cb {email dns ip} {
      set a [subst ::Liste$cb]
      set b [subst $$a]
      set l [llength $b]
      puts "Liste$cb=$b, len=$l\n"
      set nn $j
      if {$nn == 3} {
        set nn 7
      }
      if {$l > 1} {
        foreach tt $b {
          puts "$cb : $tt\n"
          if {$tt == ""} {
            break
          }
          if {$nn != 7} {
            append extsan [::asn::asnContext $nn $tt]
          } else {
            #Проверку IP-адреса уже сделали
            set vip [::ip::version $tt]
            set nip [::ip::Normalize $tt $vip]
            append extsan [::asn::asnContext $nn $nip]
          }
        }
      }
      incr j
    }
    set extsan1 ""
    if {$extsan != "" } {
      puts "extsan != пусто\n"
      set extsan1 [::asn::asnSequence \
      [::asn::asnObjectIdentifier "2 5 29 17"] \
      [::asn::asnOctetString \
      [::asn::asnSequence $extsan] \
      ] \
      ]
                              		
    }
    append signreq(extensions_bin) $extsan1
  }
  lappend certlist [::asn::asnContextConstr 3 [::asn::asnSequence $signreq(extensions_bin)]]

  ## Enclose certificate data in an ASN.1 sequence
  #return ""
  # Sign certificate request using CA
  set cert [::asn::asnSequenceFromList $certlist]
  switch -- $algo {
    "1.2.643.7.1.1.3.2" - "1 2 643 7 1 1 3 2" {
      #     "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256"
      set stribog "stribog256"
    }
    "1.2.643.7.1.1.3.3" - "1 2 643 7 1 1 3 3" {
      #    "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512"
      set stribog "stribog512"
    }
    default {
      tk_messageBox -title "Самоподписанный сертификат" -icon info -message "Невозможно создать подпись" -detail "Неизвестный алгоритм подписи:\n\t$algo" -parent .
      return ""
    }
  }
  #Оригинал для Хэш передается в оригигальном виде
  set digest_cert_hex    [pki::pkcs11::dgst $stribog $cert]

  if {![info exists cakey(group)]} {
    set signature [::pki::sign $digest_cert_hex $cakeylist $algo]
  } else {
    set lenkey [string length $cakey(privkey)]
    #tk_messageBox -title "сертификат" -message "algo=$algo\nlenkey=$lenkey\n$stribog\n$cakey(group)" -icon info  -parent .
    #puts "LENKEY=$lenkey"
    set rnd_ctx [lrnd_random_ctx_create ""]
    set rnd_bytes [lrnd_random_ctx_get_bytes $rnd_ctx $lenkey]
    set digest_cert_bin [binary format H* $digest_cert_hex]

    if { $lenkey == 32 } {
      set signature [lcc_gost3410_2012_256_sign $cakey(group) $cakey(privkey) $digest_cert_bin $rnd_bytes]
    } elseif {$lenkey == 64 } {
      set signature [lcc_gost3410_2012_512_sign $cakey(group) $cakey(privkey) $digest_cert_bin $rnd_bytes]
    } else {
      puts "BAD key=$lenkey"
      return ""
    }
  }

  binary scan $signature B* signature_bitstring

  if {[info exists cakey(group)] } {
    set cert [::asn::asnSequence \
    $cert \
    [::asn::asnSequence \
    [::asn::asnObjectIdentifier $algo] \
    [::asn::asnNull] \
    ] \
    [::asn::asnBitString $signature_bitstring] \
    ]
  } else {
    set cert [::asn::asnSequence \
    $cert \
    [::asn::asnSequence \
    [::asn::asnObjectIdentifier [::pki::_oid_name_to_number "${algo}With${type}Encryption"]] \
    [::asn::asnNull] \
    ] \
    [::asn::asnBitString $signature_bitstring] \
    ]
}
  if {$encodePem} {
    set cert [::pki::_encode_pem $cert "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]
  }
  return $cert
}

proc create_asnextkey {oids} {
  if {[llength $oids] == 0} {
    return ""
  }
  set extkeyuse ""
  foreach oid $oids {
    set oidt [string map {"." " "} $oid]
    append extkeyuse [::asn::asnObjectIdentifier $oidt ]
  }
  set asnextkeyuse  [::asn::asnSequence [::asn::asnObjectIdentifier "2 5 29 37"] \
  [::asn::asnOctetString  \
  [::asn::asnSequence $extkeyuse] \
  ] \
  ]

  return $asnextkeyuse
}


# Generate a PKCS#10 Certificate Signing Request
proc ::pki::pkcs::create_csr_OK {typegost userkey_hex namelist subjectsigntool extkeyuse {encodePem 0} aa} {
  variable certfor
  if {$typegost == "g12_512"} {
    set ckm "CKM_GOSTR3410_512"
    set stribog "stribog512"
    set signkey "1 2 643 7 1 1 3 3"
  } elseif {$typegost == "g12_256"} {
    set ckm "CKM_GOSTR3410"
    set stribog "stribog256"
    set signkey "1 2 643 7 1 1 3 2"
  } elseif {$typegost == "gost2001"} {
    set ckm "CKM_GOSTR3410"
    set stribog "gostr3411"
    set signkey "1 2 643 2 2 3"
  } else {
    return ""
  }

  set extreq "1 2 840 113549 1 9 14"
  set subjectst "1 2 643 100 111"
  #puts "DN=$namelist"
  set userkey [binary format H* $userkey_hex]
  array set ar_aa $aa
  if {[info exists ar_aa(group)]} {
    ::asn::asnGetSequence userkey userkey1
    set userkey $userkey1
  }

  #Идентификатор ключа получателя (CKA_ID)
  binary scan  $userkey H*  userk_hex
  array set infopk [parse_key_gost $userk_hex]
  #Учет требований ТК-26 по par_sign
  set userkey [create_asn_pubkey $infopk(pubkey_algo) $infopk(paramkey) $infopk(hashkey) $infopk(pubkey)]

  set pubkeysub  [binary format H* $infopk(pubkey)]
  set pkcs11id_bin [lcc_sha1 $pubkeysub]
  binary scan $pkcs11id_bin H* pkcs11id_hex
  # "id-ce-subjectKeyIdentifier" = 2 5 29 14
  #tk_messageBox -title "create_csr_OK" -icon info -message "$ckm\n$pkcs11id_hex" -detail "$infopk(pubkey)"
  #		[::asn::asnBoolean $critical]
  set idsub [::asn::asnSequence \
  [::asn::asnObjectIdentifier [::pki::_oid_name_to_number "id-ce-subjectKeyIdentifier"]] \
  [::asn::asnOctetString [::asn::asnOctetString $pkcs11id_bin]] \
  ]
  #set idsub ""

  set name [list_to_dn_tc26 $namelist]
  #Creare asn1 keyusage
  set k 0
  set ku_m ""
  foreach v $::ku_options {
    set ku "::ku"
    append ku $k
    #puts "KU=$ku"
    set ku [subst $$ku]
    append ku_m $ku
    incr k
  }
  #puts "KU=$ku_m"
  set one_last [string last "1" $ku_m ]
  set ku_m [string range $ku_m 0 $one_last]
  set asn_ku [::asn::asnBitString $ku_m]
  #binary scan $asn_ku H* ku_hex
  #puts "KU_HEX=$ku_hex"
  set isca [lsearch $::bc_options $::bc]
  # If we are generating a CA cert, add a CA extension
  set id_ce_bc ""
  switch $isca {
    0 {
      set id_ce_bc ""
    }
    1 {
      set id_ce_bc [list false false -1]
    }
    2 {
      set id_ce_bc [list true false -1]
    }
    3 {
      set id_ce_bc [list false true 0]
    }
    4 {
      set id_ce_bc [list true true 0]
    }
  }

  set ext_bc ""
  if {$id_ce_bc != "" } {
    set critical [lindex $id_ce_bc 0]
    set allowCA [lindex $id_ce_bc 1]
    set caDepth [lindex $id_ce_bc 2]

    if {$caDepth < 0} {
      set extvalue [::asn::asnSequence [::asn::asnBoolean $allowCA]]
    } else {
      set extvalue [::asn::asnSequence [::asn::asnBoolean $allowCA] [::asn::asnInteger $caDepth]]
    }
    set  ext_bc [::asn::asnSequence \
    [::asn::asnObjectIdentifier [::pki::_oid_name_to_number "id-ce-basicConstraints"]] \
    [::asn::asnBoolean $critical] \
    [::asn::asnOctetString $extvalue] \
    ]	
  }
  set extsubsigntool ""
  if {$subjectsigntool != ""} {
    set extsubsigntool [::asn::asnSequence [::asn::asnObjectIdentifier $subjectst] \
    [::asn::asnOctetString [::asn::asnUTF8String $subjectsigntool]] \
    ]
  }


  #  $userkey
  #  [::asn::asnSequence $userkey ]
  set cert_req_info [::asn::asnSequence \
  [::asn::asnInteger 0] \
  [::asn::asnSequence $name] \
  $userkey \
  [::asn::asnContextConstr 0 \
  [::asn::asnSequence [::asn::asnObjectIdentifier $extreq] \
  [::asn::asnSet \
  [::asn::asnSequence \
  $ext_bc \
  [::asn::asnSequence [::asn::asnObjectIdentifier "2 5 29 15"] \
  [::asn::asnOctetString $asn_ku] \
  ] \
  $extkeyuse \
  $extsubsigntool \
  $idsub \
  ] \
  ] \
  ] \
  ] \
  ]

  #Посчитать хэш от tbs-сертификата!!!!
  binary scan $cert_req_info H* tbs_csr_hex
  #puts "AA=$aa"
  #puts "TBS_CSR=$tbs_csr_hex"
  #Оригинал для Хэш передается в оригигальном виде
  if {$typegost == "gost2001"} {
    set digest_hex    [$::tokenls11sw0 digest $stribog $cert_req_info]
  } else {
    set digest_hex    [pki::pkcs11::dgst $stribog $cert_req_info]
  }
  #puts "DIGEST=$digest_hex"
  #Определяем на каком ключе токен или LCC создается запрос
  if {![info exists ar_aa(group)]} {
    array set rr $aa
    tk_messageBox -title "create_csr_OK" -message "[array names rr]"

    #    set sign_csr_hex  [pki::pkcs11::sign $ckm $digest_hex  $aa]
    set sign_csr_hex  [$::tokenls11sw0 signcert $ckm $digest_hex  $rr(pkcs11_id)]
    #    if {[catch {set verify [pki::pkcs11::verify $digest_hex $sign_csr_hex $aa]} res] } {}
    if {[catch {set verify [$::tokenls11sw0 verify $digest_hex $sign_csr_hex $rr(pubkeyinfo)]} res] } {
      #	puts "BEDA=$res"
      return ""
    }
  } else {
    # generate random bytes for signature
    set lenkey [string length $ar_aa(privkey)]
    puts "LENKEY=$lenkey"
    set rnd_ctx [lrnd_random_ctx_create ""]
    set rnd_bytes [lrnd_random_ctx_get_bytes $rnd_ctx $lenkey]
    set digest_bin [binary format H* $digest_hex]
                    	
    if { $lenkey == 32 } {
      set sign_csr [lcc_gost3410_2012_256_sign $ar_aa(group) $ar_aa(privkey) $digest_bin $rnd_bytes]
    } elseif {$lenkey == 64 } {
      set sign_csr [lcc_gost3410_2012_512_sign $ar_aa(group) $ar_aa(privkey) $digest_bin $rnd_bytes]
    } else {
      puts "BAD key=$lenkey"
      return ""
    }
    binary scan  $sign_csr H*  sign_csr_hex
    set verify 1
    set len_sign [string length $sign_csr]
    #    puts "::pki::pkcs::create_csr_OK for LCC=$len_sign"
    if { $len_sign != 128 && $len_sign != 64} {
      puts "BAD signature=$len_sign"
      return ""
    }
  }
  if {$verify != 1} {
    puts "BAD SIGNATURE=$verify"
    return ""
  } else {
    puts "SIGNATURE OK=$verify"
  }

  set signature [binary format H* $sign_csr_hex]

  binary scan $signature B* signature_bitstring
          	
  set cert_req [::asn::asnSequence \
  $cert_req_info \
  [::asn::asnSequence [::asn::asnObjectIdentifier $signkey] ] \
  [::asn::asnBitString $signature_bitstring] \
  ]

  if {$encodePem} {
    set cert_req [::pki::_encode_pem $cert_req "-----BEGIN CERTIFICATE REQUEST-----" "-----END CERTIFICATE REQUEST-----"]
  }
  return $cert_req
}

proc CreateSelfCertTCL {profilename attributes} {
  global param3410
  variable certfor
  global yespas
  global pass

  upvar $attributes attr

  if { $certfor != 0 } {
    # Не корневой сертификат
    #Проверяем наличие корневого сертификата и ключа
    set capfx [file join $attr(csr_fn) rootCA.pfx]
    if {![file exists $capfx]} {
      tk_messageBox -title "Выпуск сертификат" -message "Отсутствует корневой сертификат:\n$capfx\n" -detail "Каталог:\n$attr(csr_fn)" -icon error  -parent .
      return ""
    }
  }

  set parkey [string map {"." " "} $attr(parkey)]
  set parkey_name $param3410($parkey)

  puts "CreateSelfCertTCL parkey=$attr(parkey) $parkey_name $parkey"
  # generate random private key
  set rnd_ctx [lrnd_random_ctx_create ""]
  if {$attr(typekey) == "gost2012_512" }  {
    set typegost "g12_512"
    set sign_algo "1 2 643 7 1 1 3 3"
    set pubkey_algo "1 2 643 7 1 1 1 2"
    set par_hash "1 2 643 7 1 1 2 3"
    set group [lcc_gost3410_2012_512_getGroupById "$parkey_name"]
    set rnd_bytes [lrnd_random_ctx_get_bytes $rnd_ctx 64]
    set private_key_str [lcc_gost3410_2012_512_createPrivateKey $group $rnd_bytes]
  } elseif {$attr(typekey) == "gost2012_256" } {
    set typegost "g12_256"
    set sign_algo "1 2 643 7 1 1 3 2"
    set pubkey_algo "1 2 643 7 1 1 1 1"
    set par_hash "1 2 643 7 1 1 2 2"
    set group [lcc_gost3410_2012_256_getGroupById "$parkey_name"]
    set rnd_bytes [lrnd_random_ctx_get_bytes $rnd_ctx 32]
    set private_key_str [lcc_gost3410_2012_256_createPrivateKey $group $rnd_bytes]
  } elseif {$attr(typekey) == "rsa" } {
    puts "RSA"
    set pubkey_algo "sha256"
  }
  #Готовим закрытый ключ для сохранения в файле
  set par_sign $parkey
  #Готовим публичный ключ для сертификата
  set asn_pubkey [create_asn_pubkey_for_cert $pubkey_algo $par_sign $par_hash $private_key_str]
  binary scan $asn_pubkey H* userkey_hex

  set key {}
  lappend key "group"
  lappend key $group
  lappend key "privkey"
  lappend key $private_key_str
  lappend key "pubkeyinfo"
  lappend key $userkey_hex

  #####################
  #puts "PUBKEYINFO=$genkey(pubkeyinfo)"
  puts "DNCSR=$attr(dncsr)"
  set usercsr [ pki::pkcs::create_csr_OK $typegost $userkey_hex  $attr(dncsr) $attr(ckzi) "" 1 $key]
  #  puts "PrivKey Len=[string length $private_key_str]"
  if {$usercsr == ""} {
    #    puts "CreateSelfCertTCL: Cannot create CSR"
    return ""
  }

  #Создаем сертификат
  set csr [pki::pkcs::parse_csr_gost $usercsr]
  #В сутках 86400 секунд
  set secday 86400
  # В году секунд
  set secyear [expr {$secday * 365}]
  set notbefor [clock seconds]
  set notafter [expr {$notbefor + ($::yearcert * $secyear) + ($::dayscert * $secday) }]
  #tk_messageBox -title "Выпуск сертификат" -icon error -message "DAYCERT:\n$::dayscert" -detail "NOTAFTER=$notafter"  -parent .
  if { $certfor != 0 } {
    #Выкуск сертификатов пользователя и SSL-сертификатов
    set capfx_f [file join $attr(csr_fn) rootCA.pfx]
    set fd [open $capfx_f]
    chan configure $fd -translation binary
    set capfx [read $fd]
    close $fd
    #Ввод пароля
    read_password "Введите пароль для \"[file tail $capfx_f]\""
    if { $yespas == "no" } {
      return ""
    }
    set yespas "no"
    set password $pass
    set pass ""

    set p12er [catch {array set dCertKey [::GostPfx::pfxGetSingleCertKey $capfx "$password" $::nomacver]} rp12]
    set password ""
    if {$p12er} {
      tk_messageBox -title "Выпуск сертификат" -icon error -message "Это не PKCS12 корневого сертификата или плохой пароль." -detail "CreateSelfCertTCL $rp12"  -parent .
      return ""
    }
    if {![info exists dCertKey(certificate)]} {
      tk_messageBox -title "Выпуск сертификат" -icon error -message "В контейнере отсутствует корневой сертификат:\$capfx"  -parent .
      return ""
    }
    if {![info exists dCertKey(keyValue)]} {
      tk_messageBox -title "Выпуск сертификат" -icon error -message "В контейнере отсутствует закрытый ключ:\$capfx"  -parent .
      return ""
    }
    set cader $dCertKey(certificate)
    if {$cader == ""} {
      tk_messageBox -title "Выпуск сертификат" -message "В контейнере отсутствует сертификат:\n$capfx\n" -icon error  -parent .
      return;
    }
    set cacrt $dCertKey(certificate)
    binary scan $dCertKey(certificate) H* cacrt_hex

    set parkey $dCertKey(gost3410Paramset)
    set parkey_name $param3410($parkey)
    if {$dCertKey(keyAlg) == "1 2 643 7 1 1 1 1"} {
      set group [lcc_gost3410_2012_256_getGroupById "$parkey_name"]
      set sign_algo "1 2 643 7 1 1 3 2"
    } elseif {$dCertKey(keyAlg) == "1 2 643 7 1 1 1 2"} {
      set group [lcc_gost3410_2012_512_getGroupById "$parkey_name"]
      set sign_algo "1 2 643 7 1 1 3 3"
    } else {
      tk_messageBox -title "Выпуск сертификат" -message "Неподдерживаемый тип ключа:\n$dCertKey(keyAlg)" -icon error  -parent .
      return ""
    }
    array set parsecert [pki::x509::parse_cert $cacrt]
    array set extcert $parsecert(extensions)
    binary scan  $cader H* cacrt_hex
    array set infopk [pki::pkcs11::pubkeyinfo $cacrt_hex]
    array set retpk [parse_key_gost $infopk(pubkeyinfo)]
    #Идентификатор ключа УЦ
    set pk_bin [binary format H* $retpk(pubkey)]
    set pkcs11id_bin [lcc_sha1 $pk_bin]

    set key {}
    lappend key "group"
    lappend key $group
    lappend key "privkey"
    lappend key $dCertKey(keyValue)

    lappend key "pubkeyinfo"
    lappend key $userkey_hex
    lappend key "issuer"
    lappend key $parsecert(issuer)
    lappend key "issuer_id"
    lappend key $pkcs11id_bin
                    	
    #    	tk_messageBox -title "Выпуск сертификат" -message "В стадии реализации:\n$parkey_name\nsign_algo???=$sign_algo"  -icon info  -parent .
    if {$::pointca != ""} {
      array set csr_ar $csr
      append csr_ar(extensions_bin) [createpointCA $::pointca]
      set csr [array get csr_ar]
    }

    set crt [::pki::x509::create_self_cert $csr $key $::snforcert $notbefor $notafter [list ] 0 $sign_algo]
  } else {
    #Выпускаем самоподписанный корневой сертификат
    set crt [::pki::x509::create_self_cert $csr $key $::snforcert $notbefor $notafter [list ] 0 $sign_algo]
  }
  if {$crt == ""} {
    tk_messageBox -title "Выпуск сертификат" -icon error -message "Невозможно создать сертификат (certfor=$certfor)" -parent .
    return ""
  }

  #Временно пишем запрос
  set ret $usercsr
  #Пакуем в PKCS#12
  # =======================================================
  # Create localKeyID: private keyValue+keyAlg+gost3410Paramset->public key value->octet string->sha1=>localKeyID
  # =======================================================
  set localKeyID [::GostPfx::pfxCreateLocalKeyID $pubkey_algo $par_sign $private_key_str]
  set nn $::snforcert
  set friendlyName "cryptoarmpkcs_$nn"
  # =======================================================
  # Create new PFX container TC 26 v2:
  # =======================================================
  set newPfx [::GostPfx::pfxCreateSingleCertKey $::rpw $crt $private_key_str $pubkey_algo $par_sign $par_hash $friendlyName $localKeyID]
  set ::pw ""
  set ::rpw ""
  if {[string length $newPfx] == 0} {
    tk_messageBox -title "Выпуск сертификата" -icon error -message "Невозможно создать контейнер PKCS#12" -parent .
    return ""
  }
  if {$::formatCSR == 1} {
    set crt [::pki::_encode_pem $crt "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]
  }
  #Сохраняем закрытый ключ
  set asn_privkey [create_asn_privkey $pubkey_algo $par_sign $par_hash $private_key_str]
  if {$certfor != 0 } {
    if {1} {
      set filekey [file join $attr(csr_fn) self_$::snforcert.key]
      if {$::formatCSR == 1} {
        set asn_privkey [::pki::_encode_pem $asn_privkey "-----BEGIN PRIVATE KEY-----" "-----END PRIVATE KEY-----"]
      }
      set fd [open $filekey w]
      chan configure $fd -translation binary
      puts -nonewline $fd $asn_privkey
      close $fd
    }
    #Сохраняем сертификат
    set filecrt [file join $attr(csr_fn) self_$::snforcert.cer]
    set fd [open $filecrt w]
    chan configure $fd -translation binary
    puts -nonewline $fd $crt
    close $fd
    #Сохраняем сертификат в PKCS#12
    set filecrt [file join $attr(csr_fn) self_$::snforcert.pfx]
    set fd [open $filecrt w]
    chan configure $fd -translation binary
    puts -nonewline $fd $newPfx
    close $fd
  } else {
    if {1} {
      if {$::formatCSR == 1} {
        set asn_privkey [::pki::_encode_pem $asn_privkey "-----BEGIN PRIVATE KEY-----" "-----END PRIVATE KEY-----"]
      }
      set filekey [file join $attr(csr_fn) rootCA.key]
      set fd [open $filekey w]
      chan configure $fd -translation binary
      puts -nonewline $fd $asn_privkey
      close $fd
    }
    #Сохраняем корневой сертификат
    set filecrt [file join $attr(csr_fn) rootCA.cer]
    set fd [open $filecrt w]
    chan configure $fd -translation binary
    puts -nonewline $fd $crt
    close $fd
    #Сохраняем корневой сертификат в PKCS#12
    set filecrt [file join $attr(csr_fn) rootCA.pfx]
    set fd [open $filecrt w]
    chan configure $fd -translation binary
    puts -nonewline $fd $newPfx
    close $fd
  }
  incr ::snforcert

  return $ret
}

proc CreateRequestTCL {profilename attributes} {
  global env
  global typeCert

  upvar $attributes attr
  array set tkey {gost2001 gost2001 gost2012_512 gost3410-2012-512 gost2012_256 gost3410-2012-256}
  #  parray tkey
  #set typeCert  {"Физическое лицо" reqFL "Индивидуальный предприниматель" reqIP "Юридическое лицо" reqUL}
  set oidtype ""
  foreach {ru lat} $typeCert {
    #puts "RU=$ru"
    #puts "LAT=$lat"
    if {$attr(type) == $ru } {
      switch --  $lat {
        "reqFL" {
          set oidtype "1.2.643.6.3.1.2.2"
        }
        "reqUL" {
          set oidtype "1.2.643.6.3.1.2.1"
        }
        "reqIP" {
          set oidtype "1.2.643.6.3.1.2.3"
        }
      }
    }
  }
  set temp ""

  # + 32768 для неэкспортируемого ключа
  set typegost ""
  switch -- $tkey($attr(typekey)) {
    "gost2001" {
      set typegost gost2001
      set stribog gostr3411
    }
    "gost3410-2012-256" {
      set typegost g12_256
      set stribog stribog256
    }
    "gost3410-2012-512" {
      set typegost g12_512
      set stribog stribog512
    }
  }
  if {$attr(expkey) == 1} {
    incr tpkey 32768
  }
  set token_slotid $::slotid_tek
  puts "token_slotid=$token_slotid"
  if { [pki::pkcs11::login $::handle $token_slotid $attr(keypassword)] == 0 } {
    tk_messageBox -title "Запрос на сертификат" -message "Не смогли залогиниться на токене\nПроверьте PIN-код." -icon error  -parent .
    return ""
  }
  set aa [list "pkcs11_handle" $::handle "pkcs11_slotid" $token_slotid]
  #tk_messageBox -title "Запрос на сертификат" -message "type=$typegost tpkey=$attr(parkey)" -icon error  -parent .
  array set genkey [::pki::pkcs11::keypair $typegost $attr(parkey) $aa ]
  #puts "Ключевая пара $typegost создана"
  #parray genkey
  #puts "pkcs11_id=\"$genkey(pkcs11_id)\""
  lappend aa "pkcs11_id"
  lappend aa $genkey(pkcs11_id)
  #Установить метку ключевой пары
  lappend aa "pkcs11_label"
  if {$::egais == 1 && $attr(type) != "Физическое лицо"} {
    set tekt [clock format [clock seconds] -format {%y%m%d%H%M}]
    if {$attr(type) == "Индивидуальный предприниматель"} {
      set lenkpp 0
      set inn $attr(INN)
    } else {
      set lenkpp [string length $attr(UN)]
      set inn $attr(INNLE)
#      set inn [string trimleft $attr(INN) "0"]
    }
    if {$lenkpp != 0 && $lenkpp != 9 } {
      tk_messageBox -title "Запрос на сертификат" -message "Ошибка в поле КПП." -detail "Поле должно быть пустым или содеожать 9 цифр" -icon error  -parent .
      return ""
    }
    if {$lenkpp == 9} {
      set labkey "$tekt-$inn-$attr(UN)"
    } else {
      set labkey "$tekt-$inn"
    }
  } else {
    set labkey $attr(CN)
  }
  puts "labkey=$labkey"
  lappend aa $labkey
  pki::pkcs11::rename key $aa

  lappend aa "pubkeyinfo"
  lappend aa $genkey(pubkeyinfo)

  #####################
  #puts "PUBKEYINFO=$genkey(pubkeyinfo)"
  set   userkey_hex  $genkey(pubkeyinfo)

  set ekeyuse ""
  set oids ""
  if {$attr(type) == "Юридическое лицо" && $::egais == 1 } {
    set oids $::oidegais
    if {$::lisalko == 1} {
      #	    lappend oids $::oidalko
      lappend oids $::oidlizfsrar

    }
  } elseif {$attr(type) == "Индивидуальный предприниматель" && $::egais == 1 } {
    set oids $::oidegais
    if {$::lisalko == 1} {
      #	    lappend oids $::oidalko
      lappend oids $::oidlizfsrar
    }
  }
  set ekeyuse [create_asnextkey $oids]

  set usercsr [ pki::pkcs::create_csr_OK $typegost $userkey_hex  $attr(dncsr) $attr(ckzi) $ekeyuse $::formatCSR $aa]
  #puts $usercsr
  return [list $usercsr $labkey]
}


proc ::finalizeCSR {tpage} {
  variable certfor
  global wizDatacsr
  global wizDatacert
  if {$tpage == "csr"} {
    array set wizData [array get wizDatacsr]
    array set attr [array get wizData]
    set ercreate "Ошибка генерации запроса.\n"
    set tit "Запрос на сертификат"
    set msgok "Запрос успешно создан в файле\n$attr(csr_fn)"
    set detok "Закрытый ключ сохранен на токене\n$attr(token)"
  } else {
    array set wizData [array get wizDatacert]
    array set attr [array get wizData]
    set ercreate "Ошибка создания самоподписанного сертификата.\n"
    set tit "Самоподписанный сертификат"
    if {$certfor != 0} {
      set selfcsr [file join $attr(csr_fn) self_$::snforcert.csr]
      set selfp12cert [file join $attr(csr_fn) self_$::snforcert.pfx]
      set selfcert [file join $attr(csr_fn) self_$::snforcert.cer]
      #	    set selfkey $attr(key_fn)
      set selfkey [file join $attr(csr_fn) self_$::snforcert.key]
    } else {
      set selfcsr [file join $attr(csr_fn) "rootCA.csr"]
      set selfp12cert [file join $attr(csr_fn) "rootCA.pfx"]
      set selfcert [file join $attr(csr_fn) "rootCA.cer"]
      set selfkey [file join $attr(csr_fn) "rootCA.key"]
    }
    set msgok "Сертификат успешно создан в файле\n$selfcert\nСертификат и закрытый ключ сохранены в контейнере PKCS#12:\n$selfp12cert\nНикому не передавайте пароль к контейнеру"
    set detok "Закрытый ключ сохранен также в файле\n$selfkey\nНикому не передавайте закрытый ключ."
    #	set detok ""
    append detok "\nЗапрос на сертификат сохранен в файле\n$selfcsr"
  }
  # only create certificate request to file
  set profile $attr(type)
  #puts "PROFILE=$profile"
  #parray attr
  #puts "wizData"
  #parray wizData

  if {$tpage == "csr"} {
    #    	    set req [CreateRequestTCL $profile attr]
    foreach {req labk} [CreateRequestTCL $profile attr] {}
    append detok "\nМетка ключевой пары:\n$labk"
  } else {
    #tk_messageBox -title $tit -message $msgok -detail $detok -icon info  -parent .
    #set ::pw 01234567
    #set ::rpw 01234567
    if {$::rpw != $::pw || $::rpw == ""} {
      tk_messageBox -title "Выпуск сертификата" -message "Ошибка в пароле для Вашего PKCS#12.\nВернитесь на шаг назад и задайте пароль" -detail "(Пароль не может быть пустым)" -icon error  -parent .
      return -code break
    }

    set req [CreateSelfCertTCL $profile attr]
  }

  if {$req == "" } {
    tk_messageBox -title $tit -message $ercreate -icon error  -parent .
    return -code break
  }
  if {$tpage == "csr"} {
    set fd [open $wizData(csr_fn) w]
  } else {
    set fd [open $selfcsr w]
  }
  chan configure $fd -translation binary
  puts -nonewline $fd $req
  close $fd
  tk_messageBox -title $tit -message $msgok -detail $detok -icon info  -parent .

  #array set csr_parse [::pki::pkcs::parse_csr_gost $req]
  #parray csr_parse

  return -code break
}

proc nextStep {tpage numpage} {
  global certfor
  global wizDatacsr
  global wizDatacert
  global reqFL
  global typeCert
  global sodCert
  set currentStep $numpage
  incr currentStep -1

  #parray wizDatacsr
  #parray wizDatacert
  if {$tpage == "csr"} {
    array set wizData [array get wizDatacsr]
  } else {
    array set wizData [array get wizDatacert]
  }
  set keytok $wizData(keytok)
  #parray wizData

  #puts "CURRENT=$currentStep"
  if { $currentStep == 0} {
    return 1
  }
  if { $currentStep == 1 && $tpage == "cert" } {
    if {$certfor == 0 && $::ku5 == 0} {
      tk_messageBox -title "Выпуск сертификата" -message "Вы хотите выпустить корневой сертификат, но в назначении ключа отсутствует возможность подписания сертификатов!" -icon error  -parent .
      return 0;
    }
  }
  if { $currentStep == 1 && $tpage == "csr" && $keytok == 1} {
    #puts "TypeKey=$wizData(typekey)"
    #puts "token=$wizData(token)"
    #puts "LISTTS=$::listtok"
    #parray ::arlists
    #puts "SLOT=$::arlists($wizData(token))"
    set llmech [pki::pkcs11::listmechs $::handle $::slotid_tek]
    #puts  "MECH=$llmech"
    switch -- $wizData(typekey) {
      gost2001 {
        set err [string first "0x1200" $llmech]
        if {$err != -1 } {
          set err [string first "0x1210" $llmech]
        }
      }
      gost2012_256 {
        set err [string first "0x1200" $llmech]
        if {$err != -1 } {
          set err [string first "0xD4321012" $llmech]
        }
      }
      gost2012_512 {
        set err [string first "0xD4321005" $llmech]
      }	
      default {
        set err -1
      }
    }
    if {$err == -1} {
      tk_messageBox -title "Запрос на сертификат" -message "Токен $wizData(token)\nне поддерживает ключи $wizData(typekey)" -icon error  -parent .
      return 0;
    }
  } elseif {$currentStep == 2 || $currentStep == 3} {
    if {$wizData(CN) == ""} {
      tk_messageBox -title "Запрос на сертификат" -message "Пожалуйста, укажите владельца (CN) сертификата." -icon error  -parent .
      return 0;
    }
  } elseif {$currentStep == 5} {
    if {$tpage == "csr"} {
      if {$wizData(csr_fn) == ""} {
        tk_messageBox -title "Запрос на сертификат" -message "Не задан файл для сохранения запроса." -icon error  -parent .
        return 0
      }
      if {$wizData(keypassword) == ""} {
        tk_messageBox -title "Запрос на сертификат" -message "Задайте PIN-код." -icon error  -parent .
        return 0
      }
    } else {
      if {$wizData(csr_fn) == ""} {
        tk_messageBox -title "Выпуск сертификата" -message "Не выбран каталог для хранения сертификатов и ключей." -icon error  -parent .
        return 0
      }
      if {$::rpw != $::pw || $::rpw == ""} {
        tk_messageBox -title "Выпуск сертификата" -message "Ошибка в пароле для Вашего PKCS#12." -detail "(Пароль не может быть пустым)" -icon error  -parent .
        return 0
      }
    }
  } elseif {!$::checkfull } {
    return 1
  } elseif {$currentStep == 4} {
    set missingvalue 0
    set missinglist {}
    foreach {v req} $typeCert {
      if {$v == $wizData(type) } {
        array set profdate $sodCert($req)
        set reqFL1 $sodCert($req)
        break
      }
    }
    foreach {field dflt} $reqFL1 {
      if {$wizData($field) == ""} {
        if {$field == "UN" && $::egais == 0} {
          continue
        }
        set missingvalue 1
        lappend missinglist "$field"
      }
    }
    if {$wizData(E) != ""} {
      set mail [verifyemail $wizData(E)]
      if {$mail != "OK" } {
        tk_messageBox -title "Запрос на сертификат" -message "Вы неверно указали адрес электронной почты." -icon error  -parent .
        return 0
      }
    } else {
      tk_messageBox -title "Запрос на сертификат" -message "Вы не указали электронную почту"  -icon error  -parent .
      return 0
    }
    if {$wizData(INN) != ""} {
      set leninn [string length $wizData(INN)]
      if {$leninn != 12} {
        tk_messageBox -title "Запрос на сертификат" -message "Неправильная длина поля ИНН." \
        -detail "Для физлиц и ИП ИНН должен содержать 12 цифр." \
        -icon error  -parent .
        return 0
      }
    }
    if {$wizData(INNLE) != ""} {
      set leninn [string length $wizData(INNLE)]
      if {$leninn != 10} {
        tk_messageBox -title "Запрос на сертификат" -message "Неправильная длина поля ИНН." \
        -detail "Для юрлиц ИННЮЛ имеет 10 цифр" \
        -icon error  -parent .
        return 0
      }
    }
    if {$missingvalue && $tpage == "csr"} {
      tk_messageBox -title "Запрос на сертификат" -message "Вы не заполнили следующие обязательные поля:" -detail "[join $missinglist {, }]."  -icon error  -parent .
      return 0
    }
  }
  return 1
}

proc create_csr_list22 {type page num} {
  #puts "LIST2=$page"
  set c $page
  label $c.lab -text "WIZARD=$num"
  grid $c.lab -row 0 -column 0 -sticky w -padx 4 -pady 4
  grid columnconfigure $c 0 -weight 0
  grid columnconfigure $c 1 -weight 0
  grid columnconfigure $c 2 -weight 1
  grid rowconfigure $c 0 -weight 0
  grid rowconfigure $c 1 -weight 0
  return
}

proc egais_ul {w tpage } {
  set tface [$w get]
  set ind [string last "." $w]
  set win [string range $w 0 $ind]
  append win "egais"
  if {$tface == "Физическое лицо"} {
    #	puts "Win=$win"
    grid remove $win
  } else {
    grid $win
  }
}

proc create_csr_list1 {tpage c num} {
  global typesys
  global wizDatacsr
  global wizDatacert
  variable certfor
  global macos
  #puts "LIST1=$c"
  puts "create_csr_list1 tpage=$tpage"

  $c configure -bg white
  #    global wizData
  set typeCert  {"Физическое лицо" reqFL "Индивидуальный предприниматель" reqIP "Юридическое лицо" reqUL}
  label $c.l1 -text "Владелец сертификата:" -anchor nw
  #-width 27
#set xx [$c.l1 configure -font]
#tk_messageBox -title "Запрос на сертификат" -message "Font:" -detail "$xx"  -icon info  -parent .

  set listCert {}
  # insert existing profiles

  foreach {v req} $typeCert {
    lappend listCert $v
  }
  set wz [subst "wizData$tpage"]
  set type [subst "$wz\(type\)"]
  set typekey [subst "$wz\(typekey\)"]
  set parkey [subst "$wz\(parkey\)"]
  set ckzi [subst "$wz\(ckzi\)"]
  set expkey [subst "$wz\(expkey\)"]
  set selfca [subst "$wz\(selfca\)"]
  set selfssl [subst "$wz\(selfssl\)"]

  if {$tpage == "csr"} {
    set pretext "Укажите кто будет владельцем сертификата, для каких целей он будет использоваться.
    Выберите тип ключевой пары и токен, где она она будет сгенерирована и хранится.
    Укажите наименование вашего СКЗИ из сертификата соответствия."
    .st.fr1.fr2_list3.lab  configure  -text $pretext
    set dtfl $wizDatacsr(type)
  } else {
    set pretext "Укажите кто будет владельцем сертификата, для каких целей он будет использоваться.
    Выберите тип ключевой пары (ГОСТ Р 34.10-2012-256/512 или RSA).
    Наименование вашего СКЗИ - СКЗИ \"ЛИРССЛ-CSP\"."
    .st.fr1.fr2_list9.lab  configure  -text $pretext
    set dtfl $wizDatacert(type)
  }

  ttk::combobox $c.c1 -textvariable $type -values $listCert -state readonly -style TCombobox
    #     -width 35

  if {$tpage == "csr"} {
    bind $c.c1 <<ComboboxSelected>> {egais_ul %W "csr" }
  }

  if {$tpage == "cert"} {
    if {$typesys == "x11"} {
      ttk::frame $c.fcrt -padding 0
      #	 -relief flat -bg white  -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue -padx 0
      $c.fcrt configure -style RoundedLabelFrame
    } else {
      frame $c.fcrt  -relief flat -bg white  -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue -padx 0
    }
    label $c.lcrt -text "Выберите тип сертификата:" -bg white -anchor w
    ttk::radiobutton $c.fcrt.chb1 -value 1 -variable certfor -text "User" -pad 0
    #	 -highlightthickness 0 -disabledforeground #000000
    ttk::radiobutton $c.fcrt.chb2 -value 0 -variable certfor -text "CA (Корневой)" -pad 0
    #	-highlightthickness 0 -disabledforeground #000000
    #	ttk::radiobutton $c.lcrt.chb2 -value 0 -variable certfor -text "CA (Корневой)"
    ttk::radiobutton $c.fcrt.chb3 -value 2 -variable certfor -text "SSL" -pad 0
    #	 -highlightthickness 0
    pack $c.fcrt.chb1 -side left -padx {8 8} -pady {0 0} -fill y -expand 1 -pady 1
    pack $c.fcrt.chb2 -side left -padx {38 8} -pady {0 0} -fill y -expand 1 -pady 1
    pack $c.fcrt.chb3 -side right -padx {8 8} -pady {0 0} -fill y -expand 1 -pady 1
    #	grid $c.lcrt.chb1 -row 0 -column 0 -sticky wnse -padx {8 8} -pady {0 2}
    #	grid $c.lcrt.chb2 -row 0 -column 1 -sticky wnse -padx {8 8} -pady {0 2}
    #	grid $c.lcrt.chb3 -row 0 -column 2 -sticky wnse -padx {8 8} -pady {0 2}
  }

  #Type Key
  # combo box
  label $c.l3 -text "Тип ключа:" -font TkDefaultFontBold
  set listKey {gost2001 gost2012_256 gost2012_512}
  if {$tpage == "csr"} {
    set dflt $wizDatacsr(typekey)
  } else {
    set dflt $wizDatacert(typekey)
  }

  ttk::combobox $c.c3  -textvariable $typekey -values $listKey -state readonly  -style TCombobox
    # -width 13

  set $typekey $dflt
  #    $c.c3 delete 0 end
  #    set tekC [lsearch $listKey $dflt]
  #    $c.c3 insert end [lindex $listKey $tekC]

  #puts "C=$c"
  if {$tpage == "csr"} {
    bind $c.c3 <<ComboboxSelected>> {keyParam %W "csr" $wizDatacsr(typekey)}
  } else {
    bind $c.c3 <<ComboboxSelected>> {keyParam %W "cert" $wizDatacert(typekey)}
  }

  label $c.l4 -text "Параметры ключа:" -anchor w
  # -font TkDefaultFontBold
  if {$dflt == "gost2012_512"} {
    #    $c.l4 configure -text "Параметры для ГОСТ-2012-512"
    set listBits {1.2.643.7.1.2.1.2.1 1.2.643.7.1.2.1.2.2 1.2.643.7.1.2.1.2.3}
  } elseif {$dflt == "gost2012_256"} {
    #    $c.l4 configure -text "Параметры для ГОСТ-12-256"
    set listBits {1.2.643.2.2.35.1 1.2.643.2.2.35.2  1.2.643.2.2.35.3  1.2.643.2.2.36.0 1.2.643.2.2.36.1 1.2.643.7.1.2.1.1.1 1.2.643.7.1.2.1.1.2 1.2.643.7.1.2.1.1.3 1.2.643.7.1.2.1.1.4}
  } elseif {$dflt == "gost2001"} {
    #    $c.l4 configure -text "Параметры для ГОСТ-12-256"
    set listBits {1.2.643.2.2.35.1 1.2.643.2.2.35.2  1.2.643.2.2.35.3  1.2.643.2.2.36.0 1.2.643.2.2.36.1}
  }
  set listKey {gost2001 gost2012_256 gost2012_512}
  set dflt [subst $$typekey]

  ttk::combobox $c.c4 -width 16  -textvariable $parkey -values $listBits -style TCombobox
  $c.c3 delete 0 end
  set tekC [lsearch $listKey $dflt]
  $c.c3 insert end [lindex $listKey $tekC]

  set dflt [subst $$ckzi]
  label $c.l5 -text "Наименование СКЗИ:"
  ttk::entry $c.c5 -textvariable $ckzi
  #  -width 45
  # -textvariable $ckzi -bg white -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue
  $c.c5 delete 0 end
  $c.c5 insert end $dflt

  grid $c.l1 -row 0 -column 0 -columnspan 1 -sticky w -padx {4 4} -pady 2
  grid $c.c1 -row 0 -column 1 -columnspan 1 -sticky nwe -padx {0 4} -pady 2p
  grid columnconfigure $c 1 -weight 1
  if {$tpage == "cert"} {
    grid $c.lcrt -row 1 -column 0 -columnspan 1 -sticky wsen -padx {4 0} -pady {0 0}
    grid $c.fcrt -row 1 -column 1 -columnspan 2 -sticky wsen -padx {0 4} -pady {0 0}
  }
  #    grid $c.l3 -row 2 -column 0 -sticky w -padx 4 -pady 4
  #    grid $c.c3 -row 2 -column 1 -sticky w -padx 4 -pady 4
  grid $c.l3 -row 2 -column 0 -columnspan 1 -sticky w -padx {4 4} -pady 4
  grid $c.c3 -row 2 -column 1 -columnspan 1 -sticky wn -padx {0 4} -pady 4
  #    grid $c.l4 -row 3 -column 0 -sticky w -padx 4 -pady 4
  #    grid $c.c4 -row 3 -column 1 -sticky w -padx 4 -pady 4
  grid $c.l4 -row 3 -column 0 -columnspan 1 -sticky w -padx {4 4} -pady 4
  grid $c.c4 -row 3 -column 1 -columnspan 1 -sticky nw -padx {0 4} -pady 4

  grid $c.l5 -row 4 -column 0 -sticky w -padx 4 -pady 4
  grid $c.c5 -row 4 -column 1 -sticky wne -padx {0 4} -pady 4

  #    if {$tpage == "csr"} {
  #	checkbutton $c.c6 -text "Ключ неэкспортируемый"  -variable $expkey  -bg white -highlightthickness 0
  #	grid $c.c6 -row 5 -column 0 -sticky w -padx 4 -pady 4
  #    }

  #	checkbutton $c.c6 -text "Самоподписанный корневой сертификат"  -variable $selfca  -bg white -highlightthickness 0
  #	checkbutton $c.c7 -text "Самоподписанный DV SSL-сертификат"  -variable $selfssl  -bg white -highlightthickness 0
  #	grid $c.c6 -row 5 -column 0 -columnspan 2 -sticky w -padx 4 -pady 4
  #	grid $c.c7 -row 6 -column 0 -columnspan 2 -sticky w -padx 4 -pady 4

  #	label $c.l6 -text "Key Usage:" -font TkDefaultFontBold  -bg skyblue
  label $c.l6 -text "Использование ключа:" -font TkDefaultFontBold -anchor w
  # -bg skyblue
  grid $c.l6 -row 7 -column 0 -columnspan 2 -sticky w -padx 4 ;#-pady 4
  set i 8
  set j 0
  set ir 8
  set k 0
  foreach v $::ku_options {
    #puts "KU=::ku$k"
    ttk::checkbutton $c.c$i -text "$v" -variable ::ku$k
    #    	    -pady 0
    eval "grid $c.c$i -row $ir -column $j -columnspan 1 -sticky w -padx 8  -pady {0 [expr $j * 3]}"
    #    	    grid rowconfigure $c $i -weight 0
    incr i
    if {$j == 1} {
      incr ir
      set j 0
    } else {
      incr j
    }
    incr k
  }
  if {$tpage == "csr"} {
    incr ir
    checkbutton $c.egais -image egais_83x36 -text "Запрос на сертификат для ЕГАИС" -variable ::egais  -compound left  -bd 0 -bg skyblue
    #	 -background white -activebackground white -highlightthickness 0
    grid $c.egais -row $ir -column 0 -columnspan 3 -sticky w -padx 0 -pady 0
    grid remove $c.egais
    egais_ul $c.c1 "csr"
  }
  return
}

set typeCert  {"Физическое лицо" reqFL "Индивидуальный предприниматель" reqIP "Юридическое лицо" reqUL}
array set atrkval {ИНН 12 ИННЮЛ 10 ОГРН 13 ОГРНИП 15 СНИЛС 11 {ИНН *} 12 {ОГРН *} 13 {ОГРНИП *} 15 {СНИЛС *} 11 КПП 9}
array set sodCert {reqFL  "{C} {Страна} {ST} {Регион} {CN} {ФИО} {SN} {Фамилия} {givenName} {Имя, Отчество} {E} {Электронная почта}
{L} {Населенный пункт}
{street} {Улица, номер дома}
{INN} {ИНН}
{SNILS} {СНИЛС}"
reqUL  "{C} {Страна} {ST} {Регион} {CN} {Организация}
{O} {Наименование организации}
{E} {Электронная почта}
{L} {Населенный пункт}
{street} {Улица, номер дома}
{OU} {Подразделение организации}
{title} {Должность}
{SN} {Фамилия}
{givenName} {Имя, Отчество}
{OGRN} {ОГРН}
{INNLE} {ИННЮЛ}
{UN} {КПП}"
reqIP "{C} {Страна} {ST} {Регион} {CN} {ФИО}
{SN} {Фамилия}
{givenName} {Имя, Отчество}
{E} {Электронная почта}
{L} {Населенный пункт}
{street} {Улица, номер дома}
{INN} {ИНН}
{OGRNIP} {ОГРНИП}
{SNILS} {СНИЛС}"
reqAss  "{C} {Страна} {ST} {Регион} {O} {Организация}
{L} {Населенный пункт}
{street} {Улица, номер дома}
{U} {Подразделение организации}
{title} {Должность}
{INN} {ИНН}
{OGRN} {ОГРН}
{OGRNIP} {ОГРНИП}
{SNILS} {СНИЛС}"
}
#parray sodCert
set reqFL $sodCert(reqFL)

proc boxdns {c tekdns cb} {
  set dns [$c get];
  if {$cb == "email" && $dns != ""} {
    set mail [verifyemail $dns]
    if {$mail != "OK" } {
      tk_messageBox -title "Запрос на SSL-сертификат" -message "Ошибка в адресе электронной почты:" -detail "\t$dns" -icon error  -parent .
      return 0
    }
  }
  if {$cb == "ip" && $dns != ""} {
    set ver [::ip::version $dns]
    if {$ver == -1 } {
      tk_messageBox -title "Запрос на SSL-сертификат" -message "Ошибка в IP-адресе:" -detail "\t$dns" -icon error  -parent .
      return 0
    }
  }

  upvar $tekdns tek
  set Liste [lindex [$c configure -values] end]
  set len [llength $Liste]; incr len -1;puts "LEN=$len";
  if {$dns == ""} {
    set Liste [lreplace $Liste $tek $tek]
  } else {lset Liste $tek $dns};
  if {$tek == $len} { lappend Liste ""};
  $c configure -values $Liste
  set aa [subst "::Liste$cb"]
  set $aa $Liste
  set aa [subst $$aa]
}

proc cmdssl {c} {
  variable certfor
  puts "SSLCERT=$::sslcert"
  #    if {$::sslcert == 1} {}
  if {$certfor == 2} {
    $c.l1 configure -text "Domain \n(Common Name):"
    grid $c.altsub
    #	grid $c.ld
    #	grid $c.ed
  } else {
    grid remove $c.altsub
    #	grid remove $c.ld
    #	grid remove $c.ed
  }

}


proc create_csr_list2 {tpage c num} {
  variable certfor
  puts "LIST1=$c"
  $c configure -bg white
  #    global wizData
  global wizDatacsr
  global wizDatacert
  global reqFL
  global typeCert
  global sodCert
  if {$tpage == "csr"} {
    array set wizData [array get wizDatacsr]
  } else {
    array set wizData [array get wizDatacert]
  }

  #puts "ROLE=$wizData(role)"
  foreach {v req} $typeCert {
    if {$v == $wizData(type) } {
      array set profdate $sodCert($req)
      break
    }
  }
  #puts "$wizData(type)"
  #parray profdate
  set l1text "Common Name"
  if { $wizData(type) == "Юридическое лицо" } {
    set comname "Организация"
    set pretext "Введите полное имя будущего владельца сертификата.
    Для юридического лица это наименование компании из ЕГРЮЛ.
    Эта информация будет размещена в поле 'Common Name' и 'O' сертификата."
  } else {
    set comname "ФИО"
    set pretext "Введите полное имя будущего владельца сертификата.
    Для физического лица и индивидуального предпринимателя это ФИО как в паспорте.
    Эта информация будет размещена в поле 'Common Name' сертификата."
  }

  label $c.l1 -text "$comname \n($l1text):" -wraplength 120
  ttk::entry $c.e1
  # -width 57 -bg white -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue
  grid $c.l1 -row 0 -column 0 -sticky w -padx 4 -pady 4
  grid $c.e1 -row 0 -column 1  -sticky nwe -padx {0 5mm} -pady 4
  grid columnconfigure $c 1 -weight 1

  if {$tpage == "csr" } {
    set ::checkfull 1
    .st.fr1.fr2_list3.lab  configure  -text $pretext
    set varcn "wizDatacsr(CN)"
    ttk::checkbutton $c.checkfull -text "Контроль заполнения всех полей" -variable ::checkfull
    grid $c.checkfull -row 1 -column 0 -columnspan 2 -sticky nwe -padx {4 0} -pady 4
  } else {
    if {$certfor == 2} {
      set pretext "Укажите имя вашего основного домена. В окне
      \"Certificate Subject Alt Name\" можно указать имена поддоменов и IP-адресов."
    }
    .st.fr1.fr2_list9.lab  configure  -text $pretext
    set varcn "wizDatacert(CN)"

    labelframe $c.altsub -text "Certificate Subject Alt Name:" -bg skyblue
    #	ttk::labelframe $c.altsub -text "Certificate Subject Alt Name:"
    grid $c.altsub -row 3  -column 0  -columnspan 2 -sticky nwse -padx {4 0} -pady 4
    grid remove $c.altsub

    set i 0
    foreach cb {dns ip email} {
      label $c.altsub.$cb -text "[string toupper $cb]:"  -anchor w
      ttk::combobox $c.altsub.box$cb  -state normal -height 4 -width 30
      set aa [subst "::Liste$cb"]
      set aa [subst $$aa]
      set cmd [list $c.altsub.box$cb configure -values $aa]
      eval $cmd
      $c.altsub.box$cb delete 0 end
      set tt [subst "::tek$cb"]
      set tt [subst $$tt]
      $c.altsub.box$cb insert end [lindex $aa $tt]
      #readonly
      set aa [subst "::tek$cb"]
      set part "set $aa \[%W current\]"
      set cmd [list bind $c.altsub.box$cb <<ComboboxSelected>> $part]
      eval $cmd
                              	
      set gg [subst "bind $c.altsub.box$cb <Key-Return> {boxdns $c.altsub.box$cb ::tek$cb $cb}"]
      eval $gg
      switch $i {
        0 {
          grid $c.altsub.$cb -row $i -column 0 -sticky nwse -padx 4 -pady 4
          grid $c.altsub.box$cb -row $i -column 1  -sticky nwse -padx 0 -pady 4
        }
        1 {
          grid $c.altsub.$cb -row 0 -column 2 -sticky nwse -padx 4 -pady 4
          grid $c.altsub.box$cb -row 0 -column 3  -sticky nwse -padx 0 -pady 4
        }
        2 {
          grid $c.altsub.$cb -row 1 -column 0 -sticky nwse -padx 4 -pady 4
          grid $c.altsub.box$cb -row 1 -column 1 -columnspan 3  -sticky nwse -padx 0 -pady 4
        }

      }

      #	    grid $c.altsub.$cb -row $i -column 0 -sticky nwse -padx 4 -pady 4
      #	    grid $c.altsub.box$cb -row $i -column 1  -sticky nwse -padx 0 -pady 4
      incr i
    }
    ttk::checkbutton $c.altsub.tlssrv -text "TLS Web Server Autentication Certificate" -variable ::tlssrv
    ttk::checkbutton $c.altsub.tlscln -text "TLS Web Client Autentication Certificate" -variable ::tlscln
    grid $c.altsub.tlssrv -row 2 -column 0 -columnspan 4  -sticky nwse -padx {4 0} -pady 4
    grid $c.altsub.tlscln -row 3 -column 0 -columnspan 4  -sticky nwse -padx {4 0} -pady 4

    cmdssl $c
  }
  $c.e1 configure -textvariable $varcn
  focus $c.e1
}

proc create_csr_list3 {tpage c num} {
  puts "LIST1=$c"
  global wizDatacsr
  global wizDatacert
  global rfregions
  global reqFL
  global typeCert
  global sodCert
  global g_iso3166_codes
  set pretext "Заполните нижележащие поля.
  Эта информация будет помещена в сертификат.
  Поля обязательны для заполнения"
  if {$tpage == "csr"} {
    .st.fr1.fr2_list3.lab  configure  -text $pretext
    array set wizData [array get wizDatacsr]
  } else {
    .st.fr1.fr2_list9.lab  configure  -text $pretext
    array set wizData [array get wizDatacert]
  }
  #puts "WIZDATA"
  #puts "INN=$wizData(INN)"
  #parray wizData


  # all optional and required fields
  set i 1 ;# field counter for widgets
  foreach {v req} $typeCert {
    if {$v == $wizData(type) } {
      array set profdate $sodCert($req)
      break
    }
  }
  global profile_options
  array set opts [array get profile_options]
  foreach {v req} $typeCert {
    if {$v == $wizData(type) } {
      array set fieldlabels $sodCert($req)
      set reqFL1 $sodCert($req)
      if {$req == "reqUL"} {
        set wizData(O) $wizData(CN)
      }
      break
    }
  }
  set count [llength $reqFL1]
  set count [expr $count / 2 ]
  set cfirst [expr [expr $count / 2 ] + [expr $count % 2 ]]
  #    puts "CFIRST=$cfirst"
  #    puts "COUNT=$count [expr $count / 2 ] [expr $count % 2 ]"
  #puts "TYPE=$wizData(type)"
  global rfregions
  set oidO 0
  set oidCN -1
  set pp 1

  set wz [subst "wizData$tpage"]

  foreach {field dflt} $reqFL1 {
    if {$pp > $cfirst } {
      break
    }
    set dflt $wizData($field)
    #puts "creating field : $field / $dflt"
    # label
    if { $pp < 10} {
      set label " $pp. $fieldlabels($field)"
    } else {
      set label "$pp. $fieldlabels($field)"
    }
    set label1 "$fieldlabels($field)"
    incr pp

    if {$field == "O"} {
      incr oidO
    } elseif {$field == "CN"} {
      set oidCN $i
    }
    set wzf [subst "$wz\($field\)"]
    if {$field == "C"} {
      label $c.l$i -text "$label ($field)"
      set listISO {}
      foreach {country who} $g_iso3166_codes  {
        lappend listISO $country
      }
      #            ttk::combobox $c.e$i -textvariable [namespace current]::wizData($field) -width 50 -values $listISO -style TCombobox
      ttk::combobox $c.e$i -textvariable $wzf -width 80 -values $listISO -style TCombobox
      if {$wizData($field) == ""} {
        set wizData($field) $dflt
      }
      #puts "listISO=$wizData($field)"
      set tekC [lsearch $listISO {Российская Федерация}]
      $c.e$i delete 0 end
      $c.e$i insert 0 [lindex $listISO $tekC]

    } elseif {$field == "ST"} {
      label $c.l$i -text "$label ($field)"
      ttk::combobox $c.e$i -textvariable $wzf -width 55 -values $rfregions -style TCombobox
      if {$wizData($field) == ""} {
        set wizData($field) $dflt
      }
      set tekC [lsearch $rfregions {Московская область}]
      $c.e$i delete 0 end
      $c.e$i insert 0 [lindex $rfregions $tekC]

    } else  {
      global atrkval
      #Здесь добавить обработку ИНН и т.д.
      #puts "LABEL=\"$label\""
      label $c.l$i -text "$label ($field)" -wraplength 120
      #             -justify left
      if {[info exists atrkval($label1)]} {
        set len $atrkval($label1)
        #puts "LEN==$len"
        set com "ttk::entry $c.e$i -textvariable $wzf -validate key -validatecommand {Digit $c.e$i %i %P $len} "
        set com1 [subst $com]
        eval $com1
      } else {
        ttk::entry $c.e$i -textvariable $wzf
      }
      $c.e$i delete 0 end
      $c.e$i insert end $dflt
    }
    grid $c.l$i -row $i -column 0 -sticky w -padx 4 -pady 4
    grid $c.e$i -row $i -column 1 -sticky we -padx {0 5mm} -pady 4
    #        grid rowconfigure $c $i -weight 0
    incr i
  }
  grid columnconfigure $c 1 -weight 1

  if {$oidO == 1 && $oidCN > -1} {
    $c.l$oidCN configure -text " 3. Организация"
  }
  if {$oidCN > -1} {
    #    $c.e$oidCN configure -state disabled
  }
  focus $c.e4
}

proc create_csr_list4 {tpage c num} {
  global rfregions
  global reqFL
  global typeCert
  global sodCert
  global g_iso3166_codes
  global wizDatacsr
  global wizDatacert
  set pretext "Заполните оставшиеся поля.
  Эта информация будет помещена в сертификат."
  if {$tpage == "csr"} {
    array set wizData [array get wizDatacsr]
    .st.fr1.fr2_list3.lab  configure  -text $pretext
  } else {
    array set wizData [array get wizDatacert]
    .st.fr1.fr2_list9.lab  configure  -text $pretext
  }
  set wz [subst "wizData$tpage"]
  #puts "WIZDATA"
  #puts "INN=$wizData(INN)"
  #parray wizData

  # all optional and required fields
  set i 1 ;# field counter for widgets
  foreach {v req} $typeCert {
    if {$v == $wizData(type) } {
      array set profdate $sodCert($req)
      break
    }
  }
  global profile_options
  array set opts [array get profile_options]
  foreach {v req} $typeCert {
    if {$v == $wizData(type) } {
      array set fieldlabels $sodCert($req)
      set reqFL1 $sodCert($req)
      if {$req == "reqUL"} {
        set wizData(O) $wizData(CN)
      }
      break
    }
  }
  set count [llength $reqFL1]
  set count [expr $count / 2 ]
  set cfirst [expr [expr $count / 2 ] + [expr $count % 2 ]]
  #    puts "CFIRST=$cfirst"
  #    puts "COUNT=$count [expr $count / 2 ] [expr $count % 2 ]"
  #    array set fieldlabels $reqFL
  #puts "TYPE=$wizData(type)"
  global rfregions
  set oidO 0
  set oidCN -1
  set pp 1
  foreach {field dflt} $reqFL1 {
    if {$pp <= $cfirst } {
      incr pp
      continue
    }
    set dflt $wizData($field)
    #puts "creating field : $field / $dflt"
    # label
    if { $pp < 10} {
      set label " $pp. $fieldlabels($field)"
    } else {
      set label "$pp. $fieldlabels($field)"
    }
    set label1 "$fieldlabels($field)"
    incr pp

    # if required
    if {$field == "O"} {
      incr oidO
    } elseif {$field == "CN"} {
      set oidCN $i
    }
    set wzf [subst "$wz\($field\)"]

    if {$field == "C"} {
      label $c.l$i -text "$label ($field)"
      set listISO {}
      foreach {country who} $g_iso3166_codes  {
        lappend listISO $country
      }
      ttk::combobox $c.e$i -textvariable $wzf -width 40 -values $listISO -style TCombobox
      if {$wizData($field) == ""} {
        set wizData($field) $dflt
      }
      #puts "listISO=$wizData($field)"
      set tekC [lsearch $listISO {Российская Федерация}]
      $c.e$i delete 0 end
      $c.e$i insert 0 [lindex $listISO $tekC]

    } elseif {$field == "ST"} {
      label $c.l$i -text "$label ($field)"
      ttk::combobox $c.e$i -textvariable $wzf -width 40 -values $rfregions -style TCombobox
      if {$wizData($field) == ""} {
        set wizData($field) $dflt
      }
      set tekC [lsearch $rfregions {Московская область}]
      $c.e$i delete 0 end
      $c.e$i insert 0 [lindex $rfregions $tekC]

    } else  {
      global atrkval
      #Здесь добавить обработку ИНН и т.д.
      #puts "LABEL=\"$label\""
      label $c.l$i -text "$label ($field)" -anchor w -wraplength 120
      if {[info exists atrkval($label1)]} {
        set len $atrkval($label1)
        #puts "LEN==$len"
        set com "ttk::entry $c.e$i -textvariable $wzf -validate key -validatecommand {Digit $c.e$i %i %P $len} "
        set com1 [subst $com]
        eval $com1
      } else {
        ttk::entry $c.e$i -textvariable $wzf
      }
      $c.e$i delete 0 end
      $c.e$i insert end $dflt
    }
    grid $c.l$i -row $i -column 0 -sticky w -padx 4 -pady 4
    grid $c.e$i -row $i -column 1 -sticky we -padx {4 5mm} -pady 4
    #        grid rowconfigure $c $i -weight 0
    incr i
  }
  if {$oidO == 1 && $oidCN > -1} {
    $c.l$oidCN configure -text " 3. Организация (CN)"
  }

  if {$wizData(type) == "Юридическое лицо" && $::egais == 1 } {
    #OID 1.2.643.3.6.78.4.4
    #	set lisenze "Лицензиат Росалкогольрегулирования или органов исполнительной власти  субъектов  РФ по розничной продаже алкогольной продукции"
    set lisenze "Лицензиат системы декларирования ФСРАР-лицензиат"
    checkbutton $c.lalko -text $lisenze -wraplength 535 -justify left -variable ::lisalko  -bd 0 -bg wheat3 -activebackground skyblue -padx 0
    grid $c.lalko -row $i -column 0  -columnspan 2 -sticky w -padx 4 -pady 4
  }
  grid columnconfigure $c 1 -weight 1

  focus $c.e1
}

proc ::deleteObject {} {
  global yespas
  global pass
  puts "HANDLE=$::handleObj"

  #  set aa [dict create pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]
  #  lappend aa "hobj"
  #  lappend aa $::handleObj

  #  set err [::pki::pkcs11::delete obj $aa]
  $::tokenls11sw0 login
#tk_messageBox -title "deleteObject" -icon info -message "hobj: $::handleObj\n"
  set err [$::tokenls11sw0 deleteobj $::handleObj]
  #    catch {::pki::pkcs11::logout $::handle $::slotid_tek}
  $::tokenls11sw0 logout
  ::updateobj
}

proc ::updateobj {} {
  global yespas
  global pass
  variable ::handleObj
  variable ::listObjs
  if {[array size ::tokenlist] == "0"} {
    tk_messageBox -title "Библиотека PKCS#11" -icon info -message "Нет подключенных токенов (0)\n"
    return ""
  }
  set c .st.fr1.fr2_list7
  $c.fratext.text delete 1.0 end
catch {$::tokenls11sw0 logout }
$::tokenls11sw0 login
  if {[catch {set allobjs [$::tokenls11sw0 listobjects "all"]} ret]} {
    if {$ret == ""} {
      tk_messageBox -title "Объекты токена" -icon info -message "Нет токена. Вставьте токен и\nобновите список токенов" -parent .
      return ""
    }
    tk_messageBox -title "Объекты токена" -icon info -message "Нет токена. Вставьте токен и\nобновите библиотеку" -detail $ret -parent .
    return ""
  }
  set ::listObjs {}
  $c.lobj configure -values $::listObjs
  set ::handleObj [lindex $::listObjs 0]

  foreach obj $allobjs {
    lappend ::listObjs [lindex $obj 1]
    foreach {type handle label id} $obj {
      $c.fratext.text insert end $type
      $c.fratext.text insert end "\n\t"
      $c.fratext.text insert end $handle
      $c.fratext.text insert end "\n\t"
      $c.fratext.text insert end $label
      $c.fratext.text insert end "\n\t"
      $c.fratext.text insert end $id
      $c.fratext.text insert end "\n"
    }
    #	puts "$obj"
  }
  #puts "::listObjs=$::listObjs"
  #puts "ALLOBJS=[lindex $allobjs 0]"
  $c.lobj configure -values $::listObjs
  set ::handleObj [lindex $::listObjs 0]
  return $allobjs
}

proc ::deleteallobj {} {
  global yespas
  global pass
  variable ::handleObj
  variable ::listObjs
  set allobjs [$::tokenls11sw0 listobjects "all"]
  foreach obj $allobjs {
    set err [$::tokenls11sw0 deleteobj [lindex $obj 1]]
  }
  ::updatetok
  return 1
}


proc page_objects  {c} {
  variable ::handleObj
  variable ::listObjs
  set ::handleObj ""
  set ::listObjs {}
  frame $c.fratext -borderwidth 0 -relief flat
  text $c.fratext.text  -yscrollcommand [list $c.fratext.scr set] -height 0 \
  -insertbackground black -bg #f5f5f5 -highlightcolor skyblue
  ttk::scrollbar $c.fratext.scr  -command [list $c.fratext.text yview]
  pack $c.fratext.scr \
  -in $c.fratext -anchor center -expand 0 -fill y -side right
  pack $c.fratext.text \
  -in $c.fratext -anchor center -expand 1 -fill both -side top -padx 0 -pady {0 0}
  label $c.lab -text "Handle объекта"  -font TkDefaultFontBold
  ttk::combobox $c.lobj -textvariable ::handleObj -values $::listObjs -takefocus {}   -style TCombobox
  #    -state readonly

  ttk::button $c.butdel -text "Удалить объект"  -command ::deleteObject -style My.TButton -padding 1
  button $c.butupd -command {::updateobj} -image ::img::update_18x16 -compound left -bd 0 -background white -activebackground white -highlightthickness 0

  pack $c.fratext -in $c -anchor center -expand 1 -fill both -side top
  pack $c.lab -in $c -anchor center -expand 0 -fill none -side left
  pack $c.lobj -in $c -anchor center -expand 1 -fill x -side left -ipadx 3 -ipady 2 -padx 5
  pack $c.butdel -in $c -anchor center -expand 0 -fill none -side left -ipady 0 -pady 0
  pack $c.butupd -in $c -anchor center -expand 0 -fill none -padx {5 10} -side right
}

proc contentabout {w} {
  # Set up display styles.
  if {[winfo depth $w] > 1} {
    set bold "-background #43ce80 -relief raised -borderwidth 1"
    #	    set normal "-background {} -relief flat"
    set normal "-background {} -foreground red -relief flat -underline on"
  } else {
    set bold "-foreground white -background black"
    set normal "-foreground {} -background {}"
  }

  $w.text configure -background white
  $w.text tag configure tagAbout -foreground blue -font {Times 10 bold italic}
  $w.text image create end -image creator_small
  $w.text insert end "\t\tКриптографический АРМ cryptoarmpkcs\n\n" tagAbout

  #	$w.text insert end $content
  $w.text insert end "       Криптографическая утилита cryptopkcs на базе стандартов с открытым ключом \
  предназначена для работы с криптографическими токенами PKCS#11, защищенными контейнерами PKCS#12, \
  а также для создания запроса на на квалифицированный сертификат, подписания документов \
  в формате PKCS7, CAdes-BES, CAdes-T и CAdes-XLT1 и самоподписанных сертификатов, \
  написана Орловым В.Н."
  $w.text insert end \n
  $w.text insert end \
  {       В качестве СКЗИ используются токены/смарткарты }
  $w.text insert end {PKCS#11} d1
  $w.text insert end ".\n"
  $w.text insert end \
  {       При работе с защищенным контейнером }
  $w.text insert end {PKCS#12} d2
  $w.text insert end \
  { используется }
  $w.text insert end {СКЗИ "ЛИРССЛ-CSP"} d3
  $w.text insert end ".\n"
  $w.text insert end \
  {        Утилита cryptoarmpkcs функционирует на ОС Linux, MS Windows, MacOS, Android и др.} tagLoad1
  $w.text insert end \n
  $w.text insert end \
  {        Загрузить дистрибуты для платформ Linux, MS Windows, OS X, Android можно }
  $w.text tag configure tagLoad -foreground blue -font {Times 12 bold italic}
  $w.text tag configure tagLoad1 -foreground blue -font {Times 10 bold italic}
  foreach tag {d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 } {
    $w.text tag configure $tag  -foreground red
  }
  #     -font {Times 10 bold italic}
  $w.text insert end {здесь:}  tagLoad
  $w.text insert end "\n\t - "
  $w.text insert end {Linux32} d4
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {Linux64} d5
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {OS X} d6
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {WIN32} d7
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {WIN64} d8
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {AndroWishApp-debug.apk} d15
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {Source} d9
  $w.text insert end \n
  $w.text insert end \
  {        При создании дистрибутивов были использованы пакеты }
  $w.text insert end {TclPKCS11} d10
  $w.text insert end \
  {, а такжe утилиты }
  $w.text insert end {freewrap} d11
  $w.text insert end {, }
  $w.text insert end {tclexecomp} d12
  $w.text insert end { и }
  $w.text insert end {tclderdump} d13
  $w.text insert end ".\n"
  $w.text insert end \
  {        При создании дистрибутива под Android использовался }
  $w.text insert end {AndroWish} d14
  $w.text insert end ".\n"
  $w.text insert end \
  {        Утилита cryptoarmpkcs разрабатывалась с учетом требований ФЗ-63 и регуляторов.}
  $w.text insert end \n
  $w.text insert end \
  {        Автор выражает благодарность Блажнову В.Ю. за разработку пакетов Lrnd, Lcc и GostPfx.}  tagLoad1
  $w.text insert end \n
  $w.text insert end \
  {        Это программное обеспечение доступно в терминах GNU General Public License.}
  $w.text insert end \n
  $w.text insert end \
  {        email: vorlov@lissi.ru} tagLoad1
  $w.text insert end \n

  # Create bindings for tags.
  # d3 d4 d5 d6
  array set url []
  set url(d1) "http://soft.lissi.ru/ls_product/skzi/PKCS11"
  set url(d2) "http://soft.lissi.ru/ls_product/utils/p12fromcsp"
  set url(d3) "http://soft.lissi.ru/ls_product/skzi/skzi_lirssl_csp"
  set url(d4) "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_linux32.tar.bz2"
  set url(d5) "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_linux64.tar.bz2"
  set url(d6) "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_mac.tar.bz2"
  set url(d7) "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_setup_win32.exe"
  set url(d8) "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_setup_win64.exe"
  set url(d9) "https://github.com/a513/CryptoArmPKCS/raw/master/source/cryptoarmpkcs_source.tar.bz2"

  set url(d10) "https://github.com/a513/TclPKCS11"
  set url(d11) "http://freewrap.sourceforge.net"
  set url(d12) "http://tclexecomp.sourceforge.net"
  set url(d13) "https://github.com/a513/TclDerDUMP"
  set url(d14) "https://www.androwish.org"
  set url(d15) "https://raw.githubusercontent.com/a513/CryptoArmPKCS/master/distr/AndroWishApp-debug.apk"

  foreach tag {d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15} {
    #	    $w.text tag bind $tag <Any-Enter> ".about.butt.lab configure -text {$url($tag)} ;$w.text tag configure $tag $bold"
    #	    $w.text tag bind $tag <Any-Leave> ".about.butt.lab configure -text {}; $w.text tag configure $tag $normal"
    $w.text tag bind $tag <Any-Enter> "set ::entryd {$url($tag)};$w.text tag configure $tag $bold"
    #	    $w.text tag bind $tag <Any-Leave> "set ::entryd {}; $w.text tag configure $tag $normal"
    $w.text tag bind $tag <Any-Leave> "$w.text tag configure $tag $normal"
}
  # Main widget program sets variable tk_demoDirectory
  $w.text tag bind d1 <1> {openURL "http://soft.lissi.ru/ls_product/skzi/PKCS11"}
  $w.text tag bind d2 <1> {openURL "http://soft.lissi.ru/ls_product/utils/p12fromcsp"}
  $w.text tag bind d3 <1> {openURL "http://soft.lissi.ru/ls_product/skzi/skzi_lirssl_csp"}
  if {[string range $w 0 5] == ".about"} {
    $w.text tag bind d4 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_linux32.tar.bz2" ".about"}
    $w.text tag bind d5 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_linux64.tar.bz2" ".about"}
    $w.text tag bind d6 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_mac.tar.bz2" ".about"}
    $w.text tag bind d7 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_setup_win32.exe" ".about"}
    $w.text tag bind d8 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_setup_win64.exe" ".about"}
    $w.text tag bind d9 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/source/cryptoarmpkcs_source.tar.bz2" ".about"}
    $w.text tag bind d15 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/AndroWishApp-debug.apk" ".about"}
  } else {
    $w.text tag bind d4 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_linux32.tar.bz2" "."}
    $w.text tag bind d5 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_linux64.tar.bz2" "."}
    $w.text tag bind d6 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_mac.tar.bz2" "."}
    $w.text tag bind d7 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_setup_win32.exe" "."}
    $w.text tag bind d8 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/cryptoarmpkcs_setup_win64.exe" "."}
    $w.text tag bind d9 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/source/cryptoarmpkcs_source.tar.bz2" "."}
    $w.text tag bind d15 <1> {readdistr "https://github.com/a513/CryptoArmPKCS/raw/master/distr/AndroWishApp-debug.apk" "."}
  }
  $w.text tag bind d10 <1> {openURL "https://github.com/a513/TclPKCS11"}
  $w.text tag bind d11 <1> {openURL "http://freewrap.sourceforge.net"}
  $w.text tag bind d12 <1> {openURL "http://tclexecomp.sourceforge.net"}
  $w.text tag bind d13 <1> {openURL "https://github.com/a513/TclDerDUMP"}
  $w.text tag bind d14 <1> {openURL "https://www.androwish.org"}
}

proc contentcreatetok {w} {
  # Set up display styles.
  if {[winfo depth $w] > 1} {
    set bold "-background #43ce80 -relief raised -borderwidth 1"
    #	    set normal "-background {} -relief flat"
    set normal "-background {} -foreground red -relief flat -underline on"
  } else {
    set bold "-foreground white -background black"
    set normal "-foreground {} -background {}"
  }

  $w.text configure -background white
  $w.text tag configure tagAbout -foreground blue -font {Times 10 bold italic}
  $w.text image create end -image creator_small
  $w.text insert end "\t\tКриптографический АРМ cryptoarmpkcs\n\n" tagAbout

  #	$w.text insert end $content
  $w.text insert end "       Если у вас нет аппаратного токена, не огорчайтесь. \
  Вы можете создать на своем компьютере программный токен LS11SW2016, либо создать облачный токен.\
  Более того на платформе Android программный токен создается при первом запуске приложения. \
  Это позволит вам не только обучиться, но и, при желании,  организовать Инфраструктуру Открытых Ключей \
  (ИОК/PKI) в вашей организации или с коллегами"
  $w.text insert end \n\n
  $w.text insert end {   1. }
  $w.text image create end -image sw_token
  $w.text insert end \
  "   Создание программного токена "
  $w.text insert end {LS11SW2016} d1
  $w.text insert end ".\n\n"
  $w.text insert end \
  {        Утилита guicreate_sw_token функционирует на ОС Linux, MS Windows, MacOS и др.} tagLoad1
  $w.text insert end \n
  $w.text insert end \
  {        Загрузить дистрибутивыы для платформ Linux, MS Windows, OS X можно }
  $w.text tag configure tagLoad -foreground blue -font {Times 12 bold italic}
  $w.text tag configure tagLoad1 -foreground blue -font {Times 10 bold italic}
  foreach tag {d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13} {
    $w.text tag configure $tag  -foreground red
  }
  #     -font {Times 10 bold italic}
  $w.text insert end {здесь:}  tagLoad
  $w.text insert end "\n\t - "
  $w.text insert end {Linux32} d2
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {Linux64} d3
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {OS X} d4
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {WIN32} d5
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {WIN64} d6
  $w.text insert end \n
  $w.text insert end "\tПри необходимости распакуйте дистрибутив и запустите его. В дальнейшем следуйте его подсказкам. \
  Вы можете также воспользоваться "
  $w.text insert end {инструкцией} d7
  $w.text insert end ".\n"
  $w.text insert end "\tP.S. На платформе Android программный токен создается автоматически при первом запуске приложения" tagLoad1
  $w.text insert end ".\n\n"

  ##################### CLOUD TOKEN ################
  $w.text insert end {   2. }
  $w.text image create end -image cloud_token
  $w.text insert end \
  "   Создание облачного токена "
  $w.text insert end {LS11CLOUD} d8
  $w.text insert end ".\n\n"
  $w.text insert end \
  {        Утилита guils11cloud_conf функционирует на ОС Linux, MS Windows, MacOS, Android и др.} tagLoad1
  $w.text insert end \n
  $w.text insert end \
  {        Загрузить дистрибутивыы для платформ Linux, MS Windows, OS X, Android можно }
  $w.text tag configure tagLoad -foreground blue -font {Times 12 bold italic}
  $w.text tag configure tagLoad1 -foreground blue -font {Times 10 bold italic}
  foreach tag {d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14} {
    $w.text tag configure $tag  -foreground red
  }
  #     -font {Times 10 bold italic}
  $w.text insert end {здесь:}  tagLoad
  $w.text insert end "\n\t - "
  $w.text insert end {Linux32} d9
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {Linux64} d10
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {OS X} d11
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {WIN32} d12
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {WIN64} d13
  $w.text insert end \n
  $w.text insert end "\t - "
  $w.text insert end {AndroWishApp-debug.apk} d14
  $w.text insert end \n
  $w.text insert end "\tПри необходимости распакуйте дистрибутив и запустите его. В дальнейшем следуйте его подсказкам. \
  Вы можете также воспользоваться "
  $w.text insert end {инструкцией} d8
  $w.text insert end ".\n\n"


  # Create bindings for tags.
  # d3 d4 d5 d6
  array set url []
  set url(d1) "http://soft.lissi.ru/ls_product/skzi/PKCS11"
  set url(d2) "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_linux32.tar.bz2"
  set url(d3) "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_linux64.tar.bz2"
  set url(d4) "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_mac.tar.bz2"
  set url(d5) "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_win32.exe"
  set url(d6) "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_win64.exe"
  set url(d7) "http://soft.lissi.ru/ls_product/skzi/LS11SW2016/"
  set url(d8) "http://soft.lissi.ru/solution/ls11cloud"
  set url(d9) "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_linux32.tar.bz2"
  set url(d10) "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_linux64.tar.bz2"
  set url(d11) "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_mac.tar.bz2"
  set url(d12) "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_win32.exe"
  set url(d13) "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_win64.exe"
  set url(d14) "https://github.com/a513/guils11cloud_config/raw/master/distr/AndroWishApp-debug.apk"

  foreach tag {d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14} {
    #	    $w.text tag bind $tag <Any-Enter> ".about.butt.lab configure -text {$url($tag)} ;$w.text tag configure $tag $bold"
    #	    $w.text tag bind $tag <Any-Leave> ".about.butt.lab configure -text {}; $w.text tag configure $tag $normal"
    $w.text tag bind $tag <Any-Enter> "set ::entryd {$url($tag)};$w.text tag configure $tag $bold"
    #	    $w.text tag bind $tag <Any-Leave> "set ::entryd {}; $w.text tag configure $tag $normal"
    $w.text tag bind $tag <Any-Leave> "$w.text tag configure $tag $normal"
}

  $w.text tag bind d1 <1> {openURL "http://soft.lissi.ru/ls_product/skzi/PKCS11"}
  $w.text tag bind d2 <1> {readdistr "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_linux32.tar.bz2" "."}
  $w.text tag bind d3 <1> {readdistr "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_linux64.tar.bz2" "."}
  $w.text tag bind d4 <1> {readdistr "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_mac.tar.bz2" "."}
  $w.text tag bind d5 <1> {readdistr "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_win32.exe" "."}
  $w.text tag bind d6 <1> {readdistr "https://github.com/a513/GuiCreateLS11SW2016Token/raw/master/distr/guicreate_sw_token_win64.exe" "."}
  $w.text tag bind d7 <1> {openURL "http://soft.lissi.ru/ls_product/skzi/LS11SW2016"}
  $w.text tag bind d8 <1> {openURL "http://soft.lissi.ru/solution/ls11cloud"}
  $w.text tag bind d9 <1> {readdistr "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_linux32.tar.bz2" "."}
  $w.text tag bind d10 <1> {readdistr "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_linux64.tar.bz2" "."}
  $w.text tag bind d11 <1> {readdistr "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_mac.tar.bz2" "."}
  $w.text tag bind d12 <1> {readdistr "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_win32.exe" "."}
  $w.text tag bind d13 <1> {readdistr "https://github.com/a513/guils11cloud_config/raw/master/distr/guils11cloud_conf_win64.exe" "."}
  $w.text tag bind d14 <1> {readdistr "https://github.com/a513/guils11cloud_config/raw/master/distr/AndroWishApp-debug.apk" "."}
}

proc page_about  {w} {
  frame $w.fratext -borderwidth 0 -relief flat
  text $w.fratext.text -yscrollcommand [list $w.fratext.scr set]  \
  -height 0 -insertbackground black -bg #f5f5f5 -highlightcolor skyblue -wrap word
  ttk::scrollbar $w.fratext.scr  -command [list $w.fratext.text yview]
  pack $w.fratext.scr -anchor center -expand 0 -fill y -side right
  pack $w.fratext.text -anchor center -expand 1 -fill both -side top -padx 0 -pady {0 0}
  contentabout $w.fratext
  pack $w.fratext -in $w -anchor center -expand 1 -fill both -side top
  set ::entryd ""
  frame $w.butt -bg #f5f5f5 -highlightthickness 2 -highlightbackground skyblue -highlightcolor skyblue
  pack $w.butt -expand 0 -fill x -side bottom
  entry $w.butt.lab -textvariable ::entryd -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue
  pack $w.butt.lab -side top  -pady {0 0} -fill x -expand 1  -padx {0 5}
}

proc page_createtok  {w} {
  frame $w.fratext -borderwidth 0 -relief flat
  text $w.fratext.text -yscrollcommand [list $w.fratext.scr set]  \
  -height 0 -insertbackground black -bg #f5f5f5 -highlightcolor skyblue -wrap word
  ttk::scrollbar $w.fratext.scr  -command [list $w.fratext.text yview]
  pack $w.fratext.scr -anchor center -expand 0 -fill y -side right
  pack $w.fratext.text -anchor center -expand 1 -fill both -side top -padx 0 -pady {0 0}
  contentcreatetok $w.fratext
  pack $w.fratext -in $w -anchor center -expand 1 -fill both -side top
  set ::entryd ""
  frame $w.butt -bg #f5f5f5 -highlightthickness 2 -highlightbackground skyblue -highlightcolor skyblue
  pack $w.butt -expand 0 -fill x -side bottom
  entry $w.butt.lab -textvariable ::entryd -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue
  pack $w.butt.lab -side top  -pady {0 0} -fill x -expand 1  -padx {0 5}
}

proc page_csr_view {c} {
  global env
  global reqFL
  global typeCert
  global sodCert
  variable csr_fn
  set csr_fn ""
  variable cert_fn
  set cert_fn ""
  variable opcert
  set opcert 0
  variable dir_crt
  set dir_crt ""
  global macos
  global typesys

  set filetyperequest {
    {{Запрос на сертификат (DER)} {.p10}}
    {{Запрос на сертификат (PEM)} {.csr}}
    {{Запрос на сертификат (DER)} {.der}}
    {{Запрос на сертификат (PEM)} {.pem}}
    {{Любой тип} *}
  }
  set filetypecert {
    {{Сертификат в DER формате}    .der}
    {{Сертификат в DER формате}    .cer}
    {{Сертификат в PEM формате}    .pem}
    {{Сертификат в PEM формате}    .crt}
    {{Любой тип}    *}
  }
  ############
  frame $c.fscr -relief flat -pady 2 -padx 0

  label $c.fscr.l1 -text "Файл с запросом:" -font TkDefaultFontBold
  pack $c.fscr.l1  -padx 0 -side left  -pady 0 -expand 0 -fill both
  if {$typesys == "win32"} {
    set ww 58
  } elseif {$macos } {
    set ww 63
  } else {
    set ww 55
  }
  if {$macos} {
    set ft ""
  } else {
    set ft $filetyperequest
  }

  cagui::FileEntry $c.fscr.e1 -dialogtype open \
  -title "Выберите файл с запросом" \
  -width $ww \
  -defaultextension "*.csr *.p10 " \
  -variable  csr_fn \
  -initialdir $env(HOME) \
  -filetypes $ft
  pack $c.fscr.e1 -side left -expand 1 -fill both
  button  $c.fscr.viewscr -command {variable csr_fn;::viewCSR  $csr_fn 1} -image ::img::view_18x16 -compound right -bd 0 -background white -activebackground white -highlightthickness 0
  set lc "bind $c.fscr.viewscr <Enter> {.helpview configure -text \"Просмотр запроса\";place .helpview -in $c.fscr.e1 -relx 0.77 -rely 1.0}"
  set lc [subst $lc]
  eval $lc
  bind $c.fscr.viewscr <Leave> {place forget .helpview}
  pack $c.fscr.viewscr -side right -padx {1 3} -pady 0 -expand 0 -fill none
  grid $c.fscr -row 0 -column 0 -columnspan 2 -sticky wsen -padx {0 0} -pady {0 0}
  grid columnconfigure $c 1 -weight 1
  ttk::labelframe $c.build -text "Выпуск сертификата" -labelanchor n
  #########
  set c_old $c
  set c [subst $c.build]
  label $c.l1 -text "Папка для сертификатов:"
  if {$typesys == "win32"} {
    set ww 52
  } elseif {$macos } {
    set ww 62
  } else {
    set ww 49
  }
  #  -width $ww
  cagui::FileEntry $c.e1 -dialogtype directory \
  -variable dir_crt \
  -title "Каталог для сертификатов" \
  -initialdir $env(HOME)
  frame $c.ftype -relief flat -bg white  -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue -padx 0 -pady 0
  label $c.l0 -text "Выберите формат файла:" -bg white -anchor w
  ttk::radiobutton $c.ftype.typeDer -text "DER-формат" -value 0 -variable ::formatCSR
  pack $c.ftype.typeDer -expand 1 -fill x  -side left -padx {10 0} -pady 0
  ttk::radiobutton $c.ftype.typePem -text "PEM-формат" -value 1 -variable ::formatCSR
  ttk::button  $c.ftype.build -command {variable csr_fn;::viewCSR  $csr_fn 7} -text "Выпуск" -style My.TButton -pad 0
  pack $c.ftype.build -expand 1 -fill x -side right -padx {0 4} -pady 0
  pack $c.ftype.typePem -expand 1 -fill x -side right -padx {0 10} -pady 0

  label $c.lbc -text "Точка раздачи CA:"  -bg white -anchor w
  ttk::entry $c.bc  -textvariable ::pointca
  set lc "bind $c.lbc <Enter> {.helpview configure -text \"Точка выдачи сертификата УЦ\";place .helpview -in $c.lbc -relx 1.0 -rely 0.5}"
  set lc [subst $lc]
  eval $lc
  bind $c.lbc <Leave> {place forget .helpview}
  grid $c.l1 -row 1 -column 0 -sticky w -padx {4 0} -pady {0 1}
  grid $c.e1 -row 1 -column 1 -sticky nswe -padx 0 -pady {0 1}
  grid columnconfigure $c 1 -weight 1

  $c.bc delete 0 end
  grid $c.lbc -row 2 -column 0  -sticky nwse -padx {4 0} -pady 0
  grid $c.bc -row 2 -column 1 -sticky nwse -padx {0 4} -pady 0
  label $c.lyear -text "Определите срок действия сертификата (в годах и днях):"  -bg skyblue
  grid $c.lyear -row 4 -column 0 -columnspan 2 -sticky w -padx 4 -pady 0
  #	spinbox $c.years -from 0 -to 25 -state readonly -textvariable ::yearcert -justify right
  #	grid $c.years -row 5 -column 0 -columnspan 1 -sticky w -padx {4 0} -pady 2
  #	scale $c.days -from 0 -to 366 -tickinterval 30 -orient horizontal -variable ::dayscert -showvalue true
  #	grid $c.days -row 5 -column 1 -columnspan 1 -sticky wnes -padx 0 -pady 2
  spinbox $c.years -from 0 -to 25 -state readonly -textvariable ::yearcert -justify right -width 5
  grid $c.years -row 5 -column 0 -columnspan 2 -sticky w -padx {4 0} -pady {0 0}
  scale $c.days -from 0 -to 366 -tickinterval 30 -orient horizontal -variable ::dayscert -showvalue true -length 530 -width 8  -font {Times 8 bold roman} -bg snow
  grid $c.days -row 5 -column 0 -columnspan 2 -sticky e -padx {0 4} -pady {0 0}

  label $c.kind -text "Идентификация владельца сертификата:" -anchor w  -width 0 -height 0
# -bg skyblue
  ttk::combobox $c.listKind  -textvariable ::tekIdKind -values $::listkind  -style TCombobox -background skyblue
  set ::tekIdKind [lindex $::listkind 4]
  grid $c.kind -row 7 -column 0 -sticky wn -padx {4 4} -pady {4 1}
  grid $c.listKind -row 7 -column 1 -sticky nwse -padx {4 2} -pady {0 1} -ipady 2

  grid $c.l0 -row 8 -column 0 -sticky w -padx {4 0} -pady {0 2}
  grid $c.ftype -row 8 -column 1 -sticky nswe -padx {4 4} -pady {0 2}
  grid $c -row 1 -column 0 -columnspan 3 -sticky wsen -padx {5 3} -pady {0 0}

  set c $c_old
  ########
  label $c.lsep -text "Работа с сертификатами из файлов" -font TkDefaultFontBold -bg #eff0f1 -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue

  frame $c.fcrt -relief flat -pady 2 -padx 0
  label $c.fcrt.l2 -text "Файл сертификата:" -font TkDefaultFontBold
  pack $c.fcrt.l2  -padx 0 -side left  -pady 0 -expand 0 -fill both
  if {$macos} {
    set ft ""
  } else {
    set ft $filetypecert
  }

  cagui::FileEntry $c.fcrt.e2 -dialogtype open \
  -title "Выберите файл с сертификатом" \
  -width 54 \
  -defaultextension "*.cer *.crt *.der *.pem " \
  -variable  cert_fn \
  -initialdir $env(HOME) \
  -filetypes $ft
  pack $c.fcrt.e2 -side left -expand 1 -fill both
  button  $c.fcrt.viewcrt -command {variable opcert; set z $opcert;set opcert 2;::workOpCert;set opcert $z} -image ::img::view_18x16 -compound right -bd 0 -background white -activebackground white -highlightthickness 0
  set lc "bind $c.fcrt.viewcrt <Enter> {.helpview configure -text \"Просмотр сертификата\";place .helpview -in $c.fcrt.e2 -relx 0.70 -rely 1.0}"
  set lc [subst $lc]
  eval $lc
  bind $c.fcrt.viewcrt <Leave> {place forget .helpview}
  pack $c.fcrt.viewcrt -side right -padx {2 0} -pady 0 -expand 0 -fill none
  ########

  ttk::labelframe $c.lfr1 -text "Выберите операцию с сертификатом"  -labelanchor n
  ttk::radiobutton $c.lfr1.rb1 -value 0 -variable opcert -text "Цепочка/Проверка подписи"
  ttk::radiobutton $c.lfr1.rb2 -value 1 -variable opcert -text "Проверка валидности"
  #    radiobutton $c.lfr1.rb3 -value 2 -variable opcert -text "Просмотр сертификата" -highlightthickness 0
  ttk::radiobutton $c.lfr1.rb4 -value 3 -variable opcert -text "Импорт сертификата на токен"
  ttk::checkbutton $c.lfr1.chb4 -variable ::certegais -text "Сертификат для ЕГАИС"
  # -state disabled

  grid $c.lfr1.rb1 -row 0 -column 0 -sticky w -padx 10 -pady {0 3}
  grid $c.lfr1.rb2 -row 0 -column 1 -sticky w -padx 10 -pady {0 3}
  grid $c.lfr1.rb4 -row 3 -column 0 -sticky w -padx 10 -pady {0 4}
  grid $c.lfr1.chb4 -row 3 -column 1 -sticky w -padx 10 -pady {0 4}

  ttk::button  $c.b2 -command {::workOpCert} -text "Выполнить операцию" -style My.TButton

  grid $c.lsep -row 2 -columnspan 2 -sticky wnse -pady 3
  grid $c.fcrt -row 3 -column 0 -columnspan 2 -sticky wsen -padx {0 4} -pady {0 2}
  grid columnconfigure $c 1 -weight 1


  grid $c.lfr1 -row 4 -column 0 -columnspan 2 -sticky w -padx 4 -pady {0 4}

  grid $c.b2 -row 4 -column 1 -sticky e -padx {2 10} -pady {4 0}
  if {$typesys == "x11"} {
    $c.lfr1 configure -style RoundedLabelFrame
    $c_old.build configure -style RoundedLabelFrame
  }
}

proc ::viewasn1 {clip} {
  variable asn_fn
  variable asntype
  variable asnraw
  if {$clip == 0 && $asn_fn == ""} {
    tk_messageBox -title "Просмотр ASN1-структуры" -message "Файл не выбран" -icon info  -parent .
    return
  }
  set ::prettyColumn -1;
  set deritem ""
  if {$clip == 0} {
    set fd [open $asn_fn]
    chan configure $fd -translation binary
    set deritem [read $fd]
    close $fd
  } elseif {$clip == 1} {
    set deritem [clipboard get]
  } elseif {$clip == 2} {
    set deritem [selection get]
  }
  if {$deritem == "" } {
    tk_messageBox -title "Просмотр ASN1-структуры" -message "Пустой файл или пустой буфер обмена" -icon info  -parent .
    return
  }

  if {$asntype == 1 || $clip == 2} {
    #HEX-файл
    set b [string map {"\n" "" "\t" "" "\r" "" ":" "" "." "" " " ""} $deritem]
    if {[catch {set deritem [binary format H* $b] } res] } {
      tk_messageBox -title "Просмотр ASN1-структуры" -message "Файл не содержит HEX-код или не правильно указан формат" -icon info  -parent .
      return
    }
  } elseif {$asntype == 2} {
    #PEM в трактовке openssl
    set head [string range $deritem 0 10]
    set i [string equal "-----BEGIN " $head]
    if {$i != 1} {
      tk_messageBox -title "Просмотр ASN1-структуры" -message "Файл не PEM-формата\nОтсутствует заголовок \n-----BEGIN ...-----\n" -icon info  -parent .
      return
    }
    set ind [string first "-----" $deritem 12]
    if {$ind == -1} {
      tk_messageBox -title "Просмотр ASN1-структуры" -message "Файл не PEM-формата\nОтсутствует заголовок \n-----BEGIN ...-----\n" -icon info  -parent .
      return
    }
    append head [string range $deritem 11 $ind+4]
    set tail "-----END "
    append tail [string range $deritem 11 $ind+4]
    set deritem [string map {"\r" ""} $deritem]
    array set parsed [::pki::_parse_pem $deritem $head $tail]
    set deritem $parsed(data)
  }
  if {$asnraw == 1} {
    #Расширенный просмотр
    set t 8
  } else {
    set t 9
  }
  aboutUtil ".about" $t $deritem
}

proc page_asn1view {c} {
  global macos
  global env
  variable asn_fn
  variable asnraw
  set asnraw 1
  set asn_fn ""
  variable asntype
  set asntype 0
  global typesys

  set filetypecert {
    {{Файл в DER формате}    .der}
    {{Файл в PEM формате}    .pem}
    {{Файл в HEX формате}    .hex}
    {{Любой тип}    *}
  }

  frame $c.fcrt -relief flat -pady 2 -padx 0
  label $c.fcrt.l2 -text "Файл с ASN1-структурой:" -font TkDefaultFontBold
  pack $c.fcrt.l2  -padx 0 -side left  -pady 0 -expand 0 -fill both
  if {$macos} {
    set ft ""
  } else {
    set ft $filetypecert
  }
  cagui::FileEntry $c.fcrt.e2 -dialogtype open \
  -title "Выберите файл с ASN1-структурой" \
  -width 48 \
  -defaultextension "*.der *.pem *.asn* " \
  -variable  asn_fn \
  -initialdir $env(HOME) \
  -filetypes $ft
  pack $c.fcrt.e2 -side left -expand 1 -fill both
  button  $c.fcrt.viewcrt -command {variable asn_fn; ::viewasn1 0} -image ::img::view_18x16 -compound right -bd 0 -background white -activebackground white -highlightthickness 0
  set lc "bind $c.fcrt.viewcrt <Enter> {.helpview configure -text \"Просмотр ASN1-структуры\";place .helpview -in $c.fcrt.e2 -relx 1.0 -rely 1.0 -anchor ne}"
  set lc [subst $lc]
  eval $lc
  bind $c.fcrt.viewcrt <Leave> {place forget .helpview}
  pack $c.fcrt.viewcrt -side right -padx {2 0} -pady 0 -expand 0 -fill none
  ########
  ttk::labelframe $c.lfr1 -text "Формат файла с ASN1-структурой" -labelanchor n
  ttk::radiobutton $c.lfr1.rb1 -value 0 -variable asntype -text "DER"
  ttk::radiobutton $c.lfr1.rb2 -value 1 -variable asntype -text "HEX"
  ttk::radiobutton $c.lfr1.rb3 -value 2 -variable asntype -text "PEM"
  ttk::checkbutton $c.raw -variable asnraw -text "Дополнительные подробности"

  pack $c.lfr1.rb1 $c.lfr1.rb2 $c.lfr1.rb3 -side left -fill x -expand 1 -padx {40 10}

  ttk::labelframe $c.lasn -text "Просмотр ASN1-структуры" -labelanchor n
  ttk::button  $c.lasn.b2 -command {::viewasn1 0} -text "Просмотр стр-ры файла" -style My.TButton
  ttk::button  $c.lasn.b3 -command {::viewasn1 1} -text "Просмотр буфера обмена" -style My.TButton
  pack $c.lasn.b2 -side left -pady 3mm -padx 10mm
  pack $c.lasn.b3 -side right -padx 10mm

  grid $c.fcrt -row 0 -column 0 -columnspan 2 -sticky wsen -padx {0 4} -pady {5 5}
  grid columnconfigure $c 1 -weight 1


  grid $c.lfr1 -row 1 -column 0 -columnspan 2 -sticky wsen -padx {20 20} -pady {10 4}
  if {$typesys == "x11"} {
    $c.lasn configure -style RoundedLabelFrame
    $c.lfr1 configure -style RoundedLabelFrame
  }

  grid $c.raw -row 2 -column 0 -columnspan 2 -sticky w -padx 4 -pady {10 0}

  grid $c.lasn -row 3 -column 0 -columnspan 2  -padx 4 -pady {10 0}
}



proc clock:set var {
  global $var
  set $var "Текущее время: [clock format [clock seconds] -format {%H:%M:%S %d.%m.%Y}]"
  after 1000 [list clock:set $var]
}

proc readPw ent {
  global widget
  global yespas
  global pass
  #	puts "readPWD"
  set pass [$ent get]
  $ent delete 0 end
  set yespas "yes"
}



proc ::sign_file {w typekey} {
  global ttt
  global typesys
  variable nickCert
  global pass
  global yespas
  set yespas ""
  set pass ""
  #    puts "sign_file=$w"
  variable file_for_sign
  variable doc_for_sign
  variable typesig
  variable doc_for_sign
  if {0} {
    if {$nickCert == "" } {
      tk_messageBox -title "Подписать документ" -message "Нет сертификата подписанта" -detail "AR=[array size ::certs_p11]" -icon error  -parent .
      return
    }
  }
  #  if {[array size ::certs_p11] == "0" } {}
  if { $typekey == "pkcs11" && [llength [array names ::certs_p11]] < 1} {
    tk_messageBox -title "Подписать документ" -message "На токене нет сертификатов" -icon info  -parent .
    return
  }
  if {$doc_for_sign == "" } {
    tk_messageBox -title "Подписать документ" -message "Не выбран документ для подписания" -icon error  -parent .
    return
  }
  if {$file_for_sign == "" } {
    tk_messageBox -title "Подписать документ" -message "Не выбран файл для хранения ЭП" -icon error  -parent .
    return
  }

  #puts "sign_file=$nickCert"
  set cert_hex ""
  set ::dercert ""
  if {$typekey == "pkcs11"} {
    set ret [p11status]
    if {$ret != 0} {
      return
    }
    set saveCert ".st.fr1.fr2_certs"
    set ind [$saveCert.listCert current]
    set nick  [lindex $::listx509 $ind]

    set cert_hex [lindex $::certs_p11($nick) 0]
  } elseif {$typekey == "pkcs12"} {
    set cert_hex $::certfrompfx
  } else {
    tk_messageBox -title "Подписать документ" -message "Неизвестное хранилище ключа" -icon error  -parent .
    return
  }
  if {$cert_hex == ""} {
    if {$typekey == "pkcs11"} {
      tk_messageBox -title "Подписать документ" -message "На токене отсутствует (не выбран) сертификат подписанта!" -icon error  -parent .
    } else {
      tk_messageBox -title "Подписать документ" -message "Отсутствует контейнер PKCS12 подписанта"  -icon error  -parent .
    }
    return
  }
  set fd [open $doc_for_sign]
  chan configure $fd -translation binary
  set content [read $fd]
  close $fd
  if {$content == "" } {
    tk_messageBox -title "Подписать документ" -message "Попытка подписать пустой документ:" -detail "\t$doc_for_sign" -icon error  -parent .
    return
  }
  #puts "typesig=$typesig"
  set f [file join $file_for_sign [file tail $doc_for_sign]]
  set f_sign "$f.p7s"
  if {$typekey == "pkcs11"} {
    #puts "f_sign=$f_sign"
    $::tokenls11sw0 login
    set privkey [$::tokenls11sw0 listobjects  privkey]
    $::tokenls11sw0 logout
    #puts "PRIVKEY=$privkey"
    #puts "nickCert=$nickCert"
    ######################
    set saveCert ".st.fr1.fr2_certs"
    set ind [$saveCert.listCert current]
    set nick  [lindex $::listx509 $ind]

    set cert_derhex [lindex $::certs_p11($nick) 0]
    set ::cert_pkcs11_id [lindex $::certs_p11($nick) 1]
    #Экспорт в текстовом виде	.saveCert.labExp.but.butSave configure -text [mc "Export"]
    set ::tekcert "pkcs11"
    ###################

    set i 0
    foreach prkey $privkey {
      if {$::cert_pkcs11_id == [lindex $prkey 3]} {
        #	    if {$nickCert == [lindex $prkey 2]} {}
        set i 1
        break
      }
    }
    if {$i == 0 } {
      tk_messageBox -title "Подписать документ" -message "Документ подписать не удалось" -detail "У сертификата \n$nickCert\n нет закрытого ключа" -icon error  -parent .
      return
    }
  }

  .topclock.lclock configure -text "Начался процесс подписания\n\nдокумента из файла\n\n[file tail $doc_for_sign]\n\nПодождите некоторое время!"
  .topclock configure -text "Идет процесс подписания"
  place .topclock -in .st.fr1.fr2_certs.labCert  -relx 1.0 -rely 3.0 -relwidth 3.5
  tk busy hold ".st.fr1"
  tk busy hold ".st.fr3"

  #      update
  vwait ttt
  set err [::pkcs7_create_signeddata $content $cert_hex $typesig $f_sign $typekey]
  #    catch {::pki::pkcs11::logout $::handle $::slotid_tek}
  if {$err == 1} {
    tk_messageBox -title "Подписать документ" -message "Документ успешно подписан." -detail "Подпись сохранена в файле:\n$f_sign" -icon info  -parent .topclock
    tk busy forget ".st.fr1"
    tk busy forget ".st.fr3"
    place forget .topclock
    return
  }
  if {$err != 0} {
    tk_messageBox -title "Подписать документ" -message "Документ подписать не удалось" -detail "$err" -icon error  -parent .
  }
  tk busy forget ".st.fr1"
  tk busy forget ".st.fr3"

  place forget .topclock
}

proc page_pkcs7_sign {c} {
  global macos
  global env
  global reqFL
  global typeCert
  global sodCert
  global typesys
  variable file_for_sign
  set file_for_sign ""
  variable doc_for_sign
  set doc_for_sign ""
  variable createTimeStamp
  set createTimeStamp 0
  variable createescTS
  set createescTS 0
  variable typesig
  set typesig 1

  set wd 54
  if {$macos} {
    set ft ""
  } else {
    set ft $::filetypesrc
  }
  #  -width $wd \\

  cagui::FileEntry $c.e1 -dialogtype open \
  -title "Выберите документ для подписи" \
  -defaultextension "*.txt *.doc* *.pdf *.xml* *.xl*" \
  -variable  doc_for_sign \
  -initialdir $env(HOME) \
  -filetypes $ft \
  -typewd frame
  #  -typewd window
  label $c.l2 -text "Каталог для подписи:"

  cagui::FileEntry $c.e2 -dialogtype directory \
  -title "Каталог для хранения подписи" \
  -width $wd \
  -variable  file_for_sign \
  -initialdir $env(HOME) \
  -parent "."

  ttk::labelframe $c.lfr0 -text "Тип электронной подписи"  -labelanchor n
  ttk::radiobutton $c.lfr0.rb1 -value 1 -variable typesig -text "Присоединенная"
  ttk::radiobutton $c.lfr0.rb2 -value 0 -variable typesig -text "Отсоединенная"
  grid $c.lfr0.rb1 -row 0 -column 0 -sticky nw -padx {16 8} -pady {0 4}
  grid $c.lfr0.rb2 -row 0 -column 1 -sticky ne -padx {8 16} -pady {0 4}
  #  grid columnconfigure $c.lfr0 0 -weight 1

  label $c.tsp -text "Сервер TSP:" -anchor w -bg white  -width 0 -height 0
  ttk::combobox $c.listTSP  -textvariable ::tekTSP -values $::listtsp -background white -style TCombobox
    #     -width $wd
  set ::tekTSP [lindex $::listtsp 0]

  ttk::labelframe $c.lfr1 -text "Формат подписи" -labelanchor n
  if {$typesys == "x11"} {
    #    ttk::style layout RoundedLabelFrame {
    #	RoundedLabelFrame -sticky nsew
    #    }
    $c.lfr0 configure -style RoundedLabelFrame
    $c.lfr1 configure -style RoundedLabelFrame
  }
  ttk::radiobutton $c.lfr1.chb0 -value -1 -variable createescTS -text "PKCS#7"
  ttk::radiobutton $c.lfr1.chb1 -value 0 -variable createescTS -text "CAdes-BES"
  ttk::radiobutton $c.lfr1.chb2 -value 1 -variable createescTS -text "CAdes-T"
  ttk::radiobutton $c.lfr1.chb3 -value 2 -variable createescTS -text "CAdes-XLT1"
  grid $c.lfr1.chb0 -row 0 -column 0 -sticky nw -padx {16 8} -pady {4 4}
  grid $c.lfr1.chb1 -row 0 -column 1 -sticky nw -padx {8 8} -pady {4 4}
  grid $c.lfr1.chb2 -row 0 -column 2 -sticky n -padx {8 8} -pady {4 4}
  grid $c.lfr1.chb3 -row 0 -column 3 -sticky ne -padx {8 16} -pady {4 4}
  grid columnconfigure $c.lfr1 0 -weight 1

  label $c.e1.l1 -text "Документ:"
  pack $c.e1.l1 -side left  -padx {0 4} -pady {4 4}
  #  grid $c.l1 -row 0 -column 0 -sticky w -padx {4 0} -pady {4 4}
  grid $c.e1 -row 0 -column 0 -columnspan 2 -sticky nwse -padx {4 0} -pady {4 4}
  eval "bind $c.e1.but <Enter> {.helpupdate configure -text {Выбрать документ для подписи};place .helpupdate -in $c.e1.but -relx 1.0 -rely 1.0 -anchor ne}"
  bind $c.e1.but <Leave> {place forget .helpupdate}

  grid $c.l2 -row 1 -column 0 -sticky w -padx {4 0} -pady {4 4}
  grid $c.e2 -row 1 -column 1 -sticky nwse -padx {4 0} -pady {4 4}
  eval "bind $c.e2.but <Enter> {.helpupdate configure -text {Выбрать каталог для подписи};place .helpupdate -in $c.e2.but -relx 1.0 -rely 1.0 -anchor ne}"
  bind $c.e2.but <Leave> {place forget .helpupdate}
  grid $c.lfr0 -row 3 -column 0 -columnspan 2 -sticky sn -padx {10 10} -pady {10 4}
  grid columnconfigure $c 1 -weight 1

  grid $c.tsp -row 2 -column 0 -sticky w -padx {4 0} -pady {4 4}
  grid $c.listTSP -row 2 -column 1 -sticky nwse -padx {4 4} -pady {4 4} -ipady 2


  grid $c.lfr1 -row 4 -column 0 -columnspan 2 -sticky sn -padx {20 20} -pady {10 4}
  #Для Win32, почему-то не видит сверху
  ttk::style layout RoundedFrameME {
    RoundedFrameME -sticky nsew
  }

  ttk::frame  $c.framefortime -style RoundedFrameME -padding {10 10 0 0}

  label $c.l3 -textvariable myclock -background #43cafa -font TkDefaultFontBold -padx 0 -pady 1mm
  # -padx 3mm -pady 3mm
  pack $c.l3 -in $c.framefortime -fill x -padx 3mm -pady {0 3mm} -anchor nw

  grid $c.framefortime -row 5 -column 0 -columnspan 2 -sticky n -padx {8 0} -pady {5mm 5mm}

  set com "ttk::button  $c.b2 -command {::sign_file  $c \"pkcs11\"} -text \"Подписать документ\" -style My.TButton"
  eval [subst $com]

  set offb [expr $::px2mm + $::px2mm / 2]
  eval "grid $c.b2 -row 6 -column 0 -columnspan 2 -sticky ne -pady {10 4} -padx {2mm $offb}"

  clock:set myclock          ;# call once, keeps ticking ;-) RS
  }

proc createnick {issuer_str subject_str} {
  set cn_subject ""
  set cn_issuer ""
  set lsub [split $subject_str ","]
  set lsub [del_comma $lsub]
  #    puts $lsub
  set cn_subject "Отсутствует"
  foreach a $lsub {
    set ind [string first "=" $a]
    if {$ind == -1 } { continue }
    set oidsub [string trim [string range $a 0 $ind-1]]
    set oidval "[string trim [string range $a $ind+1 end]]"
    if {$oidsub == "CN"} {
      set cn_subject  $oidval
      break;
    }
  }
  #ISSUER
  set lsub [split $issuer_str ","]
  set lsub [del_comma $lsub]
  #    puts $lsub
  set cn_issuer "Отсутствует"
  foreach a $lsub {
    set ind [string first "=" $a]
    if {$ind == -1 } { continue }
    set oidsub [string trim [string range $a 0 $ind-1]]
    set oidval "[string trim [string range $a $ind+1 end]]"
    if {$oidsub == "CN"} {
      set cn_issuer  $oidval
      break;
    }
  }
  return "$cn_subject from $cn_issuer"
}

proc nickforegais {subject_str} {
  set cn_subject ""
  set cn_issuer ""
  set sub_kpp ""
  set sub_inn ""
  set lsub [split $subject_str ","]
  set lsub [del_comma $lsub]
  foreach a $lsub {
    set ind [string first "=" $a]
    if {$ind == -1 } { continue }
    set oidsub [string trim [string range $a 0 $ind-1]]
    set oidval "[string trim [string range $a $ind+1 end]]"
    if {$oidsub == "UN"} {
      set sub_kpp  $oidval
    } elseif {$oidsub == "INN"} {
      set sub_inn  $oidval
    }
  }
  if {$sub_kpp == "" || $sub_inn == ""} {
    return ""
  }
  set len_kpp [string length $sub_kpp]
  if {$len_kpp != 4 && $len_kpp != 13} {
    return ""
  }
  if {[string range $sub_kpp 0 3] != "КПП="} {
    return ""
  }
  if {$len_kpp == 13} {
    append sub_inn "-"
    append sub_inn [string range $sub_kpp 4 end]
  }
  return $sub_inn
}
#-----------------------------------------------------------------------------
# asnGNTTime : Encode an GNT time string
#-----------------------------------------------------------------------------
proc ::asn::asnGNTTime {GNTtimestring} {
  # the gnt time tag is 0x18.
  #
  # BUG: we do not check the string for well formedness

  set ascii [encoding convertto ascii $GNTtimestring]
  set len [string length $ascii]
  return [binary format H2a*a* 18 [asnLength $len] $ascii]
}


proc asn::asnGetGNTTime {data_var utc_var} {
  upvar 1 $data_var data $utc_var utc

  asnGetByte data tag
  if {$tag != 0x18} {
    return -code error \
    [format "Expected GNTTime (0x18), but got %02x" $tag]
  }

  asnGetLength data length
  asnGetBytes data $length bytes

  # this should be ascii, make it explicit
  set bytes [encoding convertfrom ascii $bytes]

  binary scan $bytes a* utc

  return
}


proc trace_signedcert {name index op} {
  variable varTypeSign
  variable varescTS
  upvar 1 $name nick
  #puts "trace_signedcert=$nick"
  foreach p7t $::lp7 {
    #puts "P7=$p7t"
    array set p7 $p7t
    #parray p7
    if {$nick == $p7(nickcert)} {
      set varTypeSign $p7(attached)
      set varescTS [expr $p7(esctimeStamp) + $p7(timeStamp)]
      if {$varescTS == 0} {
        if {![info exists p7(signedtcertv2)]} {
          #Формат подписи PKCS7
          set varescTS -1
        }
      }
      set ::dateSign ""
      set ::dateSign "Дата подписания: Дата подписания отсутствует"
      if {[info exists p7(signedTime)]} {
        set ::dateSign "Дата подписания: "
        set tt_utc [clock scan $p7(signedTime) -format {%y%m%d%H%M%SZ} -gmt 1]
        set ::dateSign "$::dateSign [clock format $tt_utc -format  {%H:%M:%S %d.%m.%Y}]"
        #puts "trace_signedcert=$::dateSign"
      }
      if {$p7(attached) == 0} {
        tk_messageBox -title "Работа с PKCS7" -icon info -message "Подпись отсоединенная." -detail "Укажите путь с подписанному документу" -parent .
      }
      set ::dateSignTST "Дата получения штампа времени: Штамп времени отсутствует"
      if {[info exists p7(tstinfo)]} {
        switch -- $p7(tstdigest) {
          "1.2.643.7.1.1.2.2" - "1 2 643 7 1 1 2 2" {
            #    "GOST R 34.11-2012-256"
            set digest_algo "stribog256"
          }
          "1.2.643.7.1.1.2.3" - "1 2 643 7 1 1 2 3" {
            #     "GOST R 34.11-2012-512"
            set digest_algo "stribog512"
          }
          default {
            puts "Cannot veridy TST\nUnknown digestalgo=$p7(tstdigest)"
            return
          }
        }
        set signbin [binary format H* $p7(signature)]
        set digest_hex    [pki::pkcs11::dgst $digest_algo $signbin ]
                                        		

        #puts "trace_signedcertTST=$p7(tstinfo)"
        set tstfull [binary format H* $p7(tstinfo)]
        asn::asnGetSequence tstfull tst
        ::asn::asnGetInteger tst version
        ::asn::asnGetObjectIdentifier tst oidDigest1
        #puts "oidDigest1=$oidDigest1"
        asn::asnGetSequence tst tst1
        asn::asnGetSequence tst1 tst2
        ::asn::asnGetObjectIdentifier tst2 oidDigest2
        #puts "oidDigest2=$oidDigest2"
        switch -- $oidDigest2 {
          "1.2.643.7.1.1.2.2" - "1 2 643 7 1 1 2 2" {
            #    "GOST R 34.11-2012-256"
            set digest_tsp "stribog256"
          }
          "1.2.643.7.1.1.2.3" - "1 2 643 7 1 1 2 3" {
            #     "GOST R 34.11-2012-512"
            set digest_tsp "stribog512"
          }
          default {
            puts "Cannot veridy TST\nUnknown digesttsp=$oidDigest2"
            return
          }
        }
        ::asn::asnGetOctetString tst1 digsign
        ::asn::asnGetBigInteger tst num1
        ::asn::asnGetGNTTime tst timetst
        #puts "timetst=$timetst"

        set ::dateSignTST "Дата получения штампа времени: "
        set tt_utc [clock scan $timetst -format {%Y%m%d%H%M%SZ} -gmt 1]
        set ::dateSignTST "$::dateSignTST [clock format $tt_utc -format  {%H:%M:%S %d.%m.%Y}]"
                                        		
        set signbin [binary format H* $p7(signature)]
        set digest_hex    [pki::pkcs11::dgst $digest_algo $signbin ]
        set digesttsp_hex    [pki::pkcs11::dgst $digest_tsp $signbin ]
        binary scan $digsign H* digsign_hex
        if {$digsign_hex != $digesttsp_hex} {
          tk_messageBox -title "Работа с PKCS7" -icon error -message "Проверка штампа времени" -detail "Штамп времени не от этой подписи" -parent .
          set ::dateSignTST "Дата получения штампа времени: Штамп времени чужой"
        }

      }
      set ::dateSignEscTS "Дата утверждения метки времени: Штамп отсутствует"
      if {[info exists p7(esctstinfo)]} {
        switch -- $p7(tstdigest) {
          "1.2.643.7.1.1.2.2" - "1 2 643 7 1 1 2 2" {
            #    "GOST R 34.11-2012-256"
            set digest_algo "stribog256"
          }
          "1.2.643.7.1.1.2.3" - "1 2 643 7 1 1 2 3" {
            #     "GOST R 34.11-2012-512"
            set digest_algo "stribog512"
          }
          default {
            puts "Cannot veridy TST\nUnknown digestalgo=$p7(tstdigest)"
            return
          }
        }
        set signbin [binary format H* $p7(signature)]
        set digest_hex    [pki::pkcs11::dgst $digest_algo $signbin ]
                                        		

        #		set ::dateSignTST "Дата получения метки времени: Метка времени присутствует"
        #puts "trace_signedcertTST=$p7(tstinfo)"
        set tstfull [binary format H* $p7(esctstinfo)]
        asn::asnGetSequence tstfull tst
        ::asn::asnGetInteger tst version
        ::asn::asnGetObjectIdentifier tst oidDigest1
        #puts "oidDigest1=$oidDigest1"
        asn::asnGetSequence tst tst1
        asn::asnGetSequence tst1 tst2
        ::asn::asnGetObjectIdentifier tst2 oidDigest2
        #puts "oidDigest2=$oidDigest2"
        switch -- $oidDigest2 {
          "1.2.643.7.1.1.2.2" - "1 2 643 7 1 1 2 2" {
            #    "GOST R 34.11-2012-256"
            set digest_tsp "stribog256"
          }
          "1.2.643.7.1.1.2.3" - "1 2 643 7 1 1 2 3" {
            #     "GOST R 34.11-2012-512"
            set digest_tsp "stribog512"
          }
          default {
            puts "Cannot veridy TST\nUnknown digesttsp=$oidDigest2"
            return
          }
        }
        ::asn::asnGetOctetString tst1 digsign
        ::asn::asnGetBigInteger tst num1
        ::asn::asnGetGNTTime tst timetst
        #puts "timeescts=$timetst"

        set ::dateSignEscTS "Дата утверждения метки времени: "
        set tt_utc [clock scan $timetst -format {%Y%m%d%H%M%SZ} -gmt 1]
        set ::dateSignEscTS "$::dateSignEscTS [clock format $tt_utc -format  {%H:%M:%S %d.%m.%Y}]"
        #puts "ПРОВЕРКА escTS=$::dateSignEscTS"
        set signbin [binary format H* $p7(signature)]
        append signbin $p7(tst_der)
        append signbin $p7(certRefs_der)
        append signbin $p7(revokeRefs_der)
        #puts "digest_tsp=$digest_tsp"
        #puts "digest_algo=$digest_algo"
        set digest_hex    [pki::pkcs11::dgst $digest_algo $signbin ]
        set digesttsp_hex    [pki::pkcs11::dgst $digest_tsp $signbin ]
        binary scan $digsign H* digsign_hex
        if {$digsign_hex != $digesttsp_hex} {
          tk_messageBox -title "Работа с PKCS7" -icon error -message "Проверка штампа времени" -detail "Штамп escTS не от этой подписи" -parent .
        }
      }
                              	
      break
    }
  }
}

proc trace_p7s {name index op} {
  variable p7s_fn
  variable varTypeSign
  variable ::listx509S
  variable ::lcerts
  set c ".st.fr1.fr2_list2"
  #    puts "TRACE_P7S"
  upvar 1 $name p7s
  #Что подписывали
  #puts "C=[$c.e2.entry get]"
  #parray p7s
  #puts "FILE_P7S=$p7s($index)"
  #puts "FILE_P7S=$p7s"
  #puts "INDEX=$index"
  #puts "OP=$op"
  set lp7s [::parse_pkcs7 "file" $p7s ""]
  #puts "LP7S=$lp7s"
  if {$lp7s == -1} {
    tk_messageBox -title "Работа с PKCS7" -icon info -message "Подпись с неподдерживаемым хэшем" -parent .
    return
  }
  foreach {::lcerts lcrls ::lp7} $lp7s {}
  if {![info exists ::lp7]} {
    tk_messageBox -title "Работа с PKCS7" -icon info -message "Файл не содержит подписи" -parent .
    set p7s_fn ""
    return
  }

  if {[llength [lindex $::lp7 0]] == 1} {
    puts "P7 BAD=$lp7"
    return
  }
  #puts "CERTS=$lcerts"

  set ::listx509S {}
  set i 0
  set ::signedCert ""
  foreach p7t $::lp7 {
    #puts "P7=$p7t"
    array set p7 $p7t
    #parray p7
    if {$i == 0} {
      set varTypeSign $p7(attached)
      set ::signedCert $p7(nickcert)
      incr i
    }
    #Ищем подписанта
    lappend ::listx509S $p7(nickcert)
  }
  #puts "lnicks=$::listx509"
  $c.fr1.listCert configure -values $::listx509S
}

proc trace_pfx {name index op} {
  global param3410
  variable friendly
  variable pfx_fn
  global yespas
  global pass
  variable varTypeSign
  variable ::listx509
  variable ::lcerts
  set c ".st.fr1.fr2_list8"
  #    puts "TRACE_PFX"
  upvar 1 $name pfx
  if {$pfx == ""} {

    return
  }
  set file [open $pfx]
  fconfigure $file -translation binary
  set indata [read $file]
  close $file

  #Ввод пароля
  read_password "Введите пароль для \"[file tail $pfx]\""
  if { $yespas == "no" } {
    set pfx_fn ""
    set friendly ""
    set ::certfrompfx ""
    return 0
  }
  set yespas "no"
  set password $pass
  set pass ""

  set p12er [catch {array set dCertKey [::GostPfx::pfxGetSingleCertKey $indata "$password" $::nomacver]} rp12]
  if {$p12er} {
    set mm [string first "Invalid MAC" $rp12]
    if {$mm != -1} {
	tk_messageBox -title "Работа с PKCS12" -icon error -message "Проблемы с MAC.\nОтключите проверку MAC (кнопка nomacver) и\nпопробуйте повторить операцию" -detail "$rp12"  -parent .
    } else {
	tk_messageBox -title "Работа с PKCS12" -icon error -message "Это не PKCS12 или плохой пароль" -detail "$rp12"  -parent .
    }
    set pfx_fn ""
    set friendly ""
    set ::certfrompfx ""
    return
  }

  if {[info exists dCertKey(certificate)]} {
    if {[info exists dCertKey(friendlyName)]} {
      set friendly $dCertKey(friendlyName)
    } else {
      set friendly "Создать"
    }
    binary scan $dCertKey(certificate) H* ::certfrompfx
    set keyValue_hex ""
    if {[info exists dCertKey(keyValue)]} {
      set keyValueRev [string reverse $dCertKey(keyValue)]
      binary scan $keyValueRev H* keyValueRev_hex
      binary scan $dCertKey(keyValue) H* keyValue_hex
      set ::private_key_str $dCertKey(keyValue)
      #tk_messageBox -title "Работа с PKCS12" -icon info -message "Длина закрытого ключа" -detail "[string length $::private_key_str]"  -parent .
    }
    #	parray param3410
    set parid $param3410($dCertKey(gost3410Paramset))
    puts "TRACE_PFX parid=$parid"
    set gost11par  ""
    if {$dCertKey(keyAlg) == "1 2 643 7 1 1 1 1"} {
      set gost11par  "1 2 643 7 1 1 2 2"
      set ::group [lcc_gost3410_2012_256_getGroupById "$parid"]
      #set public_key_str [gost3410_2012_256_createPublicKey $group $private_key_str]
      set public_key_str [lcc_gost3410_2012_256_createPublicKey $::group $dCertKey(keyValue)]
      binary scan $public_key_str H* public_key_str_hex
      set x_str [string range $public_key_str 0 31]
      set y_str [string range $public_key_str 32 63]
      binary scan $x_str H* x_str_hex
      binary scan $y_str H* y_str_hex
      #tk_messageBox -title "Работа с PKCS12" -icon info -message "Publickey 256=$public_key_str_hex" -detail "x_str=$x_str_hex\ny_str=$y_str_hex"  -parent .

    } elseif {$dCertKey(keyAlg) == "1 2 643 7 1 1 1 2"} {
      set gost11par  "1 2 643 7 1 1 2 3"
      set ::group [lcc_gost3410_2012_512_getGroupById "$parid"]
      set public_key_str [lcc_gost3410_2012_512_createPublicKey $::group $dCertKey(keyValue)]
      binary scan $public_key_str H* public_key_str_hex
      set x_str [string range $public_key_str 0 63]
      set y_str [string range $public_key_str 64 128]
      binary scan $x_str H* x_str_hex
      binary scan $y_str H* y_str_hex
      #tk_messageBox -title "Работа с PKCS12" -icon info -message "Publickey 512=$public_key_str_hex" -detail "x_str=$x_str_hex\ny_str=$y_str_hex"  -parent .
    } else {
      tk_messageBox -title "Работа с PKCS12" -icon error -message "Неподдерживаемый тип ключа" -detail "$dCertKey(keyAlg)"  -parent .
      return
    }
    set ::public_key_str $public_key_str
    set ::gost3410Paramset  $dCertKey(gost3410Paramset)
    if {[info exists dCertKey(gost3411Paramset)]} {
	set ::gost3411Paramset  $dCertKey(gost3411Paramset)
    } else {
	set ::gost3411Paramset  $gost11par
    }
#    	set privkey "keyAlg: $dCertKey(keyAlg)\ngost3410Paramset: $dCertKey(gost3410Paramset)\ngost3410Paramset: $parid\ngost3411Paramset: $::gost3411Paramset\nkeyValue: $keyValue_hex\nkeyValueRev: $keyValueRev_hex"
#    	tk_messageBox -title "Работа с PKCS12" -icon info -message "$friendly" -detail "$privkey"  -parent .
  } else {
    tk_messageBox -title "Работа с PKCS12" -icon error -message "Файл $pfx \nне содержит контейнер PKCS12" -parent .
  }
  return
  }

proc feselectKDE {tdialog c typew titul tekdir var msk } {
  global wizDatacsr
  global wizDatacert
  set wizDatacsr(csr_fn)
  #tdialog - open|save|dir
  catch {  variable $var}
  switch -- $tdialog {
    "open"        {
      set vrr [FE::fe_getopenfile $typew "$c" $::lastDoc $msk]
    }
    "save" {
      set vrr [FE::fe_getsavefile $typew "$c" $::lastSave $msk]
    }
    "dir" {
      set vrr [FE::fe_choosedir $typew "$c" $::lastDir]
    }
    default {
      tk_messageBox -title "Файловый проводник" -icon info -message "Неизвестная операция=$tdialog"
      return
    }
  }
  $c.titul.lab configure -text $titul
  #  puts "vrr=$vrr"
  if {$typew == "frame"} {
    $c configure -relief groove -bd 2 -bg white  -highlightbackground #c0bab4 -highlightcolor skyblue  -highlightthickness 5
    place $c -in .st.fr1.fr2_certs.labCert  -relx 1.0 -rely 0.0 -relwidth 4.0
    tk busy hold ".st.fr1"
    tk busy hold ".st.fr3"
  }
  #  puts "wait ::otv"
  vwait $vrr
  if {$typew == "frame"} {
    tk busy forget ".st.fr1"
    tk busy forget ".st.fr3"
  }

  #  puts "var=$var"
  set selectobj [subst $$vrr]
    puts "subst=$selectobj"
  if {$selectobj != ""} {
    switch -- $tdialog {
	"open"        {
    	    set ::lastDoc [file dirname $selectobj ]
	}
	"save" {
    	    set ::lastSave [file dirname $selectobj ]
	}
	"dir" {
    	    set ::lastDir $selectobj
	}
    }
  }
  
  set $var $selectobj
  return $selectobj
}

proc page_pkcs7_view {c} {
  global macos
  global env
  global reqFL
  global typeCert
  global typesys
  global sodCert
  variable p7s_fn
  set p7s_fn ""
  variable src_fn
  set src_fn ""
  variable typeop
  set typeop 0
  variable varTypeSign
  set varTypeSign  0
  set varescTS  0
  set filetypep7s {
    {{PKCS7 (DER)} {.p7s}}
    {{PKCS7 (DER)} {.sig}}
    {{PKCS7 (DER)} {.p7b}}
    {{PKCS7 (PEM)} {.pem}}
    {{All Files} *}
  }
  frame $c.fr0  -bg snow
  label $c.fr0.l1 -text "Файл с ЭП:"

  if {$macos} {
    set ft ""
  } else {
    set ft $filetypep7s
  }

  cagui::FileEntry $c.fr0.e1 -dialogtype open \
  -title "Выберите файл с ЭП" \
  -width 64 \
  -defaultextension "*.p7s *.bin *.sig" \
  -variable p7s_fn \
  -initialdir $env(HOME) \
  -filetypes $ft
  pack $c.fr0.l1  -padx 0 -pady 0 -side left  -expand 0 -fill x
  pack $c.fr0.e1 -side right  -padx {2 1} -pady {1 0} -ipady 1  -expand 1 -fill x
  ##############
  ttk::labelframe $c.lfr0 -text "Тип и формат электронной подписи" -labelanchor n
  ttk::radiobutton $c.lfr0.rbs0 -text присоединенная -value 1 -variable varTypeSign
  ttk::radiobutton $c.lfr0.rbs1 -text отсоединенная -value 0 -variable varTypeSign
  frame $c.lfr0.sep -bg gainsboro -width 2
  ttk::radiobutton $c.lfr0.cbs3 -text "PKCS7" -value -1 -variable varescTS
  ttk::radiobutton $c.lfr0.cbs0 -text "CAdes-BES" -value 0 -variable varescTS
  ttk::radiobutton $c.lfr0.cbs1 -text "CAdes-T" -value 1 -variable varescTS
  ttk::radiobutton $c.lfr0.cbs2 -text "Cades-XLT1" -value 2 -variable varescTS
  grid $c.lfr0 -row 1 -column 0 -columnspan 1 -sticky sn -padx {5 10} -pady {0 1}
  pack $c.lfr0.rbs0 -side left -padx {5 0} -pady {0 1}
  pack $c.lfr0.rbs1 -side left -padx {0 0} -pady {0 1}
  pack $c.lfr0.sep -side left -padx {5 0} -pady {0 1} -fill y
  pack $c.lfr0.cbs3 -side left -padx {5 0} -pady {0 1}
  pack $c.lfr0.cbs0 -side left -padx {1 0} -pady {0 1}
  pack $c.lfr0.cbs1 -side left -padx {1 0} -pady {0 1}
  pack $c.lfr0.cbs2 -side left -padx {1 5} -pady {0 1}
  if {$macos} {
    set ft ""
  } else {
    set ft $::filetypesrc
  }
  cagui::FileEntry $c.e2 -dialogtype open \
  -title "Выберите подписанный файл" \
  -defaultextension "*.txt *.doc* *.pdf *.xml* *.xl*" \
  -width 57 \
  -variable  src_fn \
  -initialdir $::lastDoc \
  -filetypes $ft
  ############
  frame $c.fr1 -relief flat -pady 2
  label $c.fr1.labCert -text "Подписанты:" -anchor w -bg white  -width 0 -height 0
  pack $c.fr1.labCert  -padx 0 -side left -padx {0 4} -pady 0 -expand 0 -fill both
  ttk::combobox $c.fr1.listCert -textvariable ::signedCert  -values $::listx509S -background white -width 47 -style TCombobox
  pack $c.fr1.listCert -side left -expand 1 -fill both
  button  $c.fr1.viewcert -command {::viewCert "pkcs7" $::signedCert} -image ::img::view_18x16 -compound right -bd 0 -background white -activebackground white -highlightthickness 0
  set lc "bind $c.fr1.viewcert <Enter> {.helpview configure -text \"Просмотр сертификата\";place .helpview -in $c.fr1.listCert -relx 1.0 -rely 1.0 -anchor ne}"
  set lc [subst $lc]
  eval $lc
  bind $c.fr1.viewcert <Leave> {place forget .helpview}
  pack $c.fr1.viewcert -side right -padx {4 3} -pady 0 -expand 0 -fill none
  grid $c.fr1 -row 3 -column 0 -columnspan 1 -sticky wsen -padx {4 1} -pady {0 2}
  ########
  ttk::labelframe $c.lfr1 -text "Выберите операцию с Электронной Подписью" -labelanchor n
  ttk::radiobutton $c.lfr1.rb1 -value 0 -variable typeop -text "Проверить подпись"
  ttk::radiobutton $c.lfr1.rb2 -value 1 -variable typeop -text "Извлечь оригинал подписанного документа"
  ttk::radiobutton $c.lfr1.rb3 -value 3 -variable typeop -text "Добавить подпись"
  ttk::radiobutton $c.lfr1.rb4 -value 2 -variable typeop -text "Сохранить сертификат подписанта"
  ttk::radiobutton $c.lfr1.rb6 -value 5 -variable typeop -text "Извлечь штамп времени"
  ttk::checkbutton $c.lfr1.ch4 -variable typesave -text "PEM-формат"
  ttk::radiobutton $c.lfr1.rb5 -value 4 -variable typeop -text "Сохранить все сертификаты"
  ttk::checkbutton $c.lfr1.ch5 -variable typesave -text "PEM-формат"

  grid $c.fr0 -row 0 -column 0 -columnspan 1 -sticky wsen -padx {2 0} -pady {1 1}
  grid columnconfigure $c 0 -weight 1
  #  grid $c.l2 -row 2 -column 0 -sticky wn -padx {4 0} -pady {0 1}
  label $c.e2.l2 -text "Подписанный файл:" -fg black
  pack $c.e2.l2 -in $c.e2 -side left -padx {0 4}
  grid $c.e2 -row 2 -column 0  -sticky wnse -padx {4 0} -pady {0 1}
  grid $c.lfr1 -row 4 -column 0 -columnspan 1 -sticky sn -padx {20 20} -pady {0 1}
  grid $c.lfr1.rb1 -row 0 -column 0 -sticky w -padx {4 0} -pady {0 0}
  grid $c.lfr1.rb2 -row 1 -column 0 -sticky w -padx {4 0} -pady {0 0}
  grid $c.lfr1.rb6 -row 1 -column 1 -sticky w -padx {4 5mm} -pady {0 0}
  grid $c.lfr1.rb3 -row 0 -column 1 -sticky w -padx {4 0} -pady {0 0}
  grid $c.lfr1.rb4 -row 3 -column 0 -sticky w -padx {4 0} -pady {0 0}
  grid $c.lfr1.ch4 -row 3 -column 1 -sticky w -padx {4 0} -pady {0 0}
  grid $c.lfr1.rb5 -row 4 -column 0 -sticky w -padx {4 0} -pady {0 1}
  grid $c.lfr1.ch5 -row 4 -column 1 -sticky w -padx {4 0} -pady {0 1}

  frame $c.stamp
  label $c.stamp.tsp -text "Выберите Сервер TSP:" -anchor w -bg skyblue  -width 0 -height 0
  ttk::combobox $c.stamp.listTSP  -textvariable ::tekTSPadd -values $::listtsp  -style TCombobox -background skyblue
  set ::tekTSPadd [lindex $::listtsp 0]

  grid $c.stamp.tsp -row 0 -column 0 -sticky wn -padx {4 4} -pady {4 1}
  grid $c.stamp.listTSP -row 0 -column 1 -sticky nwse -padx {4 2} -pady {0 1} -ipady 2

  grid $c.stamp -row 5 -column 0 -sticky wnse -padx {4 4} -pady {4 1}
  grid columnconfigure $c.stamp 1 -weight 1

  label $c.l3 -text "Дата подписания:" -textvariable ::dateSign -anchor w -bg white  -width 0 -height 0
  grid $c.l3 -row 6 -column 0 -sticky wn -padx {4 0} -pady {0 1}
  label $c.l4 -text "Дата получения штампа времени:" -textvariable ::dateSignTST -anchor w -bg white  -width 0 -height 0
  grid $c.l4 -row 7 -column 0 -sticky wn -padx {4 0} -pady {0 1}
  label $c.l5 -text "Дата утверждения штампа времени:" -textvariable ::dateSignEscTS -anchor w -bg white  -width 0 -height 0
  grid $c.l5 -row 8 -column 0 -sticky wn -padx {4 0} -pady {0 1}


  ttk::button  $c.b2 -command {::workOp } -text "Выполнить операцию"  -style My.TButton
  grid $c.b2 -row 9 -column 0  -sticky e -padx 2mm -pady {0 0}
  if {$typesys == "x11"} {
    $c.lfr0 configure -style RoundedLabelFrame
    $c.lfr1 configure -style RoundedLabelFrame
  }

  trace variable p7s_fn w trace_p7s
  trace variable ::signedCert w trace_signedcert
}

proc setoptok {c} {
  set listop [list "Для инициализации токена заполните следующие поля:" "Для смены USER-PIN заполните следующие поля:" \
  "Для смены SO-PIN заполните следующие поля:" "Для разблокировки USER-PIN заполните следующие поля:" \
  "Для очистки токена заполните следующие поля:"]
  variable optok
  variable laboptok
  set laboptok [lindex $listop $optok]
  #  pack forget $c.butop
  switch $optok {
    0 {
      grid $c.lfr2.labTok -column 0 -padx 5 -pady 2 -row 0 -sticky we
      grid $c.lfr2.entTok -column 1 -padx 2 -pady 2 -row 0 -sticky we -padx {0 5}
      #        pack $c.lfr2 -side top -fill x -padx 20
      grid $c.lfr2
      $c.lfr2.labTok configure -text "Введите метку токена"
      $c.lfr2.labSoPin configure -text "Введите SO PIN"
      $c.lfr2.labUserPin configure -text "Новый PIN-пользователя"
      $c.lfr2.labRepUserPin configure -text "Повторите PIN-пользователя"
    }
    1 {
      grid forget $c.lfr2.labTok
      grid forget $c.lfr2.entTok
      #        pack $c.lfr2 -side top -fill x -padx 20
      grid $c.lfr2
      $c.lfr2.labSoPin configure -text "Текущий PIN-пользователя"
      $c.lfr2.labUserPin configure -text "Новый PIN-пользователя"
      $c.lfr2.labRepUserPin configure -text "Повторите новый USER-PIN"
    }
    2 {
      grid forget $c.lfr2.labTok
      grid forget $c.lfr2.entTok
      #        pack $c.lfr2 -side top -fill x -padx 20
      grid $c.lfr2
      $c.lfr2.labSoPin configure -text "Текущий SO-PIN"
      $c.lfr2.labUserPin configure -text "Новый SO-PIN"
      $c.lfr2.labRepUserPin configure -text "Повторите новый SO-PIN"
    }
    3 {
      grid forget $c.lfr2.labTok
      grid forget $c.lfr2.entTok
      #        pack $c.lfr2 -side top -fill x -padx 20
      grid $c.lfr2
      $c.lfr2.labSoPin configure -text "Введите SO PIN"
      $c.lfr2.labUserPin configure -text "Текущий PIN-пользователя"
      $c.lfr2.labRepUserPin configure -text "Повторите PIN-пользователя"
    }
    4 {
      #        pack forget $c.lfr2
      grid remove $c.lfr2
    }
  }
}

proc p11status {} {
  if {$::pkcs11_status == 1 } {
    tk_messageBox -title "Используемый токен"   -icon info -message "Нет подключенных токенов." -parent .
    return
  }
  if {$::pkcs11_status == 3 } {
    tk_messageBox -title "Используемый токен"   -icon info -message "Токен не лицензирован." -detail "Обратитесь к вкладке \"Создать токены\"" -parent .
    return
  }
  if {$::pkcs11_status == 2 } {
    tk_messageBox -title "Используемый токен"   -icon info -message "Токен еще не проинициализирован." -parent .
    return
  }
  return $::pkcs11_status
}

proc p11conf {c} {
  variable optok
  if {$::pkcs11_status == 3 } {
    tk_messageBox -title "Используемый токен"   -icon info -message "Токен не лицензирован."
    return
  }
  if {$::pkcs11_status == 2 && $optok != 0} {
    tk_messageBox -title "Используемый токен"   -icon info -message "Сначало проинициализируйте токен."
    return
  }

  switch $optok {
    0 {
      if {$::pkcs11_status == 0} {
        set answer [tk_messageBox -icon question \
        -title "Инициализация токена" \
        -message "Токен проинициализирован ранее." \
        -detail "Повторная инициализация приведет к потере данных\nБудете продолжать?" \
        -type yesno]

        if {$answer != "yes"} {
          return 0
        }
      }
      set ltok [$c.lfr2.entTok get]
      set sopin [$c.lfr2.entSoPin get]
      set upin [$c.lfr2.entUserPin get]
      set rupin [$c.lfr2.entRepUserPin get]
      if {$ltok == "" || $sopin == "" || $upin == "" || $rupin == "" || $upin != $rupin} {
        tk_messageBox -title "Инициализация токена" -icon info -message "Ошибка в заполнении полей. Будьте внимательны!" \
        -detail "upin=$upin\nrupin=$rupin\nltok=$ltok\nsopin=$sopin" -parent .
        return
      }
      catch {set ::handle [pki::pkcs11::unloadmodule $::handle]}
      catch {set ::handle [pki::pkcs11::loadmodule "$::pkcs11_module"]}
      #      updatetok
      if {$::slotid_tek == -10} {
        set ::slotid_tek 0
      }
      #      catch {::pki::pkcs11::logout $::handle $::slotid_tek}
      tk_messageBox -title "Инициализация токена" -icon info -message "$::handle $::slotid_tek $sopin $ltok" -parent .
      set ret [::pki::pkcs11::inittoken $::handle $::slotid_tek $sopin $ltok]
      if {!$ret} {
        tk_messageBox -title "Инициализация токена" -icon error -message "Инициализация токена не удалась" \
        -detail "Проверьте SO-PIN-код" -parent .
        return
      }
      set oldpin "98989898"
      catch {::pki::pkcs11::logout $::handle $::slotid_tek}
      ::pki::pkcs11::inituserpin $::handle $::slotid_tek $sopin $oldpin
      if {!$ret} {
        tk_messageBox -title "Инициализация токена" -icon error -message "Инициализация 1 токена не удалась" \
        -detail "Проверьте SO-PIN-код" -parent .
        return
      }
      catch {::pki::pkcs11::logout $::handle $::slotid_tek}
      set ret [::pki::pkcs11::setpin $::handle $::slotid_tek user $oldpin $upin]	
      if {$ret} {
        tk_messageBox -title "Инициализация токена" -icon info -message "Токен успешно проинициализирован" \
        -detail "Храните надежно и токен \"$ltok\" и PIN-коды" -parent .
        $c.lfr2.entSoPin delete 0 end
        $c.lfr2.entUserPin delete 0 end
        $c.lfr2.entRepUserPin delete 0 end
      } else {
        tk_messageBox -title "Инициализация токена" -icon error -message "Инициализация 2 токена не удалась" \
        -detail "Проверьте SO-PIN-код" -parent .
      }
      updatetok
    }
    1 {
      set tpin [$c.lfr2.entSoPin get]
      if {$tpin == ""} {
        tk_messageBox -title "Смена пользовательского PIN-кода" -icon info -message "Не задан текущий PIN-код. Будьте внимательны!"  -parent .
        return
      }
      set upin [$c.lfr2.entUserPin get]
      set rupin [$c.lfr2.entRepUserPin get]
      if {$upin == "" || $rupin == "" || $upin != $rupin} {
        tk_messageBox -title "Смена пользовательского PIN-кода" -icon info -message "Ошибка в новом PIN-коде. Будьте внимательны!" \
        -detail "upin=$upin\nrupin=$rupin" -parent .
        return
      }
      set ret [$::tokenls11sw0 setpin user $tpin $upin]

      if {$ret} {
        tk_messageBox -title "Смена пользовательского PIN-кода" -icon info -message "Новый PIN-код установлен" \
        -detail "Храните надежно и токен и PIN-коды" -parent .
        $c.lfr2.entSoPin delete 0 end
        $c.lfr2.entUserPin delete 0 end
        $c.lfr2.entRepUserPin delete 0 end
      } else {
        tk_messageBox -title "Смена пользовательского PIN-кода" -icon error -message "Сменить PIN-код не удалось" \
        -detail "Проверьте текущий PIN-код" -parent .
      }
    }
    2 {
      set sopin [$c.lfr2.entSoPin get]
      set upin [$c.lfr2.entUserPin get]
      set rupin [$c.lfr2.entRepUserPin get]
      if {$sopin == "" || $upin == "" || $rupin == "" || $upin != $rupin || $upin == "87654321"} {
        tk_messageBox -title "Смена SO-PIN-а" -icon info -message "Ошибка в заполнении полей. Будьте внимательны!" \
        -detail "SO-PIN не может быть равен первоначальному значению" -parent .
        return
      }
      set ret [$::tokenls11sw0 setpin so $sopin $upin]

      if {$ret} {
        tk_messageBox -title "Смена SO-PIN-кода" -icon info -message "Новый SO-PIN-код установлен" \
        -detail "Храните надежно и токен и PIN-коды" -parent .
        $c.lfr2.entSoPin delete 0 end
        $c.lfr2.entUserPin delete 0 end
        $c.lfr2.entRepUserPin delete 0 end
      } else {
        tk_messageBox -title "Смена SO-PIN-кода" -icon error -message "Сменить SO-PIN-код не удалось" \
        -detail "Проверьте текущий SO-PIN-код" -parent .
      }
      #      updatetok
    }
    3 {
      set sopin [$c.lfr2.entSoPin get]
      set upin [$c.lfr2.entUserPin get]
      set rupin [$c.lfr2.entRepUserPin get]
      if {$sopin == "" || $upin == "" || $rupin == "" || $upin != $rupin} {
        tk_messageBox -title "Деблокировать USER-PIN" -icon info -message "Ошибка в заполнении полей. Будьте внимательны!" \
        -detail "upin=$upin\nrupin=$rupin\nsopin=$sopin" -parent .
        return
      }
      set ret [::pki::pkcs11::inituserpin $::handle $::slotid_tek $sopin $upin]
      if {$ret} {
        tk_messageBox -title "Деблокировать USER-PIN" -icon info -message "Ваш PIN-код разблокирован" \
        -detail "Храните надежно и токен и PIN-коды" -parent .
        $c.lfr2.entSoPin delete 0 end
        $c.lfr2.entUserPin delete 0 end
        $c.lfr2.entRepUserPin delete 0 end
        updatetok
      } else {
        tk_messageBox -title "Деблокировать USER-PIN" -icon error -message "Разблокировать PIN-код не удалось" \
        -detail "Проверьте PIN-коды" -parent .
      }
    }
    4 {
      set ret [::deleteallobj]
      if {$ret} {
        tk_messageBox -title "Очистить токен" -icon info -message "Токен \"$::slotid_teklab\" очищен"  -parent .
      }
    }
  }

}

proc page_token {c} {
  global typesys
  variable optok
  set optok 0
  variable laboptok
  set laboptok "Для инициализации токена заполните следующие поля:"
  ttk::label .lforop -text "Выберите операцию с токеном:" -background wheat
  ttk::labelframe $c.lfr1  -labelwidget .lforop -labelanchor n
  set cmd "ttk::radiobutton $c.lfr1.rb1 -value 0 -variable optok -text {Инициализация токена} -width 30 -command {setoptok $c}"
  eval [subst $cmd]
  set cmd "ttk::radiobutton $c.lfr1.rb2 -value 1 -variable optok -text {Сменить USER-PIN} -command {setoptok $c}"
  eval [subst $cmd]
  set cmd "ttk::radiobutton $c.lfr1.rb3 -value 2 -variable optok -text {Сменить SO-PIN} -width 30 -command {setoptok $c}"
  eval [subst $cmd]
  set cmd "ttk::radiobutton $c.lfr1.rb4 -value 3 -variable optok -text {Деблокировать USER-PIN} -command {setoptok $c}"
  eval [subst $cmd]
  set cmd "ttk::radiobutton $c.lfr1.rb5 -value 4 -variable optok -text {Очистить токен} -command {setoptok $c} -padding {5 4 5 4}"
  eval [subst $cmd]

  grid $c.lfr1.rb1 -row 0 -column 0 -sticky news -padx 3mm -pady {2mm 1mm}
  grid $c.lfr1.rb2 -row 0 -column 1 -sticky nwe -padx 3mm -pady {2mm 1mm}
  grid $c.lfr1.rb3 -row 1 -column 0 -sticky news -padx 3mm -pady 1mm
  grid $c.lfr1.rb4 -row 1 -column 1 -sticky nwe -padx 3mm -pady 1mm
  grid $c.lfr1.rb5 -row 2 -column 0 -columnspan 2 -padx 40 -pady 2mm
  grid columnconfigure $c.lfr1 1 -weight 1

  grid $c.lfr1 -row 0 -column 0 -sticky wsen -padx {40 0} -pady 10

  ttk::label .lfortok -textvariable laboptok -background wheat
  ttk::labelframe $c.lfr2 -labelwidget .lfortok
  label $c.lfr2.labTok -background skyblue -justify left -text "Введите метку токена"  -anchor w -width 30
  grid $c.lfr2.labTok -column 0 -padx 5 -pady 2 -row 0 -sticky we
  entry $c.lfr2.entTok -background snow -width 40
  grid $c.lfr2.entTok -column 1 -padx 2 -pady 2 -row 0 -sticky we -padx {0 5}
  label $c.lfr2.labSoPin -background skyblue -text "Введите SO PIN" -anchor w -width 30
  grid $c.lfr2.labSoPin -column 0 -padx 5 -pady 2 -row 1 -sticky we
  entry $c.lfr2.entSoPin -background snow -show * -width 40
  grid $c.lfr2.entSoPin -column 1 -pady 2 -row 1 -padx {0 5}
  label $c.lfr2.labUserPin -background skyblue -text "Новый PIN-пользователя" -anchor w
  grid $c.lfr2.labUserPin -column 0 -row 2 -sticky we -padx 5
  entry $c.lfr2.entUserPin -background snow -show * -width 40
  grid $c.lfr2.entUserPin -column 1 -pady 2 -row 2 -padx {0 5}
  label $c.lfr2.labRepUserPin -background skyblue -text "Повторите PIN-пользователя" -anchor w
  grid $c.lfr2.labRepUserPin -column 0 -pady 2 -row 3 -sticky we -padx 5
  entry $c.lfr2.entRepUserPin -background snow -show * -width 40
  grid $c.lfr2.entRepUserPin -column 1 -pady 2 -row 3 -padx {0 5}

  grid $c.lfr2 -row 1 -column 0 -sticky se -padx {40 0}
  set cmd "ttk::button  $c.butop -command {p11conf  $c} -text {Выполнить операцию} -style TButton"
  eval [subst $cmd]
  grid $c.butop -row 2 -column 0  -sticky se -padx 0 -pady {10 0}
  if {$typesys == "x11"} {
    $c.lfr1 configure -style RoundedFrameME
    $c.lfr2 configure -style RoundedLabelFrame
  }
}

proc page_pkcs12 {c} {
  variable file_for_sign
  set file_for_sign ""
  variable doc_for_sign
  set doc_for_sign ""
  variable createTimeStamp
  set createTimeStamp 0
  variable createescTS
  set createescTS 0
  variable typesig
  set typesig 1
  variable friendly
  global typesys
  global macos
  global env
  global reqFL
  global typeCert
  global sodCert
  variable pfx_fn
  set pfx_fn ""
  variable src_fn
  set src_fn ""
  variable top12
  set top12 0
  variable ts12
  set ts12 0
  variable exp12
  set exp12 0
  variable varTypeSign
  set varTypeSign  0
  set varescTS  0
  set filetypep12 {
    {{PKCS12} {.pfx}}
    {{PKCS12} {.p12}}
    {{All Files} *}
  }
  #########
  frame $c.fr0  -bg snow
  ##########
  label $c.fr0.l1 -text "Файл с PKCS12:"
  if {$macos} {
    set ft ""
  } else {
    set ft $filetypep12
  }

  cagui::FileEntry $c.fr0.e1 -dialogtype open \
  -title "Выберите файл с PKCS12" \
  -width 60 \
  -defaultextension "*.pfx *.p12" \
  -variable pfx_fn \
  -initialdir $env(HOME) \
  -filetypes $ft
  pack $c.fr0.l1  -padx 0 -pady 0 -side left  -expand 0 -fill x
  pack $c.fr0.e1 -side right  -padx {2 1} -pady {1 0} -ipady 1  -expand 1 -fill x
  eval "bind $c.fr0.e1.but <Enter> {.helpupdate configure -text {Выбрать контейнер PKCS#12};place .helpupdate -in $c.fr0.e1.but -relx 1.0 -rely 1.0 -anchor ne}"
  bind $c.fr0.e1.but <Leave> {place forget .helpupdate}

  grid $c.fr0 -row 0 -column 0 -columnspan 2 -sticky wsen -padx {2 0} -pady {1 1}
  grid columnconfigure $c 0 -weight 1
  frame $c.frc  -bg snow
  set ::nomacver 0
  ttk::checkbutton $c.frc.mac -text "nomacver" -variable ::nomacver  -style My.TCheckbutton -compound left
  eval "bind $c.frc.mac <Enter> {.helpupdate configure -text {Не контролировать целостность};place .helpupdate -in $c.frc.mac -relx 1.0 -rely 1.0 -anchor n}"
  bind $c.frc.mac <Leave> {place forget .helpupdate}

  pack $c.frc.mac  -padx 0 -pady 0 -side left  -expand 0 -fill both
  #    label $c.frc.labCert -text "[mc {Certificate}]:" -font TkDefaultFontBold -anchor w -width 0 -bg white
  label $c.frc.labCert -text "friendlyName:" -font TkDefaultFontBold -anchor w -width 0 -bg white
  pack $c.frc.labCert  -padx 0 -pady 0 -side left  -expand 0 -fill both
  ttk::entry $c.frc.listCert -textvariable friendly -state normal
  pack $c.frc.listCert -side left  -padx 4 -pady 0 -expand 1 -fill both
  button  $c.frc.viewcert -command {::viewCert "pkcs12" $::certfrompfx} -image ::img::view_18x16 -compound left -pady 0 -bd 0 -bg white -activebackground white -highlightthickness 0
  .helpview config -bg #ffe0a6
  bind $c.frc.viewcert <Enter> {.helpview configure -text "Просмотр сертификата";place .helpview -in .st.fr1.fr2_list8.frc.listCert -relx 0.70 -rely 1.0}
  bind $c.frc.viewcert <Leave> {place forget .helpview}
  pack $c.frc.viewcert -side right -padx {0 3} -pady 0 -expand 0 -fill none
  grid $c.frc -row 1 -column 0 -columnspan 2 -sticky wsen -padx {2 2} -pady {1 1}
  ###############################################
  set wd 54
  set wd 72
  if {$macos} {
    set ft ""
  } else {
    set ft $::filetypesrc
  }

  cagui::FileEntry $c.e1 -dialogtype open \
  -title "Выберите документ для подписи" \
  -width $wd \
  -defaultextension "*.txt *.doc* *.pdf *.xml* *.xl*" \
  -variable  doc_for_sign \
  -initialdir $env(HOME) \
  -filetypes $ft

  cagui::FileEntry $c.e2 -dialogtype directory \
  -title "Каталог для хранения подписи" \
  -width $wd \
  -variable  file_for_sign \
  -initialdir $env(HOME) \
  -parent "."
  ttk::labelframe $c.lfr0 -text "Тип и формат электронной подписи"  -labelanchor n
  ttk::radiobutton $c.lfr0.rb1 -value 1 -variable typesig -text "Присоединенная" -pad 0
  ttk::radiobutton $c.lfr0.rb2 -value 0 -variable typesig -text "Отсоединенная" -pad 0
  frame $c.lfr0.sep -bg gainsboro -width 2
  ttk::radiobutton $c.lfr0.chb1 -value 0 -variable createescTS -text "CAdes-BES" -pad 0
  ttk::radiobutton $c.lfr0.chb2 -value 1 -variable createescTS -text "CAdes-T" -pad 0
  ttk::radiobutton $c.lfr0.chb3 -value 2 -variable createescTS -text "CAdes-XLT1" -pad 0

  grid $c.lfr0.rb1 -row 2 -column 0 -sticky w -padx 10 -pady {0 2}
  grid $c.lfr0.rb2 -row 2 -column 1 -sticky nw -padx {0 10} -pady {0 2}
  grid $c.lfr0.sep -row 2 -column 2 -sticky ns -padx {10 0} -pady 0
  grid $c.lfr0.chb1 -row 2 -column 3 -sticky nw -padx {20 14} -pady {0 2}
  grid $c.lfr0.chb2 -row 2 -column 4 -sticky ne -padx 0 -pady {0 2}
  grid $c.lfr0.chb3 -row 2 -column 5 -sticky e -padx {14 10} -pady {0 5}

  label $c.tsp -text "Сервер TSP:" -anchor w -bg white
  ttk::combobox $c.listTSP  -textvariable ::tekTSP -values $::listtsp -width $wd  -background white -style TCombobox
  set ::tekTSP [lindex $::listtsp 0]
  label $c.e1.l1 -text "Документ:"
  pack $c.e1.l1 -side left  -padx {0 4} -pady {2 0}
  grid $c.e1 -row 2 -column 0 -columnspan 2 -sticky wne -padx {4 0} -pady {2 0}
  eval "bind $c.e1.but <Enter> {.helpupdate configure -text {Выбрать документ для подписи};place .helpupdate -in $c.e1.but -relx 1.0 -rely 1.0 -anchor ne}"
  bind $c.e1.but <Leave> {place forget .helpupdate}

  label $c.e2.l2 -text "Каталог для подписи:"
  pack $c.e2.l2 -side left  -padx {0 4} -pady {2 0}
  grid $c.e2 -row 3 -column 0 -columnspan 2 -sticky nswe -padx {0 0} -pady {2 2}
  eval "bind $c.e2.but <Enter> {.helpupdate configure -text {Выбрать каталог для подписи};place .helpupdate -in $c.e2.but -relx 1.0 -rely 1.0 -anchor ne}"
  bind $c.e2.but <Leave> {place forget .helpupdate}
  grid $c.lfr0 -row 4 -column 0 -columnspan 2 -sticky sn -padx {4 2} -pady {2 2}

  grid $c.tsp -row 5 -column 0 -sticky wnse -padx {4 0} -pady {2 0}
  grid $c.listTSP -row 5 -column 1 -sticky nwse -padx {0 4} -pady {2 2} -ipady 2
  grid columnconfigure $c 1 -weight 1
  #Для Win32, почему-то не видит сверху
  ttk::style layout RoundedFrameME {
    RoundedFrameME -sticky nsew
  }
  ttk::frame  $c.framefortime -style RoundedFrameME -padding {10 10 0 0}
  label $c.l3 -textvariable myclock -background #43cafa -font TkDefaultFontBold -padx 0 -pady 0
  pack $c.l3 -in $c.framefortime -fill x -padx 3mm -pady {0 3mm} -anchor nw
  grid $c.framefortime -row 6 -column 0 -columnspan 2 -sticky n -padx {8 0}

  set com "ttk::button  $c.b2 -command {::sign_file  $c \"pkcs12\"} -text \"Подписать документ\" -style My.TButton -padding 4"
  eval [subst $com]

  set offb [expr $::px2mm + $::px2mm / 2]
  eval "grid $c.b2 -row 7 -column 0 -columnspan 2 -sticky n -pady {1mm 1mm} -padx {2mm $offb}"

  clock:set myclock          ;# call once, keeps ticking ;-) RS
  if {1} {
    ttk::labelframe $c.lfr1 -text "Дополнительные операции"
    ttk::radiobutton $c.lfr1.rb1 -value 0 -variable top12 -text "Сохранить сертификат на токене"
    ttk::radiobutton $c.lfr1.rb2 -value 1 -variable top12 -text "Импортировать закрытый ключ на токен"
    ttk::checkbutton $c.lfr1.ch0 -variable exp12 -text "Неэкспортируемый"
    ttk::radiobutton $c.lfr1.rb3 -value 2 -variable top12 -text "Сохранить сертификат в файле"
    ttk::checkbutton $c.lfr1.ch1 -variable ts12 -text "PEM-формат"
    grid $c.lfr1.rb1 -row 0 -column 0 -sticky wn -padx {4 0} -pady {0 0}
    grid $c.lfr1.rb2 -row 1 -column 0 -sticky wn -padx {4 0} -pady {0 0}
    grid $c.lfr1.ch0 -row 1 -column 1 -sticky wn -padx {10mm 0} -pady {0 1}
    grid $c.lfr1.rb3 -row 2 -column 0 -sticky wn -padx {4 0} -pady {0 1}
    grid $c.lfr1.ch1 -row 2 -column 1 -sticky wn -padx {10mm 0} -pady {0 1}

    grid $c.lfr1 -row 8 -column 0 -columnspan 2 -sticky nwse -padx 10mm -pady {1 1}

    ttk::button  $c.b3 -command {::workOpP12 } -text "Выполнить операцию" -style My.TButton -padding 2
    eval "grid $c.b3 -row 9 -column 0 -columnspan 2  -sticky e -padx {2mm $offb} -pady {2 0}"
    if {$typesys == "x11"} {
      $c.lfr1 configure -style RoundedLabelFrame
    }
  }
  if {$typesys == "x11"} {
    $c.lfr0 configure -style RoundedLabelFrame
  }

  trace variable pfx_fn w trace_pfx

  return
}

proc saveCert { typesave cont} {
  global macos
  global myHOME
  if {$cont == "" } {
    tk_messageBox -title "Экспорт" -icon info -message "Нечего экспортировать" -parent .
    return
  }

  set typeCertDer {
    {"Экспорт сертификата в DER формате"    .der}
    {"Экспорт сертификата в DER формате"    .cer}
    {"Любой"    *}
  }
  set typeCertPem {
    {"Экспорт сертификата в PEM формате"   .pem}
    {"Экспорт сертификата в PEM формате"    .crt}
    {"Любой"    *}
  }
  set typeP7S {
    {"PKCS#7 в DER-формате"    .p7s}
    {"Любой"    *}
  }
  set typeFileTXT {
    {"Экспорт просматриваемого"   .txt}
    {"Любой"    *}
  }
  set typeFileAll {
    {"Любой"    *}
  }
  set tit "Экспорт сертификата"
  set mbad "Экспорт сертификата не удался в файл"
  set mok "Сертификат сохранен в файле"
  set encodePem $typesave
  set tsav "."
  if { $typesave == 1 } {
    set typeCert [subst $typeCertPem]
    set typeTitle "Экспорт сертификата в PEM формате"
  } elseif { $typesave == 0 } {
    set typeCert [subst $typeCertDer]
    set typeTitle "Экспорт сертификата в DER формате"
  } elseif { $typesave == 2 }  {
    set typeCert [subst $typeFileAll]
    set typeTitle "Экспорт контента"
    set tit "Экспорт контента"
    set mbad "Экспорт контента не удался в файл"
    set mok "Контент сохранен в файле"
  } elseif { $typesave == 3 }  {
    set typeCert [subst $typeP7S]
    set typeTitle "Экспорт TimeStampToken"
    set encodePem 0
  } elseif { $typesave == 4 }  {
    set typeCert [subst $typeFileTXT]
    set typeTitle "Экспорт просматриваемого"
    set tit "Экспорт просматриваемого"
    set mbad "Экспорт просматриваемого не удался в файл"
    set mok "Содержимое сохранено в файле"
    set tsav ".about"
  } else {
    return
  }
  if {$macos} {
    set ft ""
  } else {
    set ft $typeCert
  }

#  set file [tk_getSaveFile -title "$typeTitle"  -filetypes $ft -parent $tsav -initialdir "$myHOME"]
  set file [tk_getSaveFile -title "$typeTitle"  -filetypes $ft -parent $tsav -initialdir $::lastSave]
  if { $file == "" } {
    return;
  }
  set ::lastSave [file dirname $file]

  set x [catch {set fid [open $file w+]}]
  set y [catch {puts $fid "#http://soft.lissi.ru\n"}]
  set z [catch {close $fid}]
  if { $x || $y || $z || ![file exists $file] || ![file isfile $file] || ![file readable $file] } {
    tk_messageBox -parent $tsav -icon error  -message "Невозможно записать сертификат в этот файл:\n \"$file\""
    return
  }
  file delete -force $file
  #Собственно запись в файл
  #Разобраться с PEM
  if {$encodePem == 1} {
    set cert [::pki::_encode_pem $cont "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]
  } else {
    set cert $cont
  }
  set fd [open $file w]
  chan configure $fd -translation binary
  puts -nonewline $fd $cert
  close $fd

  if {![file exists $file]} {
    tk_messageBox -title $tit -icon error -message "$mbad\n $file" -parent $tsav
    return
  }
  if {![file size $file]} {
    tk_messageBox -title $tit -icon error -message "$mbad\n $file" -parent $tsav
    return
  }
  tk_messageBox -title $tit -parent $tsav -icon info  -message "$mok\n\"$file\""
}

proc cafromlist {lurls} {
  foreach c_par $lurls {
    #Выбираем очередной  url
    #адрес корневого сертификата
    #Читаем очередной корневой сертификат
    #puts "readca=$c_par"
    set certca [readca $c_par]
    if {$certca == ""} {
      #Прочитать сертификат не удалось. Ищем следующую точку с сертификатом
      continue
    } else {
      set asndata [cert2der $certca]
      if {[string first "p7b" $c_par] != -1} {
        puts "P7B !!!"
        set tst [parse_pkcs7 "der" "$asndata" ""]
        foreach {tstcerts tstcrls tstp7} $tst {}
        set certtst ""
        foreach tstcert $tstcerts {
          set asndata [binary format H* $tstcert]
          break
        }
      }
      return $asndata
    }
  }
  return ""
}
proc string_to_dn_tc26 {strdn} {
  set dn $strdn
  set namelist {}
  while {1} {
    #puts "DN=$dn"
    set ind [string first "=" $dn]
    if {$ind == -1} {
      break
      set value $dn
    }
    set label [string range $dn 0 $ind-1]
    incr ind
    set ind1 [string first "=" [string range $dn $ind end ]]
    if {$ind1 == -1} {
      set value [string range $dn $ind end ]
      lappend namelist $label $value
      puts "$label:$value"
      break;
    }
    set dn1 [string range $dn 0 $ind+$ind1]
    #puts "DN1=$dn1"
    set ind1 [string last " " $dn1]
    if {$ind1 == -1} {
      set value [string range $dn $ind  end]
    } else {
      set value [string range $dn $ind $ind1-2 ]
      set dn [string range $dn $ind1+1 end]
    }
    #        puts "ПАРА=$label:$value"
    lappend namelist $label $value
    if {$ind1 == -1 } {
      break
    }
  }
  #puts $namelist
  return [list_to_dn_tc26 $namelist]
}

proc string_to_dn_tc26_OLD {strdn} {
  set b [split $strdn "="]
  lappend namelist [string trim [lindex $b 0]]
  set b [lreplace $b 0 0]
  set i 0
  foreach s1 $b {
    set ind [string last "," $s1]
    if {$ind == -1} {
      lappend namelist [string trim $s1]
    } else {
      incr ind -1
      set label [string trim [string range $s1 0 $ind]]
      incr ind +2
      set value [string trim [string range $s1 $ind end]]
      lappend namelist $label $value
    }
    incr i
  }
  return [list_to_dn_tc26 $namelist]
}

proc list_to_dn_tc26 {name} {
  set ret ""
  foreach {oid_name value} $name {
    if {$oid_name == "INN" || $oid_name == "INNLE" || $oid_name == "OGRN" || $oid_name == "OGRNIP" || $oid_name == "SNILS" } {
      set asnValue [::asn::asnNumericString $value]
    } elseif {[string tolower $oid_name] == "email"} {
      set value_em [string map {"@" "A"} $value]
      set ll [string is graph $value_em]
      if {$ll == 1} {
        #			set asnValue [::asn::asnIA5String $value]
        set asnValue [::asn::asnEncodeString 16 $value]
      } else {
        set asnValue [::asn::asnUTF8String $value]
      }
    } elseif {![regexp {[^ A-Za-z0-9'()+,.:/?=-]} $value]} {
      set asnValue [::asn::asnPrintableString $value]
    } else {
      set asnValue [::asn::asnUTF8String $value]
    }

    append ret [::asn::asnSet \
    [::asn::asnSequence \
    [::asn::asnObjectIdentifier [::pki::_oid_name_to_number $oid_name]] \
    $asnValue \
    ] \
    ] \
  }

  return $ret
}

proc create_req_ocsp {cert_user_hex cert_ca_hex} {
  set cert [binary  format H* $cert_user_hex]
  array set parsecert [pki::x509::parse_cert $cert]
  set certca [binary  format H* $cert_ca_hex]
  array set parseca [pki::x509::parse_cert $certca]
  #parray parseca
  catch {set pubkey_algo_number [::pki::_oid_name_to_number $parsecert(pubkey_algo)]}
  if {![info exists pubkey_algo_number]} {
    set pubkey_algo_number $parsecert(pubkey_algo)
  }
  #puts "PUBKEY_ALGO=$pubkey_algo_number"
  switch -- $pubkey_algo_number {
    "1.2.643.7.1.1.1.1" - "1 2 643 7 1 1 1 1" {
      #    "GOST R 34.10-2012-256"
      set digest_algo "stribog256"
      set digest_oid "1 2 643 7 1 1 2 2"
    }
    "1.2.643.7.1.1.1.2" - "1 2 643 7 1 1 1 2" {
      #     "GOST R 34.10-2012-512"
      set digest_algo "stribog512"
      set digest_oid "1 2 643 7 1 1 2 3"
    }
    default {
      puts "Cannot veridy create signature\nUnknown pubkey algo=$pubkey_algo_number"
      return ""
    }
  }
  #    array set infopkuser [pki::pkcs11::pubkeyinfo $cert_user_hex)  [list pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]]
  #    array set infopk [pki::pkcs11::pubkeyinfo $cert_ca_hex)  [list pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]]
  array set infopkuser [pki::pkcs11::pubkeyinfo $cert_user_hex)  ]
  array set infopk [pki::pkcs11::pubkeyinfo $cert_ca_hex) ]
  #  parray infopk
  #От чего считать хэш ключа- включать в состав 0440 или 048180  ВКЛЮЧАТЬ
  set pkca  [binary format H* $infopk(pubkey)]
  if {$infopkuser(issuer) != $infopk(subject)} {
    puts "Bad CA issuer!=subject"
    return ""
  }
  set issueruser [binary format H* $infopk(subject)]
  set issuerNamehash_hex [::pki::pkcs11::dgst $digest_algo $issueruser]
  set issuerNamehash [binary format H* $issuerNamehash_hex]
  set issuerKeyhash_hex [::pki::pkcs11::dgst $digest_algo $pkca]
  set issuerKeyhash [binary format H* $issuerKeyhash_hex]
  #puts "issuerNamehash_hex=$issuerNamehash_hex"
  #puts "issuerKeyhash_hex =$issuerKeyhash_hex"
  #puts $infopk(pubkey)
  set req_ocsp \
  [::asn::asnSequence \
  [::asn::asnSequence \
  [::asn::asnSequence \
  [::asn::asnSequence \
  [::asn::asnSequence \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier $digest_oid] \
  [::asn::asnNull]
  ] \
  [::asn::asnOctetString $issuerNamehash] \
  [::asn::asnOctetString $issuerKeyhash] \
  [binary format H* $infopkuser(serial_number)] \
  ] \
  ] \
  ] \
  ] \
  ]
  return $req_ocsp
}

proc pkcs7_add_unsign {p7s certtst digest_algo} {
  variable createescTS

  #puts "pkcs7_add_unsign=$digest_algo"

  #tk_messageBox -title "Подписание документа" -icon info -message "createescTS=$createescTS"
  if {1} {
    if {$createescTS == 2} {
      #Усли тип подписи CAdES-XLT1
      set unsattrtst [create_unsignattrs [list $certtst $certtst] $digest_algo]
    } else {
      #Усли тип подписи не CAdES-XLT1 (например, CAdES-T и ниже)
      set unsattrtst [create_unsignattrs [list $certtst ""] $digest_algo]
    }
  }
  #  set unsattrtst [create_unsignattrs [list $certtst ""] $digest_algo]
  #  set unsattrtst [create_unsignattrs [list $certtst $certtst] $digest_algo]

  if {[llength $unsattrtst] == 1} {
    tk_messageBox -title "Подписание документа" -icon info -message [mc "Cannot create unsigned attributes for TST=$unsattrtst"] -detail "Возможно надо выбрать другой сервер щтампов времени"
    set list_for_unstst ""
    #		return ""
  } else {
    foreach {tstchain tstchainref tstcrl tstcrlref} $unsattrtst {}
    if {$tstchain != ""} {
      set list_for_unstst [::asn::asnContextConstr 1 \
      $tstcrlref \
      $tstchainref \
      $tstcrl \
      $tstchain \
      ]
    } else {
      tk_messageBox -title "Подписание документа" -icon info -message "Невозможно создать  unsigned attributes для TST\nНет online-доступа к корневому сертификату" -detail "Возможно надо выбрать другой сервер штампов времени"
      set list_for_unstst ""
    }
  }

  asn::asnGetSequence p7s pkcs7
  ::asn::asnGetObjectIdentifier pkcs7 oidSignedData
  ::asn::asnGetContext pkcs7 - asn_cont
  ::asn::asnGetSequence asn_cont asn_cont1
  ::asn::asnPeekByte asn_cont1 peek_tag
  if {$peek_tag == 0x02} {
    # Version number is optional, if missing assumed to be value of 0
    ::asn::asnGetInteger asn_cont1 version
    #puts "VER TST=$version"		
  } else {
    set version 1
    #puts "default TST VER=$version"		
  }
  ::asn::asnGetSet asn_cont1 listdigest
  ::asn::asnGetSequence asn_cont1 context_for_sign
  set asn_cont4 $context_for_sign
  ::asn::asnGetObjectIdentifier asn_cont4 oiddata
  #puts "TST OIDDATA=$oiddata"
  if {[string length $asn_cont4] > 0 } {
    #	    puts "attached signature"
    ::asn::asnGetContext asn_cont4 - octcontext
    ::asn::asnGetOctetString octcontext context
  } else {
    #	    puts "detached signature"
    set context ""
  }

  ::asn::asnGetContext asn_cont1 - cert
  ::asn::asnGetSet asn_cont1 listsigner

  asn::asnGetSequence listsigner signerinfo
  set listsigner [asn::asnSequence $signerinfo \
  $list_for_unstst \
  ]

  set p7_signed [::asn::asnSequence \
  [::asn::asnObjectIdentifier $oidSignedData] \
  [::asn::asnContextConstr 0 \
  [::asn::asnSequence \
  [::asn::asnInteger $version] \
  [::asn::asnSet $listdigest] \
  [::asn::asnSequence $context_for_sign] \
  [::asn::asnSet $listsigner] \
  ] \
  ] \
  ]

  return $p7_signed
}

proc create_new_signer {cert_hex content typekey} {
  global ttt
  variable createTimeStamp
  variable createescTS
  variable varescTS
  global yespas
  global pass
  array set ret [list]
  set listdigest ""
  set listsigner ""
  set cert [binary  format H* $cert_hex]
  array set parsecert [pki::x509::parse_cert $cert]
  #  parray parsecert
  catch {set pubkey_algo_number [::pki::_oid_name_to_number $parsecert(pubkey_algo)]}
  if {![info exists pubkey_algo_number]} {
    set pubkey_algo_number $parsecert(pubkey_algo)
  }
  #puts "PUBKEY_ALGO=$pubkey_algo_number"
  switch -- $pubkey_algo_number {
    "1.2.643.7.1.1.1.1" - "1 2 643 7 1 1 1 1" {
      #    "GOST R 34.10-2012-256"
      set digest_algo "stribog256"
      set digest_oid "1 2 643 7 1 1 2 2"
      set signature_oid "1 2 643 7 1 1 3 2"
      set ckm "CKM_GOSTR3410"
    }
    "1.2.643.7.1.1.1.2" - "1 2 643 7 1 1 1 2" {
      #     "GOST R 34.10-2012-512"
      set digest_algo "stribog512"
      set digest_oid "1 2 643 7 1 1 2 3"
      set signature_oid "1 2 643 7 1 1 3 3"
      set ckm "CKM_GOSTR3410_512"
    }
    default {
      puts "Cannot veridy create signature\nUnknown pubkey algo=$pubkey_algo_number"
      return [array get ret]
    }
  }
  set listdigest1 [::asn::asnSequence \
  [::asn::asnObjectIdentifier $digest_oid] \
  [::asn::asnNull] \
  ]
  set listdigest "$listdigest$listdigest1"
  set aa [dict create pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]
  if {$typekey == "pkcs11"} {
    array set infopk [pki::pkcs11::pubkeyinfo $cert_hex  [list pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]]
  } else {
    array set infopk [pki::pkcs11::pubkeyinfo $cert_hex ]
  }
  #  parray infopk
  # "1 2 840 113549 1 9 16 2 47" - signedtcertv2
  set cert_digest_hex [pki::pkcs11::dgst $digest_algo $cert]
  set cert_digest [binary  format H* $cert_digest_hex]
  set name [binary format H* $infopk(issuer)]
  #Подпись CAdES
  if {$createescTS != -1} {
    set certv2 [::asn::asnSequence \
    [::asn::asnSequence \
    [::asn::asnSequence \
    [::asn::asnSequence \
    [::asn::asnObjectIdentifier $digest_oid] \
    ] \
    [::asn::asnOctetString $cert_digest] \
    [::asn::asnSequence \
    [::asn::asnSequence \
    [::asn::asnContextConstr 4 \
    $name \
    ] \
    ] \
    [::asn::asnBigInteger [math::bignum::fromstr $parsecert(serial_number)]] \
    ] \
    ] \
    ] \
    ]

    set cades [::asn::asnSequence \
    [::asn::asnObjectIdentifier $::::oidsigningCertificateV2] \
    [::asn::asnSet $certv2]  \
    ]

  } else {
    #Подпись PKCS#7
    #set certv2 ""
    set cades ""
  }

  #	set digest_hex    [pki::pkcs11::digest $digest_algo $content  $aa]
  set digest_hex    [pki::pkcs11::dgst $digest_algo $content]
  set digest_content [binary  format H* $digest_hex]

  set list_for_sign [::asn::asnContextConstr 0 \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier $::oidAttributeContentType] \
  [::asn::asnSet \
  [::asn::asnObjectIdentifier $::oidData] \
  ] \
  ] \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier $::oidAttributeSigningTime] \
  [::asn::asnSet \
  [::asn::asnUTCTime [clock format [clock seconds]  -format {%y%m%d%H%M%SZ} -gmt true]] \
  ] \
  ] \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier $::oidAttributeMessageDigest] \
  [::asn::asnSet \
  [::asn::asnOctetString $digest_content] \
  ] \
  ] \
  $cades \
  ]
          	
  #################
  binary scan  $list_for_sign H* listsigner_hex

  #puts "listsigner_HEX=$listsigner_hex"

  set listsigner_for_digest_hex "31[string range $listsigner_hex 2 end]"
  #puts "listsigner_for_digest=$listsigner_for_digest_hex"
  set listsigner_for_digest [binary format H* $listsigner_for_digest_hex]
  #    set digestsign_hex    [pki::pkcs11::digest $digest_algo $listsigner_for_digest  $aa]
  set digestsign_hex    [pki::pkcs11::dgst $digest_algo $listsigner_for_digest ]
  if {$typekey == "pkcs11"} {
    set aa [dict create pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]
    lappend aa "pkcs11_id"
    #CKA_ID сертификата вычисляем по открытому ключу
    if {$::cert_pkcs11_id == ""} {
      lappend aa $infopk(pkcs11_id)
      set ckaid $infopk(pkcs11_id)
    } else {
      #CKA_ID сертификата берем с токенв
      lappend aa $::cert_pkcs11_id
      set ckaid $::cert_pkcs11_id
    }
    #puts "digestsign_hex=$digestsign_hex"
    #puts "digestsign_hex=[string length $digestsign_hex]"
    puts "SIGN=start; $aa"
    #    set sign_content_hex  [pki::pkcs11::sign $ckm $digestsign_hex  $aa]
    set sign_content_hex  [$::tokenls11sw0 signcert $ckm $digestsign_hex  $ckaid]
    #puts "SIGN=$sign_content_hex"
    lappend aa "pubkeyinfo"
    lappend aa $infopk(pubkeyinfo)

    #   if {[catch {set verify [pki::pkcs11::verify $digestsign_hex $sign_content_hex $aa]} res] } {}
    if {[catch {set verify [$::tokenls11sw0 verify $digestsign_hex $sign_content_hex $infopk(pubkeyinfo)]} res] } {
      puts "BEDA=$res"
      return [array get ret]
    }
    if {$verify != 1} {
      puts "BAD SIGNATURE=$verify"
      return ""
    }
    #puts "SIGNATURE OK=$verify"
  } elseif {$typekey == "pkcs12"} {
    set digestsign [binary  format H* $digestsign_hex]
    set lenkey [string length $::private_key_str]
    # generate random bytes for signature
    set rnd_ctx [lrnd_random_ctx_create ""]
    set rnd_bytes [lrnd_random_ctx_get_bytes $rnd_ctx $lenkey]
    if { $lenkey == 32 } {
      set sign_content [lcc_gost3410_2012_256_sign $::group $::private_key_str $digestsign $rnd_bytes]
    } elseif {$lenkey == 64 } {
      set sign_content [lcc_gost3410_2012_512_sign $::group $::private_key_str $digestsign $rnd_bytes]
    } else {
      puts "BAD key=$lenkey"
      return ""
    }
    binary scan  $sign_content H*  sign_content_hex
  } else {
    puts "Bad type storage key=$typekey"
    return ""
  }
  set sign_content [binary  format H* $sign_content_hex]
  set list_for_unsign ""
  if {$createescTS > 0} {
    set stamp ""
    set escstamp ""
    #puts "Первый штамп"
    set tsr [::create_tsq $sign_content $digest_oid]
    #puts "Первый штамп END"
    set url $::tekTSP
    #Проверяем тип протокола
    if { "https://" == [string range $url 0 7]} {
      puts "HTTPS=$url"
      http::register https 443 ::tls::socket
    }
    if {[catch {
      set token [http::geturl $url  -type  "application/timestamp-query" -query  $tsr  -binary 1]
      set stampfull [doneGet $token]

      ::asn::asnGetSequence stampfull stamp

    } error]} {
      puts stderr "Error while getting URL: $error"
      tk_messageBox -title "Новый подписант, TST" -icon error -message "Ошибка при чтении URL:\n$url" -detail $error
      return ""
    }
    #::oidtimeStampToken             "1 2 840 113549 1 9 16 2 14"
    #УБИРАЕМ ВЕРСИЮ ???
    ::asn::asnGetSequence stamp version
    if {[string length $stamp] == 0} {
      tk_messageBox -title "Новый подписант, TST"  -icon error -message  "Получили пустой штамп времени"  -detail "URL:$url"
      return ""
    }
    #Ищем издателя TST
    set tst [parse_pkcs7 "der" "$stamp" ""]
    foreach {tstcert tstcrls tstp7} $tst {}
    set certtst ""
    foreach tstp7t $tstp7 {
      #puts "P7=$p7t"
      array set tp7 $tstp7t
      set certtst $tp7(cert_hex)
      #parray tp7
    }
                    	
    #Цепочка сертификатов и crl для TST
    #puts "TST add UNSIGN=$digest_algo"
    set stamp [pkcs7_add_unsign $stamp $certtst $digest_algo]
    #puts "TST add UNSIGN END"

    #Упаковываем штамп времени TST
    set tspstamp [::asn::asnSequence \
    [::asn::asnObjectIdentifier $::oidtimeStampToken] \
    [::asn::asnSet $stamp ] \
    ]

    #Цепочка сертификатов и crl
    set unsignattrs [create_unsignattrs [list $cert_hex $certtst] $digest_algo]
    if {[llength $unsignattrs] == 1} {
      tk_messageBox -title "Подписание документа" -icon info -message "Проблеиы с OSCP-сервером ($unsignattrs)" -parent .
      return ""
    }
    foreach {lchain lchainref lcrl lcrlref} $unsignattrs {}

    set esctspstamp  ""
    if {$createescTS == 2} {
      if {$lchainref == "" } {
        tk_messageBox -title "Подписание документа" -icon info -message [mc "No certificate chain"]
        return ""
      }
                              	
      #Второй штамр
      set cont2esc $sign_content
      ::asn::asnGetSequence tspstamp temp
      append cont2esc $temp
      set tspstamp [::asn::asnSequence $temp]
      ::asn::asnGetSequence lchainref temp
      append cont2esc $temp
      set lchainref [::asn::asnSequence $temp]
      ::asn::asnGetSequence lcrlref temp
      append cont2esc $temp
      set lcrlref [::asn::asnSequence $temp]
      set escstamp ""
      #puts "Второй штамп"
      set esctsr [::create_tsq $cont2esc $digest_oid]
      #puts "Второй штамп END"
      set url $::tekTSP
      #Проверяем тип протокола
      if { "https://" == [string range $url 0 7]} {
        puts "HTTPS=$url"
        http::register https 443 ::tls::socket
      }
      if {[catch {
        set token [http::geturl $url  -type  "application/timestamp-query" -query  $esctsr  -binary 1]
        #		http::wait $token
        #             -timeout 300000
        #puts "GETURL END 2"
        set escstampfull [doneGet $token]
        ::asn::asnGetSequence escstampfull escstamp
      } error]} {
        puts stderr "Error while getting URL: $error"
        tk_messageBox -title [mc "Create new signer, escTS"] -icon error -message [mc "Error while getting URL:\n$url"] -detail $error
        return ""
      }
      # ::oidesctimeStamp           "1 2 840 113549 1 9 16 2 25"
      #УБИРАЕМ ВЕРСИЮ У esc???
      ::asn::asnGetSequence escstamp version

      set esctspstamp [::asn::asnSequence \
      [::asn::asnObjectIdentifier $::oidesctimeStamp] \
      [::asn::asnSet $escstamp ] \
      ]
    }

    set list_for_unsign [::asn::asnContextConstr 1 \
    $lcrlref \
    $lchainref \
    $esctspstamp \
    $lcrl \
    $tspstamp \
    $lchain \
    ]

  }

  #################

  set listsigner1 [::asn::asnSequence \
  [::asn::asnInteger 1] \
  [::asn::asnSequence \
  $name \
  [::asn::asnBigInteger [math::bignum::fromstr $parsecert(serial_number)]] \
  ] \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier $digest_oid] \
  [::asn::asnNull] \
  ] \
  $list_for_sign \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier $pubkey_algo_number] \
  ] \
  [::asn::asnOctetString $sign_content] \
  $list_for_unsign \
  ]
  set listsigner "$listsigner$listsigner1"
  set ret(listsigner) $listsigner
  set ret(listdigest) $listdigest
  return [array get ret]
}

proc ::pki::pkcs7_add_signeddata {content cert_hex typesign p7s_hex} {
  #puts "P7S_HEX=$p7s_hex"
  set p7s [binary  format H* $p7s_hex]
  asn::asnGetSequence p7s pkcs7
  ::asn::asnGetObjectIdentifier pkcs7 oidSignedData
  ::asn::asnGetContext pkcs7 - asn_cont
  ::asn::asnGetSequence asn_cont asn_cont1
  ::asn::asnPeekByte asn_cont1 peek_tag
  if {$peek_tag == 0x02} {
    # Version number is optional, if missing assumed to be value of 0
    ::asn::asnGetInteger asn_cont1 version
    #puts "VER=$version"		
  } else {
    set version 1
    #puts "default VER=$version"		
  }
  ::asn::asnGetSet asn_cont1 listdigest
  ::asn::asnGetSequence asn_cont1 context_for_sign
  set asn_cont4 $context_for_sign
  ::asn::asnGetObjectIdentifier asn_cont4 oiddata
  #puts "OIDDATA=$oiddata"
  if {[string length $asn_cont4] > 0 } {
    #	    puts "attached signature"
    ::asn::asnGetContext asn_cont4 - octcontext
    ::asn::asnGetOctetString octcontext context
    #puts "CONTEXT=$context"		
    if  {$context != $content} {
      puts "Bad content!!!!"
      return 0
    }
  } else {
    #	    puts "detached signature"
    set context $content
  }

  ::asn::asnGetContext asn_cont1 - cert
  ::asn::asnGetSet asn_cont1 listsigner

  array set addsigner [create_new_signer $cert_hex $context "pkcs11"]
  if {![info exists addsigner(listdigest)]} {
    #Что-то плохо с добавлением
    #    puts "Cannot add signer (digest)"
    tk_messageBox -title "Добавить новую подпись" -icon error -message "Невозможно добавить подпись" -detail "Неподдерживаемый тип ключа"
    return 0
  }
  if {![info exists addsigner(listsigner)]} {
    #Что-то плохо с добавлением
    #	    puts "Cannot add signer (signer)"
    tk_messageBox -title "Добавить новую подпись" -icon error -message [mc "Cannot add signer (signer)"]
    return 0
  }
  #puts "OK for ADD"
  set certnew [binary  format H* $cert_hex]

  set p7_signed [::asn::asnSequence \
  [::asn::asnObjectIdentifier $oidSignedData] \
  [::asn::asnContextConstr 0 \
  [::asn::asnSequence \
  [::asn::asnInteger $version] \
  [::asn::asnSet $listdigest$addsigner(listdigest)] \
  [::asn::asnSequence $context_for_sign] \
  [::asn::asnContextConstr 0 $certnew$cert] \
  [::asn::asnSet $listsigner$addsigner(listsigner)] \
  ] \
  ] \
  ]

  return $p7_signed
}

proc ocspfromcert {cert_hex} {
  set asndata [binary  format H* $cert_hex]
  if {$asndata == "" } {
    #    puts "ocspfromcert=not cert"
    return [list {} {}]
  }
  array set cert_parse [::pki::x509::parse_cert $asndata]
  array set extcert $cert_parse(extensions)
  if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} {
    #В сертификате нет расширений
    #    puts "ocspfromcert=not extend"
    return [list {} {}]
  }

  set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0]

  #Читаем ASN1-последовательность расширения в Hex-кодировке
  set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1]
  #Переводим в двоичную кодировку
  set chain [binary format H* $b]


  set ret {}
  ::asn::asnGetSequence chain c_par_first
  set caissuer {}
  set servocsp {}
  while {[string length $c_par_first] > 0 } {
    #Выбираем очередную последовательность (sequence)
    ::asn::asnGetSequence c_par_first c_par
    #Выбираем oid из последовательности
    ::asn::asnGetObjectIdentifier c_par c_type
    set tas1 [::pki::_oid_number_to_name $c_type]
    #Выбираем установленное значение
    ::asn::asnGetContext c_par c_par_two
    #Ищем oid с адресом корневого сертификата
    if {$tas1 == "1.3.6.1.5.5.7.48.2" } {
      #Читаем очередной корневой сертификат
      lappend caissuer $c_par
      #	    puts "CA (oid=$tas1)=$c_par"
    } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } {
      lappend servocsp $c_par
      #	    puts "OCSP server (oid=$tas1)=$c_par"
    }
  }
  # Цепочка закончилась
  return [list $caissuer $servocsp]
}



proc chainfromcert {cert dir} {
  variable chaincerts
  global count
  if {$cert == "" } {
    puts "XAend=not cert"
    return
  }
  set asndata [cert2der $cert]
  if {$asndata == "" } {
    #Файл содержит все что угодно, только не сертификат
    puts "XAend=bad CRL"
    return -1
  }
  array set cert_parse [::pki::x509::parse_cert $asndata]
  array set extcert $cert_parse(extensions)
  if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} {
    #В сертификате нет расширений
    puts "XAend=bad CRL 1"
    return 0
  }

  set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0]
  #Читаем ASN1-последовательность расширения в Hex-кодировке
  set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1]
  #Переводим в двоичную кодировку
  set c [binary format H* $b]
  #Sequence 1.3.6.1.5.5.7.1.1
  ::asn::asnGetSequence c c_par_first
  #Цикл перебора значений в засширении 1.3.6.1.5.5.7.1.1
  while {[string length $c_par_first] > 0 } {
    #Выбираем очередную последовательность (sequence)
    ::asn::asnGetSequence c_par_first c_par
    #Выбираем oid из последовательности
    ::asn::asnGetObjectIdentifier c_par c_type
    set tas1 [::pki::_oid_number_to_name $c_type]
    #Выбираем установленное значение
    ::asn::asnGetContext c_par c_par_two
    #Ищем oid с адресом корневого сертификата
    if {$tas1 == "1.3.6.1.5.5.7.48.2" } {
      #Читаем очередной корневой сертификат
      #puts "readca=$c_par"
      set certca [readca $c_par]
      if {$certca == ""} {
        #Прочитать сертификат не удалось. Ищем следующую точку с сертификатом
        continue
      } else {
        #Сохраняем корневой сертификат в указанном каталоге
        if {$dir != ""} {
          set f [file join $dir [file tail $c_par]]
          set fd [open $f w]
          chan configure $fd -translation binary
          puts -nonewline $fd $certca
          close $fd
          lappend ::listcert $f
        } else {
          set asndata [cert2der $certca]
          if {[string first "p7b" $c_par] != -1} {
            puts "P7B !!!"
            set tst [parse_pkcs7 "der" "$asndata" ""]
            #puts "P7B parse_pkcs7 END"
            foreach {tstcerts tstcrls tstp7} $tst {}
            set certtst ""
            foreach tstcert $tstcerts {
              set asndata [binary format H* $tstcert]
              break
            }
          }
          append chaincerts $asndata
          set certca $asndata
        }
        incr count
        #		puts "cert $count from $c_par"
        #ПОДЫМАЕМСЯ по ЦЕПОЧКЕ СЕРТИФИКАТОВ ВВЕРХ
        chainfromcert $certca $dir
        continue
      }
    } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } {
      #	    puts "OCSP server (oid=$tas1)=$c_par"
    }
  }
  # Цепочка закончилась
  #puts "XAend=$count"
  return $count
}


proc chaincafromcert {cert} {
  variable chainca
  global count
  if {$cert == "" } {
    return $chainca
  }
  set asndata [cert2der $cert]
  #    set asndata $cert
  if {$asndata == "" } {
    #Файл содержит все что угодно, только не сертификат
    return $chainca
  }
  array set cert_parse [::pki::x509::parse_cert $asndata]
  array set extcert $cert_parse(extensions)
  if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} {
    #В сертификате нет расширений
    return $chainca
  }

  set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0]
  #Читаем ASN1-последовательность расширения в Hex-кодировке
  set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1]
  #Переводим в двоичную кодировку
  set c [binary format H* $b]
  #Sequence 1.3.6.1.5.5.7.1.1
  ::asn::asnGetSequence c c_par_first
  #Цикл перебора значений в засширении 1.3.6.1.5.5.7.1.1
  while {[string length $c_par_first] > 0 } {
    #Выбираем очередную последовательность (sequence)
    ::asn::asnGetSequence c_par_first c_par
    #Выбираем oid из последовательности
    ::asn::asnGetObjectIdentifier c_par c_type
    set tas1 [::pki::_oid_number_to_name $c_type]
    #Выбираем установленное значение
    ::asn::asnGetContext c_par c_par_two
    #Ищем oid с адресом корневого сертификата
    if {$tas1 == "1.3.6.1.5.5.7.48.2" } {
      #Читаем очередной корневой сертификат
      #puts "readca=$c_par"
      set certca [readca $c_par]
      if {$certca == ""} {
        #Прочитать сертификат не удалось. Ищем следующую точку с сертификатом
        continue
      } else {
        #Сохраняем корневой сертификат в списке
        set asndata [cert2der $certca]
        if {[string first "p7b" $c_par] != -1} {
          #			puts "P7B !!!"
          set tst [parse_pkcs7 "der" "$asndata" ""]
          #puts "P7B parse_pkcs7 END"
          foreach {tstcerts tstcrls tstp7} $tst {}
          set certtst ""
          foreach tstcert $tstcerts {
            set asndata [binary format H* $tstcert]
            break
          }
        }
        lappend chainca $asndata
        set certca $asndata
        #ПОДЫМАЕМСЯ по ЦЕПОЧКЕ СЕРТИФИКАТОВ ВВЕРХ
        chaincafromcert $certca
        continue
      }
    } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } {
      #	    puts "OCSP server (oid=$tas1)=$c_par"
    }
  }
  # Цепочка закончилась
  return $chainca
}

proc readca {url} {
  set cer ""
  #Проверяем тип протокола
  if { "https://" == [string range $url 0 7]} {
    puts "HTTPS=$url"
    http::register https 443 ::tls::socket
  }
  #Читаем сертификат в бинарном виде
  if {[catch {set token [http::geturl $url -binary 1]
    #получаем статус выполнения функции
    #	http::wait $token
    set ere [http::status $token]
    if {$ere == "ok"} {
      #Получаем код возврата с которым был прочитан сертификат
      set code [http::ncode $token]
      if {$code == 200} {
        #Сертификат успешно прочитан и будет созвращен
        set cer [http::data $token]
      } elseif {$code == 301 || $code == 302} {
        #Сертификат перемещен в другое место, получаем его
	array set mm [http::meta $token]
#parray mm
        if {[info exists mm(location)]} {
#    	    set newURL [dict get [http::meta $token] "location"]
    	    set newURL $mm(location)
        } elseif {[info exists mm(Location)]} {
#    	    set newURL [dict get [http::meta $token] "Location"]
    	    set newURL $mm(Location)
        } 
        #puts "newURL=$newURL"
        #Читаем сертификат с другого сервера
        set cer [readca $newURL]
      } else {
        #Сертификат не удалось прочитать
        set cer ""
      }
    }
  } error]} {
    #Сертификат не удалось прочитать, нет узла в сети
    set cer ""
  }
  return $cer
}

proc ::loadchain {cert type} {
  global count
  global typesys
  global loadfile
  global myHOME
  set chaincert {}

  if {$cert == "" } {
    tk_messageBox -title "Загрузка цепочки сертификатов" -icon info -message "Сертификат не выбран"
    return -1
  }
  set data $cert
  set dir [tk_chooseDirectory -initialdir $myHOME -title "Выбор каталога для цепочки"]
  if {$typesys == "win32" } {
    if { "after#" == [string range $dir 0 5] } {
      set dir ""
    }
  }
  if {$dir == ""} {
    return ""
  }
  set ::listcert {}
  set count 0
  set depth [chainfromcert $data $dir]
  #    puts "DEPTH=$depth"
  #    puts $::listcert
  if {$depth == -1} {
    puts "Bad file with certificate=$file"
    return ""
  }
  set lenchain [llength $::listcert]
  set a ""
  set a "Файпы с сертификатами УЦ:\n\n"
  set caforver ""
  foreach b $::listcert {
    set caforver $b
    set a "$a  $b\n"
  }
  if {$type == "chain"} {
    tk_messageBox -title "Загрузка цепочки сертификатов" -icon info -message "Длина цепочки сертификатов УЦ - $lenchain" -detail $a
  }
  return $::listcert
}

proc ::verifysign {cert type} {
  global pass
  global yespas
  global nickTok
  global myHOME
  global macos
  variable nickCert
  #  if {$::pkcs11_module == ""} {
  #    tk_messageBox -title "Проверка подписи" -icon error -message "Выберите библиотеку PKCS#11 для токена"
  #    return -1
  #  }
  if {$type == "file"} {

    set fd [open $cert]
    chan configure $fd -translation binary
    set data [read $fd]
    close $fd
    set asndata [cert2der $data]
  } elseif {$type == "pkcs11"} {
    set asndata [binary format H* $cert]
  }
  if {$asndata == "" } {
    tk_messageBox -title "Проверка сертификата" -icon error -message "Файл $cert" -detail "Выбранный файл не содержит сертификата"
    return -1
  }

  if {[catch {array set cert_parse [::pki::x509::parse_cert $asndata]} rc]} {
    if {$type == "file"} {
      tk_messageBox -title "Проверка сертификата" -icon error -message "$cert" -detail "Выбранный файл не содержит сертификата"
      return -1
    } else {
      tk_messageBox -title "Проверка сертификата" -icon error -message "$nickCert" -detail "Выбранный nick не связан с сертификатом"
      return -1
    }
  }
  set cert_user $asndata
  set lcaforver [::loadchain $cert_user "ver"]
  if {$::pkcs11_module == ""} {
    tk_messageBox -title "Проверка подписи" -icon info -message "Выберите библиотеку PKCS#11 для токена\nЦепочка сертификатов сохранена в указанной вами папке" -detail "Проверка подписи невозможна."
    return -1
  }

  binary scan  $asndata H*  cert_hex
  #  array set infopk [pki::pkcs11::pubkeyinfo $cert_hex  [list pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]]
  if {[info command $::tokenls11sw0] == ""} {
    tk_messageBox -title "Проверка подписи" -icon info -message "Нет подключенного токена" -parent .
    return -1
  }
  array set infopk [$::tokenls11sw0 pubkeyinfo $cert_hex ]
  set cert_parse(pubkeyinfo) $infopk(pubkeyinfo)
  set ::tekcert "file"
          	

  set caforver [lindex $lcaforver 0]
  #puts "caforver=$caforver"
  if {$caforver == "" } {
    #	if {$cert_parse(issuer) == $cert_parse(subject)} {}
    if {$cert_parse(issuer) != $cert_parse(issuer)} {
      set ms "Это корневой самоподписанный сертификат"
      set dt "Валидность самоподписанного сертификата определяется владельцем"
      tk_messageBox -title "Проверка подписи" -icon info -message $ms -detail $dt
      set cert_CA $cert_user
    } else {
      set message "Невозможно загрузить сертификат издателя\nВы укажите файл с сертификатом издателя ?"
      set answer [tk_messageBox -icon question \
      -message $message \
      -title "Загрузка сертификата УЦ" \
      -detail "Невозможно проверить подпись сертификата" \
      -type yesno]

      if {$answer != "yes"} {
        return 0
      }
      set typeFile {
        {"Сертификат в DER формате"    .der}
        {"Сертификат в DER формате"    .cer}
        {"Сертификат в PEM формате"    .pem}
        {"Сертификат в PEM формате"    .crt}
        {"Любой формат"    *}
      }
      set typeFile [subst $typeFile]
      set titleS "Выбор файла с сертификатом УЦ"
      if {$macos} {
        set ft ""
      } else {
        set ft $typeFile
      }

      set caforver [tk_getOpenFile -title $titleS -filetypes $ft -initialdir $::lastDoc]
      if {$caforver == ""} {
        return 0
      }
      set ::lastDoc [file dirname $caforver]
      
      set fd [open $caforver]
      chan configure $fd -translation binary
      set data [read $fd]
      close $fd
      set cert_CA [cert2der $data]
      set lcaforver $caforver
    }
  } else {
    set fd [open $caforver]
    chan configure $fd -translation binary
    set data [read $fd]
    close $fd
    set cert_CA [cert2der $data]
  }
  array set cert_parse_user [::pki::x509::parse_cert $cert_user]
  array set cert_parse_CA [::pki::x509::parse_cert $cert_CA]
  if {![info exists cert_parse_CA]} {
    tk_messageBox -title "Проверка подписи" -icon error -message "Плохой сертификат УЦ=$caforver"
    return
  }
  #Проверяем издателя
  if {$cert_parse_user(issuer) != $cert_parse_CA(subject)} {
    tk_messageBox -title "Проверка подписи" -icon info -message "Может быть Чужой сертификат УЦ=$caforver" \
    -detail "\"$cert_parse_user(issuer)\" != \"$cert_parse_CA(subject)\""
    #	return
  }


  set aa [dict create pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]
  set tbs_cert [binary format H* $cert_parse_user(cert)]
  #puts "SIGN_ALGO1=$cert_parse(signature_algo)"
  catch {set signature_algo_number [::pki::_oid_name_to_number $cert_parse_user(signature_algo)]}
  if {![info exists signature_algo_number]} {
    set signature_algo_number $cert_parse_user(signature_algo)
  }
  #puts "SIGN_ALGO=$signature_algo_number"
  switch -- $signature_algo_number {
    "1.2.643.2.2.3" - "1 2 643 2 2 3" {
      #    "GOST R 34.10-2001 with GOST R 34.11-94"
      set digest_algo "gostr3411"
    }
    "1.2.643.7.1.1.3.2" - "1 2 643 7 1 1 3 2" {
      #     "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256"
      set digest_algo "stribog256"
    }
    "1.2.643.7.1.1.3.3" - "1 2 643 7 1 1 3 3" {
      #    "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512"
      set digest_algo "stribog512"
    }
    default {
      tk_messageBox -title "Проверка подписи" -icon info -message "Невозможно проверить подпись" -detail "Неизвестный алгоритм подписи:\n\t$signature_algo_number" -parent .
      return
    }
  }
  #Проверка наличия механизмов
  set llmech [pki::pkcs11::listmechs $::handle $::slotid_tek]
  switch -- $digest_algo {
    stribog256 {
      set err [string first "0xD4321012" $llmech]
    }
    stribog512 {
      set err [string first "0xD4321013" $llmech]
    }	
    gostr3411 {
      set err [string first "0x1210" $llmech]
    }	
    default {
      set err -1
    }
  }
  if {$err == -1} {
    tk_messageBox -title "Проверка подписи" -icon info -message "Неподдерживаемый алгоритм/меанизм" -detail "$digest_algo\n$signature_algo_number"
    return -1
  }

  #Посчитать хэш от tbs-сертификата!!!!
  set digest_hex    [$::tokenls11sw0 digest $digest_algo $tbs_cert]
  #Получаем asn-структуру публичного ключа
  #Создаем список ключевых элементов

  binary scan $cert_CA H* cert_CA_hex
  array set infopk [pki::pkcs11::pubkeyinfo $cert_CA_hex  [list pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]]

  #Цепочка
  set lca ""
  set lenchain 0
  foreach b $lcaforver {
    set lca "$lca  $b\n"
    incr lenchain
  }
  set lenchain [llength $lcaforver]
  if {[catch {set verify [$::tokenls11sw0 verify $digest_hex $cert_parse_user(signature) $infopk(pubkeyinfo)]} res] } {
    tk_messageBox -title "Проверка подписи" -icon info -message "Невозможно проверить подпись\n" -detail $res
    return -1
  }
  if {$verify != 1} {
    tk_messageBox -title "Проверка подписи" -icon info -message "Подпись сертификата" -detail "Электронная подпись плохая"
  } else {
    tk_messageBox -title "Проверка подписи" -icon info -message "Электронная подпись математически корректная" -detail "Длина цепочки сертификатов - $lenchain\n$lca"
  }
  return $verify
}

proc ::renamecert {pkcs11_id} {
  global yespas
  global pass
  variable nickCert
  if {[llength $::listx509] < 1} {
    return
  }
  #    puts "RENAMECERT nickTok=$::slotid_teklab"
  #Ввод МЕТКИ
  set yespas ""
  set pass ""

  tk busy hold ".st.fr1"
  tk busy hold ".st.fr3"
  place .topPinPw -in .st.fr1.fr2_certs.labCert  -relx 1.0 -rely 3.0 -relwidth 3.5

  set lpas $::labpas
  set ::labpas  "Введите метку для сертификата"
  pack forget .topPinPw.labFrPw.entryPw
  pack forget .topPinPw.labFrPw.butPw
  pack forget .topPinPw.labFrPw.butOk
  pack .topPinPw.labFrPw.entryLb -fill x -expand 1 -padx 5 -pady 5  -ipady 2
  pack .topPinPw.labFrPw.butPw .topPinPw.labFrPw.butLbOk -pady {0 5} -sid right -padx 5

  .topPinPw.labFrPw.entryLb insert end  $nickCert

  focus .topPinPw.labFrPw.entryLb
  set yespas ""
  vwait yespas
  pack forget .topPinPw.labFrPw.entryLb
  pack forget .topPinPw.labFrPw.butPw
  pack forget .topPinPw.labFrPw.butLbOk
  pack .topPinPw.labFrPw.entryPw -fill x -expand 1 -padx 5 -pady 5  -ipady 2
  pack .topPinPw.labFrPw.butPw .topPinPw.labFrPw.butOk -pady {0 5} -sid right -padx 5
  .topPinPw.labFrPw.entryLb delete 0 end
  .topPinPw.labFrPw.entryPw delete 0 end
  .topPinPw.labFrPw.entryPw configure -show *
  set ::labpas $lpas
  place forget .topPinPw
  tk busy forget ".st.fr1"
  tk busy forget ".st.fr3"

  if { $yespas == "no" } {
    return
  }
  set newlab $pass
  set yesno "no"
  if {![$::tokenls11sw0 rename all $pkcs11_id $newlab]} {
    tk_messageBox -title "Переименовать" -icon error -message "Сменить метку сертификата \n$pkcs11_id\n неудалось"
    return
  }
  tk_messageBox -title "Переименовать" -icon info -message "Новая Метка сертификата \n$pkcs11_id" -detail "$newlab"
  ::updatecert
}

proc ::workOpCertP11 {opnum} {
  global yespas
  global pass
  variable nickCert
  set c ".st.fr1.fr2_list4"
  #    puts "WORKOP:c=$c"
  set i 0
  if {$nickCert == ""} {
    tk_messageBox -title "Работа с сертификатом" -icon error -message "Не выбран сертификат на токене" -parent .
    return
  }
  if {![info exists ::certs_p11($nickCert)]} {
    #  if {[llength $::certs_p11] < 1} {}
    tk_messageBox -title "Работа с сертификатом" -icon error -message "Сертификаты отсутствуют на токене" -parent .
    return
  }
  set cert_derhex ""
  set saveCert ".st.fr1.fr2_certs"
  set ind [$saveCert.listCert current]
  set nick  [lindex $::listx509 $ind]

  set cert_derhex [lindex $::certs_p11($nickCert) 0]
  set ckaid [lindex $::certs_p11($nick) 1]
  #parray cert_parse_der
  if {$cert_derhex == ""} {
    tk_messageBox -title "Работа с сертификатом" -icon error -message "Проблемы с сертификатом на токене" -parent .
    return
  }

  switch $opnum {
    0 {
      puts "opnum=$opnum"
      set err [verifysign $cert_derhex "pkcs11"]
      #	    puts "CERIFYSYGN=$err"
      return
    }
    1 {
      #    puts "opnum=$opnum"
      loadcrl $cert_derhex 0
    }
    2 {
      set certder [binary format H* $cert_derhex]
      saveCert 1 $certder
      return
    }
    3 {
      set certder [binary format H* $cert_derhex]
      saveCert 0 $certder
      return
    }
    4 {
      #    puts "opnum=$opnum"
      #Удалить сертификат с токена
      set lists [listts $::handle]
      if {[llength $lists] == 0} {
        tk_messageBox -title [mc "Delete certificate"] -icon info -message "[mc {Tokens not present}]\n"
        return
      }
      set find 0
      foreach {lab token_slotid} $lists {
        if {$lab == $::slotid_teklab } {
          set find 1
          break
        }
      }
      if {$find == 0} {
        tk_messageBox -title [mc "Delete certificate"] -icon info -message "[mc {Token not find}]: $::slotid_teklab\n"
        return
      }
      set answer [tk_messageBox -icon question -message "Удалить ключевую пару\nДа/Нет?" -title "Удаление" -type yesno]
      if {$answer != "yes"} {
        $::tokenls11sw0 delete cert $ckaid
        #		pki::pkcs11::logout $::handle $token_slotid
      } else {
        $::tokenls11sw0 delete all $ckaid
      }
      set dcert $nickCert
      ::updatecert
      tk_messageBox -icon info -message "Сертификат\n$dcert\nудален с токена\n" -title "Удаление сертификата"
      return
    }
    4 {
      puts "opnum=$opnum"
                              	
    }
    5 {
      ::renamecert $ckaid
      return
    }
    default {
      puts "workOpCertP11: Unknown operation=$opnum"
    }
  }
}

proc ::workOpCert {} {
  global yespas
  global pass
  variable src_fn
  variable opcert
  variable cert_fn
  variable nickCert
  set c ".st.fr1.fr2_list4"
  #    puts "WORKOP:c=$c"
  set i 0
  if {$cert_fn == ""} {
    tk_messageBox -title "Работа с сертификатом" -icon error -message "Не выбран файл с сертификатом" -parent .
    return
  }
  set fd [open $cert_fn]
  chan configure $fd -translation binary
  set data [read $fd]
  close $fd
  set asndata [cert2der $data]
  if {$asndata == "" } {
    puts "Bad file with certificate=$file"
    return
  }
  binary scan $asndata H* cert_hex

  switch $opcert {
    0 {
      #    puts "opcert=$opcert"
      set err [verifysign $cert_fn "file"]
      puts "CERIFYSYGN=$err"
      return
    }
    1 {
      #    puts "opcert=$opcert"
      loadcrl $cert_hex 0
    }
    2 {
      ::viewCert "file" $cert_fn
    }
    3 {
      #    puts "opcert=$opcert"
      set err [verifysign $cert_fn "file"]
      if {$err == 0} {
        #Передумали
        return
      }
      if {$err != 1} {
        #		tk_messageBox -title [mc "Работа с сертификатом"] -icon error -message [mc "Сертификат не прошел проверку"] -parent .
        return
      }
      #DER в бинарнике
      if {[catch {array set cert_parse [::pki::x509::parse_cert $asndata]} rc]} {
        tk_messageBox -title "Загрузка сертификата" -icon error -message "$cert_fn" -detail "Выбранный файл не содержит сертификата"
        return
      }
      set id_new_hex ""
      if {$::certegais == 1} {
        set tekt [clock format [clock seconds] -format {%y%m%d%H%M}]
        set labcert [nickforegais $cert_parse(subject)]

        if {$labcert == "" } {
          tk_messageBox -title "Загрузка сертификата" -icon error -message "$tekt \n$cert_fn" -detail "Выбранный файл не содержит сертификата для ЕГАИС"
          return
        }
        #		set labcert "$tekt-$labcert"
        #		puts "LABCERT_0=$labcert"
        set labcert [string trimleft $labcert "0"]
        set labcert "-$labcert"
        #		puts "LABCERT=$labcert"
      } else {
        set labcert [createnick $cert_parse(issuer) $cert_parse(subject)]
      }
      ############Проверяем наличие сертификата на токене по классике и как у ЕГАИС-а##################
      array set infopk [$::tokenls11sw0 pubkeyinfo $cert_hex) ]
      set allobjs [$::tokenls11sw0 listobjects  "cert"]

      #    catch {::pki::pkcs11::logout $::handle $::slotid_tek}
      set cert 0
      #puts "LABCERT_1=$labcert"
      binary scan $labcert H* labcert_hex
      #puts "LABCERT_1_hex=$labcert_hex"
      foreach obj $allobjs {
        foreach {type handle label id} $obj {
          #puts "LabPrKey=$label"
          #puts "LabPrKey id=$id"
          set id_len [string length $id]
          if {$id_len == 40} {
            if {$id == $infopk(pkcs11_id)} {
              set cert 1
              break
            }
          } else {
            if {[string first $labcert_hex $id] != -1} {
              set cert 1
              break
            }
          }
        }
        if {$cert == 1 } {
          break
        }
      }
      if {$cert == 1} {
        tk_messageBox -title "Импорт сертификата" -icon info -message "Сертификат уже уствновлен:\n\"$labcert\"" \
        -detail "Если вы хотите его переустановить, что сначало удалите старый экземпляр"
        return
      }

      ################################################
      if {$::certegais != 1} {
        if {[catch {set pkcs11id [$::tokenls11sw0 importcert $cert_hex $labcert ]} res] } {
          tk_messageBox -title "Импорт сертификата" -icon info -message "Сертификат уже уствновлен:\n\"$labcert\"" \
          -detail "Если вы хотите его переустановить, что сначало удалите старый экземпляр"
          return
        }
        $::tokenls11sw0 rename all $pkcs11id $labcert
        set id_new_hex $pkcs11id
        #puts "Установлена метка $labcert"
      } else {
        ########
        #Получаем метку ключа, которая станет новым CKA_ID тройки
        set allobjs [$::tokenls11sw0 listobjects "privkey"]
        set prkey 0
        puts "LABCERT_1=$labcert"
        foreach obj $allobjs {
          foreach {type handle label id} $obj {
            puts "LabPrKey=$label"
            puts "LabPrKey id=$id"
            set id_len [string length $id]
            if {$id_len == 40} {
              if {$id == $infopk(pkcs11_id)} {
                set prkey 1
                binary scan $label H* id_new_hex
                break
              }
            } else {
              if {[string first $labcert $label] != -1} {
                set prkey 1
                binary scan $label H* id_new_hex
                break
              }
            }
          }
          if {$prkey == 1} {
            break
          }
        }
        if {$prkey == 0} {
          $::tokenls11sw0 delete cert $pkcs11id
          tk_messageBox -title "Импорт сертификата" -icon info -message "Нет закрытого ключа на этом токене\n для вашего сертификата" \
          -detail "Сертификат не установлен\nЕсли вы все же хотите его установить, снимите пометку\n \"Сертификат для ЕГАИС\""
          return
        }
        if {[catch {set pkcs11id [$::tokenls11sw0 importcert $cert_hex $label]} res] } {
          tk_messageBox -title "Импорт сертификата" -icon info -message [mc "Cannot import this certificate\n"] -detail $res
          return
        }
        #Сделать в классе команду change-ckaid
        $::tokenls11sw0 rename $pkcs11id "Certificate"
        #        puts "LabPrKey id old=$pkcs11id"
        #        puts "LabPrKey id_new=$id_new_hex"
        ########
        $::tokenls11sw0 changeid $pkcs11id $id_new_hex
        set labcert "Certificate"
      }
      ::updatecert
      set cnfromca [createnick $cert_parse(issuer) $cert_parse(subject)]
      tk_messageBox -title "Импорт сертификата" -icon info -message "Сертификат \n$cnfromca\nимпортирован на токен:\n$::slotid_teklab" \
      -detail "Метка сертификата (CKA_LABEL):\n$labcert\nCKA_ID (hex-формат):\n$id_new_hex"
      return
    }
    default {
      puts "Unknown operation=$opcert"
    }
  }
}

proc ::workOpP12 {} {
  variable friendly
  variable src_fn
  variable top12
  variable exp12
  variable ts12
  variable cert_fn
  variable nickCert
  set c ".st.fr1.fr2_list8"
  puts "WORKOpP12:top12=$top12;typesave=$ts12"
  set i 0
  if {$::certfrompfx == ""} {
    tk_messageBox -title "Работа с PKCS12" -icon error -message "Не выбран файл с контейнером" -parent .
    return
  }
  set cert_hex $::certfrompfx

  switch $top12 {
    0 {
      #    puts "opcert=$opcert"
      set err [verifysign $cert_hex "pkcs11"]
      if {$err == 0} {
        #Передумали
        return
      }
      if {$err != 1} {
        #		tk_messageBox -title [mc "Работа с сертификатом"] -icon error -message [mc "Сертификат не прошел проверку"] -parent .
        return
      }
      #DER в бинарнике
      set asndata [binary format H* $cert_hex]
      if {[catch {array set cert_parse [::pki::x509::parse_cert $asndata]} rc]} {
        tk_messageBox -title [mc "Load certificate from PKCS12"] -icon error -message "$friendly" -detail [mc "The selected file does not contain a certificate"]
        return
      }

      set labcert [createnick $cert_parse(issuer) $cert_parse(subject)]
      #puts "labcert=$labcert"
      if {[catch {set pkcs11id [$::tokenls11sw0 importcert $cert_hex $labcert]} res] } {
        tk_messageBox -title "Импорт из контейнера PKCS#12" -icon info -message "Не удалось импортировать сертификат из PKCS#12\n" -detail $res
        return
      }
      $::tokenls11sw0 rename all $pkcs11id $labcert
#      ::updatetok
      ::updatecert
      tk_messageBox -title "Импорт из контейнера PKCS#12" -icon info -message "Импорт из контейнера PKCS#12 \n$pkcs11id" -detail "$labcert"
      return
    }
    1 {
      if {[info command $::tokenls11sw0] == ""} {
	tk_messageBox -title "Импорт закрытого ключа на токен" -icon error -message "Нет подключенного токена" -parent .
	return 
      }
      #DER в бинарнике
      set asndata [binary format H* $cert_hex]
      array set infopk [$::tokenls11sw0 pubkeyinfo $cert_hex]

      #parray infopk
      array set cert_parse [::pki::x509::parse_cert $asndata]
      set labcert [createnick $cert_parse(issuer) $cert_parse(subject)]

      binary scan $::private_key_str H* private_key_str_hex
      binary scan $::public_key_str H* public_key_str_hex
      set asnhash [::asn::asnObjectIdentifier $::gost3411Paramset]
      binary scan $asnhash H* asnhash_hex
      set asnsign [::asn::asnObjectIdentifier $::gost3410Paramset]
      binary scan $asnsign H* asnsign_hex
      set asnsign1 $asnsign
      set asnhash1 $asnhash
      ::asn::asnGetObjectIdentifier asnsign1 oidparsign
      ::asn::asnGetObjectIdentifier asnhash1 oidparhash
      set par "pkcs11_id=$infopk(pkcs11_id)\nlabcert=$labcert\npubkey_algo=$cert_parse(pubkey_algo) ([::pki::_oid_name_to_number $cert_parse(pubkey_algo)])\nprivate_key=xxx...xxx\npublic_key=$public_key_str_hex\n\
      paramhash=$asnhash_hex ($oidparhash)\nparamsign=$asnsign_hex ($oidparsign)"
      tk_messageBox -title "Импорт закрытого ключа" -icon info -message "Импорт закрытого ключа из PKCS#12 на токен \n$::slotid_teklab" -detail "Информация о ключе\n$par\nfriendlyName=$friendly"
      set uu [dict create pkcs11_label $labcert]
      dict set uu pkcs11_id $infopk(pkcs11_id)
      dict set uu priv_value $private_key_str_hex
      if {$exp12 == 0} {
        dict set uu priv_export "true"
      } else {
        dict set uu priv_export "false"
      }
      dict set uu pub_value $public_key_str_hex
      dict set uu gosthash $asnhash_hex
      dict set uu gostsign $asnsign_hex

      #	    set impkey [pki::pkcs11::importkey $uu ]
      set impkey [$::tokenls11sw0 importkey $uu ]

      if {$impkey} {
        $::tokenls11sw0 rename all  $infopk(pkcs11_id) $labcert
        tk_messageBox -title "Импорт из контейнера PKCS#12" -icon info -message "Ключевая пара успешно импортирована" -detail "CKA_LABEL: $labcert\nCKA_ID: $infopk(pkcs11_id)"
      } else {
        tk_messageBox -title "Импорт из контейнера PKCS#12" -icon error -message "Импор ключевой пары не удался"
      }
      unset uu
      return
    }
    2 {
      set certder [binary format H* $cert_hex]
      saveCert $ts12 $certder
      return
    }

    default {
      puts "Unknown operation=$top12"
    }
  }
}

proc ::workOp {} {
  variable doc_for_sign
  global typesys
  variable createTimeStamp
  variable createescTS
  variable varescTS
  global yespas
  global pass
  global myHOME
  variable ::lcerts
  variable src_fn
  variable nickCert
  variable typeop
  variable typesave
  variable p7s_fn
  set c ".st.fr1.fr2_list2"
  #    puts "typeop=$typeop"
  #    puts "WORKOP:c=$c"
  set i 0
  if {$p7s_fn == ""} {
    tk_messageBox -title [mc "Работа с PKCS7"] -icon error -message [mc "Не выбран файл с электронной подписью"] -parent .
    return
  }
  array set p7 []
  foreach p7t $::lp7 {
    array set p7 $p7t
    if {$::signedCert == $p7(nickcert)} {
      set i 1
      break
    }
  }
  if {$i != 1 && $typeop != 4} {
    tk_messageBox -title [mc "Работа с PKCS7"] -icon error -message [mc "Перегрузите файл с электронной подписью"] -parent .
    return
  }
  switch $typeop {
    0 {
      if {$src_fn == "" } {
        tk_messageBox -title [mc "Verify signature"] -icon info -message [mc "Не выбран документ для проверки"] -parent .
        return
      }
#      if {$p7(messageDigestTek) != ""} {}
      if {[info exists p7(messageDigestTek)]} {
        #        puts "messageDigestTek=$p7(messageDigestTek)"
        #        puts "messageDigest=$p7(messageDigest)"
        if {$p7(messageDigestTek) != $p7(messageDigest)} {
          tk_messageBox -title [mc "Verify signature"] -icon info -message [mc "Файл с подписью поврежден"] -detail "или неподдерживаемая подпись\n$p7(digestalgo)" -parent .
          return
        }
      }
      set file $src_fn
      if {![file exists $file]} {
        tk_messageBox -title [mc "Verify signature"] -icon info -message [mc "Файла с документом не существует"] -parent .
        return
      }
      #puts "Loading content file: $file"
      set fd [open $file]
      chan configure $fd -translation binary
      set data [read $fd]
      close $fd
      binary scan $data  H* ret(context_hex)
      #Проверяем хэш контента
      set oidhash $p7(digestalgo)
      switch -- $oidhash {
        "1.2.643.7.1.1.2.2" - "1 2 643 7 1 1 2 2" {
          #    "GOST R 34.11-2012-256"
          set digest_algo "stribog256"
        }
        "1.2.643.7.1.1.2.3" - "1 2 643 7 1 1 2 3" {
          #     "GOST R 34.11-2012-512"
          set digest_algo "stribog512"
        }
        "1.2.643.2.2.9" - "1 2 643 2 2 9"  {
          #    "GOST R 34.10-2001 with GOST R 34.11-94"
          set digest_algo "gostr3411"
        }
        default {
          tk_messageBox -title [mc "Verify signature"] -icon info -message "[mc {Cannot veridy content}]" -detail "[mc {Unknown digest algo}]:\n\t$oidhash" -parent .
          return
      }
    }
      if {[info command $::tokenls11sw0] == ""} {
#Оригинал для Хэш передается в оригигальном виде
	set digest_mes_hex    [pki::pkcs11::dgst $digest_algo $data]
      }  else {
#Токен подключен. Считаем хэш на токене
        set digest_mes_hex    [$::tokenls11sw0 digest $digest_algo $data]
      }

      if {[info exists p7(messageDigest)]} {
	if {$digest_mes_hex != $p7(messageDigest) } {
    	    tk_messageBox -title [mc "Verify signature"] -icon info -message [mc "Подпись не от указанного документа"] -parent .
    	    return
        }
        if {[info command $::tokenls11sw0] == ""} {
    	    tk_messageBox -title "Проверка подписи" -icon info -message "Не могу проверить подпись\n" -detail "Нет подключенного токена" -parent .
    	    return
        }
	set p7signerinfo "31[string range $p7(signerinfo) 2 end]"
        set signerinfo [binary format H* $p7signerinfo]
        set signerinfo_hex    [$::tokenls11sw0 digest $digest_algo $signerinfo]
      } else {
    	if {[info command $::tokenls11sw0] == ""} {
    	    tk_messageBox -title "Проверка подписи" -icon info -message "Не могу проверить подпись (1)\n" -detail "Нет подключенного токена" -parent .
    	    return
    	}
        set signerinfo_hex   $digest_mes_hex
      }
      if {$p7(cert_hex) == ""} {
        tk_messageBox -title [mc "Verify signature"] -icon info -message [mc "Отсутствует сертификат подписанта"] -parent .
        return
      }

      array set infopk [pki::pkcs11::pubkeyinfo $p7(cert_hex)  [list pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]]
      $::tokenls11sw0 login
      if {[catch {set verify [$::tokenls11sw0 verify $signerinfo_hex $p7(signature) $infopk(pubkeyinfo)]} res] } {
        tk_messageBox -title "Проверка подписи" -icon error -message "Ошибка проверки подписи" -detail "$res" -parent .
        $::tokenls11sw0 logout
        return
      }
      $::tokenls11sw0 logout
      if {$verify != 1} {
        tk_messageBox -title "Проверка подписи" -icon error -message "Подпись не прошла проверку"  -parent .
      } else {
        tk_messageBox -title "Проверка подписи" -icon info -message "Подпись документа верна" -detail "$::dateSign\n$::dateSignTST" -parent .
      }
  }
    1 {
      if {$p7(attached) == 0} {
        tk_messageBox -title "Извлечение подписанного документа" -icon info -message "Подпись отсоединенная. Документ отсутствует." -parent .
        return
      }
      set cont [binary  format H* $p7(context_hex)]
      saveCert 2 $cont
    }
    2 {
      #puts "WORKOP save cert:c=$c"
      #puts "typesave=$typesave"
      set ::dercert [binary  format H* $p7(cert_hex)]
      if {$::dercert == ""} {
        tk_messageBox -title "Извлечение сертификата подписанта" -icon info -message "Сертификат подписанта отсутствует" -parent .
        return
      }
      saveCert $typesave $::dercert
    }
    3 {
      #puts "sifn_file=$nickCert"
      set createescTS $varescTS
      #puts "varescTS=$varescTS createescTS=$createescTS"
      set  ::tekTSP $::tekTSPadd

      if {[array size ::certs_p11] == 0 } {
        tk_messageBox -title "Подписать документ" -message "Нет подключенного токена с сертификатами." -icon info  -parent .
        return
      }
      if {$src_fn == "" } {
        tk_messageBox -title "Добавить подпись" -icon info -message "Не выбран документ для проверки" -parent .
        return
      }
      if {$::p7s_hex == "" } {
        tk_messageBox -title "Добавить подпись" -icon info -message "Не выбран файл с электронной подписью" -parent .
        return
      }
      set file $src_fn
      if {![file exists $file]} {
        tk_messageBox -title "Добавить подпись" -icon info -message "Файл с документом не существует" -parent .
        return
      }
                              	
      set privkey [$::tokenls11sw0 listobjects "privkey"]
      #	    puts "PRIVKEY=$privkey"
      set i 0
      foreach prkey $privkey {
        if {$nickCert == [lindex $prkey 2]} {
          set i 1
          break
        }
      }
      if {$i == 0 } {
        tk_messageBox -title "Добавить подписанта" -message "Документ подписать не удалось" -detail "У сертификата \n$nickCert\n нет закрытого ключа" -icon error  -parent .
        return
      }
      #####################
      set saveCert ".st.fr1.fr2_certs"
      set ind [$saveCert.listCert current]
      set nick  [lindex $::listx509 $ind]
      #tk_messageBox -title "Добавить подписанта" -message "$::listx509" -detail "\t$nickCert" -icon error  -parent .

      set cert_derhex [lindex $::certs_p11($nick) 0]
      if {$cert_derhex == ""} {
        tk_messageBox -title "Добавить подписанта" -message "На токене отсутствует сертификат подписанта:" -detail "\t$nickCert" -icon error  -parent .
        return
      }
      ####################################
      array set infopk [$::tokenls11sw0 pubkeyinfo $cert_derhex ]
      foreach p7t $::lp7 {
        array set p7 $p7t
        if {$infopk(issuer) == $p7(issuer) && $infopk(serial_number) == $p7(serial_number)} {
          tk_messageBox -title "Добавить подписанта" -icon error -message "Уже имеется подпись для выбранного сертификата:" -detail $nickCert  -parent .
          return
        }
      }
      ##############################

      #puts "Loading content file for add_signature: $file"
      set fd [open $file]
      chan configure $fd -translation binary
      set content [read $fd]
      close $fd
      .topclock.lclock configure -text "Начался процесс подписания\n\nдокумента из файла\n\n[file tail $doc_for_sign]\n\nПодождите некоторое время!"
      .topclock configure -text "Идет процесс подписания"
      place .topclock -in .st.fr1.fr2_certs.labCert  -relx 1.0 -rely 0.0 -relwidth 3.5
      tk busy hold ".st.fr1"
      tk busy hold ".st.fr3"

      update

      set pkcs7_new [::pki::pkcs7_add_signeddata $content $cert_derhex $p7(attached)  $::p7s_hex]
      if {$pkcs7_new == 0 } {
        tk_messageBox -title [mc "Add signature"] -icon error -message [mc "Не удалось добавить подпись"]  -parent .
        tk busy forget ".st.fr1"
        tk busy forget ".st.fr3"
        place forget .topclock
        return
      }
      set fd [open $p7s_fn w]
      chan configure $fd -translation binary
      puts -nonewline $fd $pkcs7_new
      close $fd
      set p7s_fn $p7s_fn
      tk_messageBox -title [mc "Add signature"] -icon info -message [mc "Подпись добавлена"] -detail "Файл с подписями:\n$p7s_fn" -parent .
      tk busy forget ".st.fr1"
      tk busy forget ".st.fr3"
      place forget .topclock
    }
    4 {
      variable ::lcerts
      variable typesave
      if {[llength $::lcerts] == 0 } {
        tk_messageBox -title [mc "Save certificates"] -icon info -message [mc "Нет сертификатов"] -detail "File=$p7s_fn" -parent .
        return
      }
      set dir [tk_chooseDirectory -initialdir $::lastDir -title "Выберите папку для сертификатов"]
      #puts "Сохранить все сертификаты в каталоге=$dir"
      if {$typesys == "win32" } {
        if { "after#" == [string range $dir 0 5] } {
          set dir ""
        }
      }
      if {$dir == ""} {
        return ""
      }
      set ::lastDir $dir
      set i 0
      set f [file tail $p7s_fn]
      set f [file rootname $f]
      set lfile ""
      if {$typesave} {
        set ext ".pem"
      } else {
        set ext ".der"
      }
      foreach cert_h $::lcerts {
        set cert [binary format H* $cert_h]
        set f1 "[file join $dir $f].cert$i$ext"
        append lfile "$f1.cert$i$ext\n"
        if {$typesave} {
          set cert [::pki::_encode_pem $cert "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]
        }
        set fd [open $f1 w]
        chan configure $fd -translation binary
        puts -nonewline $fd $cert
        close $fd
        incr i
      }
      tk_messageBox -title [mc "Save certificates"] -icon info -message [mc "Сертификаты сохранены в каталоге:\n\t$dir"] -detail "$lfile" -parent .
    }
    5 {
      #Извлечь p7 со штампом времени
      if {$p7(timeStamp) != 1} {
        tk_messageBox -title [mc "Save timeStampToken"] -icon info -message [mc "Штамп времени отсутствует"] -parent .
        return
      }
      set p7tst [binary format H* $p7(p7timestamp_hex)]
      saveCert 3 $p7tst
    }
    default {
      puts "Unknown operation"
    }
  }
}

proc fscale {ll} {
  set ind [string first "." $::dayscert]
  if {$ind == -1} {
    return
  }
  incr ind -1
  set ::dayscert2 [string range $::dayscert 0 $ind ]
  set ::dayscert $::dayscert2
}

proc create_csr_list5 {tpage c num} {
  global certfor
  global macos
  global typesys
  global env
  global reqFL
  global typeCert
  global sodCert
  global wizDatacsr
  global wizDatacert
  global certfor
  set filetyperequest {
    {{Запрос на сертификат в DER формате} {.p10}}
    {{Запрос на сертификат в PEM формате} {.csr}}
    {{Любой тип} *}
  }
  set filetypecert {
    {{Certificate (DER)} {.der}}
    {{Certificate (PEM)} {.pem}}
    {{Certificate (DER)} {.p12}}
    {{Certificate (DER)} {.pfx}}
    {{All Files} *}
  }
  set filetypekey {
    {{PrivateKey (PEM)} {.pem}}
    {{PrivateKey (PEM)} {.key}}
    {{All Files} *}
  }
  if {$tpage == "csr"} {
    set wizDatacsr(token) $::slotid_teklab
    array set wizData [array get wizDatacsr]
    set pretext "Файл с запросом на сертификат в последующем должен быть представлен в УЦ.
    Генерируемый вместе с запросом ключ, будет сохранен на токене [string trim $wizData(token)].
    Это ваш Ключ. Надежно храните его и PIN-код к нему."
    set typefile $filetyperequest
    set labt "Файл для запроса:"
    .st.fr1.fr2_list3.lab  configure  -text $pretext
  } else {
    set pretext "Генерируемый вместе с сертификатом закрытый ключ, будет сохранен в защищенном
    контейнере PKCS#12 в каталоге, который вы определите.
    Надежно храните закрытый ключ его и пароль к нему от посторонних глаз."
    .st.fr1.fr2_list9.lab  configure  -text $pretext
    set wizDatacert(token) $::slotid_teklab
    array set wizData [array get wizDatacert]
    set typefile $filetypecert
    set labt "Папка для сертификатов:"
  }
  set wz [subst "wizData$tpage"]
  set csr_fn [subst "wizData$tpage\(csr_fn\)"]
  set key_fn [subst "wizData$tpage\(key_fn\)"]
  set keypassword [subst "wizData$tpage\(keypassword\)"]

  foreach {v req} $typeCert {
    if {$v == $wizData(type) } {
      array set profdate $sodCert($req)
      break
    }
  }
  set wizData(csr_fn) [file join $env(HOME) $wizData(E).csr]

  label $c.l1 -text $labt
  if {$macos} {
    set typefile ""
  }

  if {$tpage == "csr"} {
    cagui::FileEntry $c.e1 -dialogtype save \
    -variable $csr_fn \
    -title "Введите имя файла для сохранения запроса" \
    -width 47 \
    -defaultextension "*.p10 *.csr" \
    -initialdir $env(HOME) \
    -filetypes $typefile
  } else {
    cagui::FileEntry $c.e1 -dialogtype directory \
    -variable $csr_fn \
    -title "Каталог для сертификатов и ключей" \
    -width 49 \
    -initialdir $env(HOME)
  }

  frame $c.ftype -relief flat -bg white  -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue -padx 0
  label $c.l0 -text "Выберите формат файла:" -bg white -anchor w
  ttk::radiobutton $c.ftype.typeDer -text [mc {DER-format}] -value 0 -variable ::formatCSR -pad 0
  pack $c.ftype.typeDer -expand 1 -fill x  -side left -padx {10 0} -pady 1
  ttk::radiobutton $c.ftype.typePem -text [mc {PEM-format}] -value 1 -variable ::formatCSR -pad 0
  pack $c.ftype.typePem -expand 1 -fill x -side right -padx {10 10} -pady 1
  grid $c.l0 -row 0 -column 0 -sticky w -padx {4 0} -pady {1 1}
  grid $c.ftype -row 0 -column 1 -sticky nw -padx 0 -pady {1 1}
  grid columnconfigure $c 1 -weight 1

  grid $c.l1 -row 1 -column 0 -sticky w -padx {4 0} -pady 2
  grid $c.e1 -row 1 -column 1 -sticky nswe -padx 0 -pady 2

  if {$tpage == "csr"} {
    if {$wizDatacsr(keytok) == 1 } {
      label $c.l2 -text "PIN-код для токена:"
      ttk::entry $c.e2  -show * -textvariable $keypassword
    } else {
      if {$macos} {
        set ft ""
      } else {
        set ft $filetypekey
      }
      label $c.l2 -text "Файл для закрытого ключа:"
      cagui::FileEntry $c.e2 -dialogtype save \
      -variable $key_fn \
      -title "Введите имя файла для закрытого ключа" \
      -width 47 \
      -defaultextension "*.key" \
      -initialdir $env(HOME) \
      -filetypes $ft \
      -typewd window
    }
    grid $c.l2 -row 2 -column 0 -sticky w -padx {4 0} -pady 4
    grid $c.e2 -row 2 -column 1 -sticky nw -padx 0 -pady 4
  }

  if {$certfor == 0} {
    set bc_opt [lrange $::bc_options 3 4]
  } else {
    set bc_opt [lrange $::bc_options 0 2]
  }
  if {[lsearch $bc_opt $::bc] == -1} {
    set ::bc [lindex $bc_opt 0]
  }

  label $c.lbc -text "Основные ограничения:"  -bg white -anchor w
  ttk::combobox $c.bc -textvariable ::bc -values $bc_opt
  grid $c.lbc -row 3 -column 0  -sticky w -padx {4 0} -pady 4
  grid $c.bc -row 3 -column 1 -sticky nwse -padx 0 -pady 4

  if {$tpage == "cert"} {
    label $c.lpca -text "Точка раздачи CA:"  -bg white -anchor w
    ttk::entry $c.pca -width 45
    $c.pca delete 0 end
    set lc "bind $c.lpca <Enter> {.helpview configure -text \"Точка выдачи сертификата УЦ\";place .helpview -in $c.lpca -relx 1.0 -rely 0.5}"
    set lc [subst $lc]
    eval $lc
    bind $c.lpca <Leave> {place forget .helpview}

    grid $c.lpca -row 4 -column 0  -sticky nwse -padx {4 0} -pady 2
    grid $c.pca -row 4 -column 1 -sticky nwse -padx 0 -pady 2
    grid columnconfigure $c 1 -weight 1
    label $c.lyear -text "Определите срок действия сертификата (в годах и днях):"  -bg skyblue
    grid $c.lyear -row 5 -column 0 -columnspan 2 -sticky w -padx 4 -pady 0
    spinbox $c.years -from 0 -to 25 -state readonly -textvariable ::yearcert -justify right -width 5
    grid $c.years -row 6 -column 0 -columnspan 2 -sticky w -padx {4 0} -pady 2
    ttk::label $c.ld -textvariable ::dayscert2
    ttk::style configure TScale  -background white
    ttk::scale $c.days -from 0 -to 366 -orient horizontal -variable ::dayscert -length 480 -value 0 -command fscale
    grid $c.ld -row 6 -column 0 -columnspan 1 -sticky e -padx 0 -pady 2
    grid $c.days -row 6 -column 1 -columnspan 1 -sticky e -padx 0 -pady 2

    label $c.lpw -text "Пароль для PKCS#12:"  -bg skyblue -anchor w -font TkDefaultFontBold
    entry $c.pw  -show * -textvariable ::pw -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue
    grid $c.lpw -row 7 -column 0  -sticky nwse -padx {4 0} -pady 2
    grid $c.pw -row 7 -column 1 -sticky nwse -padx 0 -pady 2
    label $c.lrpw -text "Повторите пароль:"  -bg skyblue -anchor w -font TkDefaultFontBold
    entry $c.rpw  -show * -textvariable ::rpw -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue
    grid $c.lrpw -row 8 -column 0  -sticky nwse -padx {4 0} -pady 0
    grid $c.rpw -row 8 -column 1 -sticky nwse -padx 0 -pady 0
  }

  #puts "FILE=$wizData(csr_fn)"
  focus $c.e1.entry
}

proc create_csr_list6 {tpage c num} {
  global reqFL
  global typeCert
  global sodCert
  global g_iso3166_codes
  global wizDatacsr
  global wizDatacert
  if {$tpage == "csr"} {
    set wizDatacsr(token) $::slotid_teklab
    set pretext "Внимательно просмотрите запрос, который вы создаете.
    Если все нормально, то Нажмите \"Завершение\" для генерации ключевой пары и
    создания Запроса на Сертификат с сохранением в файле"
    array set wizData [array get wizDatacsr]
    .st.fr1.fr2_list3.lab  configure  -text $pretext
  } else {
    if {$::formatCSR == 0 } {
      set wizDatacert(key_fn) [file join $wizDatacert(csr_fn) selfkey_$::snforcert.der]
    } else {
      set wizDatacert(key_fn) [file join $wizDatacert(csr_fn) selfkey_$::snforcert.pem]
    }
    set wizDatacert(token) $::slotid_teklab
    set pretext "Внимательно просмотрите сертификат, который вы создаете.
    Если все нормально, то Нажмите \"Завершение\" для генерации ключевой пары и
    создания Сертификата с сохранением в файле"
    array set wizData [array get wizDatacert]
    .st.fr1.fr2_list9.lab  configure  -text $pretext
  }

  text $c.t1 -yscrollcommand [list $c.vsb set]  -font {Times 10 bold italic}  -heigh 14
  ttk::scrollbar $c.vsb -orient vertical -command [list $c.t1 yview]

  set fnt(std) [$c.t1 cget -font]
  set fnt(bold) [list [lindex $fnt(std) 0] [lindex $fnt(std) 1] bold]
  $c.t1 tag configure bold -font $fnt(bold)

  $c.t1 insert end "Владелец сертификата:\n" bold
  $c.t1 insert end "\t$wizData(type)\n"
  $c.t1 insert end "Subject Distinguished Name:\n" bold
  foreach {v req} $typeCert {
    if {$v == $wizData(type) } {
      array set profdate $sodCert($req)
      set reqFL1 $sodCert($req)
      break
    }
  }
  global profile_options
  array set opts [array get profile_options]
  array set fieldlabels $reqFL1
  set wizData(dn) ""
  set wizData(dncsr) {}
  foreach {field dflt} $reqFL1 {
    if {$wizData($field)!= ""} {
      #puts "creating field : $field / $dflt"
      # label
      set kpp ""
      set label $fieldlabels($field)
      if {$field == "C" } {
        foreach {country who} $g_iso3166_codes  {
          if {$country == $wizData($field) } {
            append wizData(dn) "$field = $who\n"
            lappend wizData(dncsr) $field
            lappend wizData(dncsr) $who
            break
          }
        }
      } elseif {$field == "E" } {
        append wizData(dn) "emailAddress = $wizData($field)\n"
        lappend wizData(dncsr) email
        lappend wizData(dncsr) $wizData($field)
      } elseif {$field == "UN" && $::egais == 1  && $wizData(type) == "Юридическое лицо"} {
        append wizData(dn) "$field = $wizData($field)\n"
        lappend wizData(dncsr) $field
        lappend wizData(dncsr) "КПП=$wizData($field)"
        set kpp "КПП="
      } else {
        append wizData(dn) "$field = $wizData($field)\n"
        lappend wizData(dncsr) $field
        lappend wizData(dncsr) $wizData($field)
      }
      $c.t1 insert end "\t$label ($field) = $kpp$wizData($field)\n"
    }
  }
  if {$::egais == 1 && $wizData(type) == "Индивидуальный предприниматель"} {
    set label "КПП (UN)"
    $c.t1 insert end "\t$label = КПП=\n"
    lappend wizData(dncsr) "UN"
    lappend wizData(dncsr) "КПП="
    lappend wizData(dncsr) "title"
    lappend wizData(dncsr) "Индивидуальный предприниматель"
  }
  #puts "DNCSR=$wizData(dncsr)"
  if {$tpage == "csr"} {
    set wizDatacsr(dncsr) $wizData(dncsr)
  } else {
    set wizDatacert(dncsr) $wizData(dncsr)
  }
  $c.t1 insert end "Сведения о ключе:\n" bold
  $c.t1 insert end "\tТип ключа = $wizData(typekey)\n"
  $c.t1 insert end "\tПараметры ключа = $wizData(parkey)\n"
  if {$tpage == "csr"} {
    $c.t1 insert end "\tГенерация ключа на токене = $wizData(token)\n"
  } else {
    $c.t1 insert end "\tКлюч будет сохранен в файле = [file join $wizData(csr_fn) rootCA.key]\n"
  }
  if {$wizData(ckzi) != 0} {
    $c.t1 insert end "\tНаименование СКЗИ = $wizData(ckzi)\n"
  }
  if {$tpage == "csr"} {
    $c.t1 insert end "Запрос будет сохранен в файле = $wizData(csr_fn)\n" bold
  } else {
    $c.t1 insert end "Сертификат будет сохранен в каталоге = $wizData(csr_fn)\n" bold
  }
  if {$::formatCSR == 1} {
    set format "PEM"
  } else {
    set format "DER"
  }
  $c.t1 insert end "Формат файла = $format\n" bold

  $c.t1 configure  -state disabled

  pack $c.vsb -side right -fill y
  pack $c.t1 -side top -expand 1 -fill both
}

frame .st -relief flat -bd 0 -background #eff0f1  -padx 5 -pady 5

pack .st -in . -fill both -side top -expand 1 -pady 0

frame .st.fr1 -borderwidth 1 -relief flat -background white -highlightbackground #5d8fc8 -padx 0 -pady 0 -highlightthickness 2 -highlightcolor #5d8fc8
frame .st.fr1.fra82 -borderwidth 3 -relief flat -padx 0 -pady 0 -bg white -highlightthickness 1 -highlightbackground skyblue  -highlightcolor skyblue -width 300
pack .st.fr1.fra82 -in .st.fr1 -anchor center -expand 0 -fill y -padx {0 2} -side left

set stylebut "  -activebackground #f9f9f9 -background #ffe0a6 "
#################
set ::list_but {{f0} "Заставка" {f1} "Подписать документ" \
{f2} "Работаем с ЭП (PKCS7)" {f3} "Запрос на сертификат" \
{f4}  "Просмотр запроса/сертификата" {f5} "Список криптомеханизмов" \
{f6} "Просмотр ASN1-структуры" {f7} "Объекты токена" \
{f8} "Работаем с PKCS12/PFX" {f9} "Самоподписанный сертификат" \
{f10} "Получить дистрибутивы" {f11} "Создать Токены" \
{f12} "Конфигурировние токена" \
}
set i 0
option add *Button.highlightthickness  4    interactive
option add *Button.highlightbackground #39b5da interactive
frame .st.fr1.fr2_tokens -bg white -highlightcolor skyblue -relief flat -highlightthickness 1 -highlightbackground skyblue -pady 2
set selecttok ".st.fr1.fr2_tokens"
label $selecttok.lab  -text "Выберите токен/смарткарту:" -font TkDefaultFontBold -anchor w -width 0 -bg white
bind $selecttok.lab <ButtonPress-3> {showContextMenu %W %x %y %X %Y}
ttk::combobox $selecttok.tok -width 30 -textvariable ::nickTok -state readonly -values $::listtok -style TCombobox
bind $selecttok.tok <<ComboboxSelected>> {::selectTok %W $::nickTok }
button  $selecttok.update -command {::updatetok} -image ::img::update_18x16 -compound left -bd 0 -pady 0 -bg white -activebackground white -highlightthickness 0
label .helpupdate -text "Обновить список токенов" -anchor w -justify left
.helpupdate config -bg #ffe0a6
bind $selecttok.update <Enter> {.helpupdate configure -text "Обновить список токенов";place .helpupdate -in $selecttok.tok -relx 1.0 -rely 1.0 -anchor ne}
bind $selecttok.update <Leave> {place forget .helpupdate}

pack $selecttok.lab  -side left -padx {0 5} -pady 0 -expand 0 -fill both
pack $selecttok.tok -side left -padx 0 -pady 0 -expand 1 -fill both
pack $selecttok.update -side right -padx {7 3} -pady 0 -expand 0 -fill none
label .tokinfo -textvariable ::tokeninfo -anchor w -justify left
.tokinfo config -bg #ffe0a6
bind $selecttok.tok <Enter> {.tokinfo configure -text [mc "Choose info \nfor you \nToken"];place .tokinfo -in $selecttok.tok -relx 0.0 -rely 1.0}
bind $selecttok.tok <Leave> {place forget .tokinfo}
frame .st.fr1.fr2_certs -pady 2 -bg white -highlightcolor skyblue -relief flat -highlightthickness 1 -highlightbackground skyblue
set saveCert ".st.fr1.fr2_certs"
label $saveCert.labCert -text "Сертификат:" -font TkDefaultFontBold -anchor w -width 0 -bg white
bind $saveCert.labCert <ButtonPress-3> {showMenuCert %W %x %y %X %Y}
pack $saveCert.labCert  -padx 0 -pady 0 -side left  -expand 0 -fill both
ttk::combobox $saveCert.listCert -textvariable nickCert -state readonly -values $::listx509 -style TCombobox
pack $saveCert.listCert -side left  -padx 4 -pady 0 -expand 1 -fill both
button  $saveCert.viewcert -command {if {[info exists nickCert]} {::viewCert "pkcs11" $nickCert}} -image ::img::view_18x16 -compound left -pady 0 -bd 0 -bg white -activebackground white -highlightthickness 0
label .helpview -text "Просмотр сертификата" -anchor w -justify left
.helpview config -bg #ffe0a6
bind $saveCert.viewcert <Enter> {.helpview configure -text "Просмотр сертификата";place .helpview -in $saveCert.listCert -relx 1.0 -rely 1.0 -anchor ne}
bind $saveCert.viewcert <Leave> {place forget .helpview}
pack $saveCert.viewcert -side right -padx {3 3} -pady 0 -expand 0 -fill none

######################
set tekfr ".st.fr1.fra82"

proc firstgl {} {
  set tekfr ".st.fr1.fra82"
  ::setTekFrame .st.fr1.fr2_list  .st.fr1.fr2_list0 0;
  set ::pressBut  0;
  $tekfr.b$::lastFunc configure -background white;
  $tekfr.b0 configure  -background #b4ccea;
  #    $tekfr.stfirst.labgl configure  -background #b4ccea;
  set ::lastFunc 0

}

ttk::frame $tekfr.stfirst
ttk::label $tekfr.stfirst.br -image verchlefttoright_22x24 -compound left -borderwidth 0  -background white
bind $tekfr.stfirst.br <Enter> {$tekfr.stfirst.labgl configure -background #d9e8f6}
bind $tekfr.stfirst.br <Leave> {$tekfr.stfirst.labgl configure -background white}
bind $tekfr.stfirst.br <Enter> {$tekfr.stfirst.br configure -background #d9e8f6}
bind $tekfr.stfirst.br <Leave> {$tekfr.stfirst.br configure -background white}
bind $tekfr.stfirst.br <ButtonPress-1> {wrapunwrap}
pack $tekfr.stfirst.br -side left -pady 0 -padx 0 -anchor w -fill x

ttk::label $tekfr.stfirst.labgl -image rabota_24x24 -compound left -text "Функционал cryptoarmpkcs"  -padding -1 -background white
bind $tekfr.stfirst.labgl <Enter> {$tekfr.stfirst.labgl configure -background #d9e8f6}
bind $tekfr.stfirst.labgl <Leave> {$tekfr.stfirst.labgl configure -background white}
bind .st.fr1.fra82.stfirst.labgl <ButtonPress-1> {firstgl}
pack $tekfr.stfirst.labgl -side top -pady 0 -padx 0 -anchor w -fill x
pack $tekfr.stfirst -side top -pady {10 0} -padx 0 -anchor w -fill x

###############

ttk::frame $tekfr.forbut -padding 0
set i 0
foreach {a b} $::list_but {
  #puts "$a $b"
  set a "::setTekFrame .st.fr1.fr2_list  .st.fr1.fr2_list$i $i"

  ttk::label .st.fr1.fra82.b$i -image vgrlines_24x24 -compound left -text "$b"  -padding -1 -background white
  set lc "bind .st.fr1.fra82.b$i <Enter> {.st.fr1.fra82.b$i configure  -background #d9e8f6}"
  set lc [subst $lc]
  eval $lc
  set lc "bind .st.fr1.fra82.b$i <Leave> {changecolorleave $i}"
  set lc [subst $lc]
  eval $lc
  set lc "bind .st.fr1.fra82.b$i <ButtonPress-1> {changecolorpress1 $i;$a}"
  set lc [subst $lc]
  eval $lc
  if {$i == 1 || $i == 3 || $i == 5 || $i == 7 || $i == 12} {
    .st.fr1.fra82.b$i configure -state disabled
  }
  frame .st.fr1.fr2_list$i -background white -highlightcolor skyblue -relief flat -highlightthickness 1 -highlightbackground skyblue  -height 400 -pady 0
  if {$i == 1} {
    #puts "PAGE1"
    page_pkcs7_sign .st.fr1.fr2_list$i
  } elseif {$i == 2} {
    #puts "PAGE2"
    page_pkcs7_view .st.fr1.fr2_list$i
  } elseif {$i == 3} {
    .st.fr1.fr2_list$i configure  -height 300
    set pretext "Укажите кто будет владельцем сертификата, для каких целей он будет использоваться.
    Выберите тип ключевой пары и токен, где она она будет сгенерирована и хранится.
    Укажите наименование вашего СКЗИ из сертификата соответствия."

    label ".st.fr1.fr2_list$i.lab"  -bg #f5f5f5  -text $pretext -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue -justify left -anchor w
    .st.fr1.fr2_list$i.lab configure -font {Times 10 bold italic}

    pack ".st.fr1.fr2_list$i.lab" -expand 0 -fill x -anchor w

    set funcs [list create_csr_list1 create_csr_list2 create_csr_list3 create_csr_list4 create_csr_list5 create_csr_list6]
    set wiz .st.fr1.fr2_list$i
    set countp [llength $funcs]
    set ::pagescsr [wizard "csr" $wiz $countp $funcs]
    #puts "PAGES_CSR=$::pagescsr"
  } elseif {$i == 4} {
    page_csr_view .st.fr1.fr2_list$i
  } elseif {$i == 5} {
    set w .st.fr1.fr2_list$i
    text $w.text -bg #f5f5f5 -highlightcolor skyblue -yscrollcommand [list $w.vsb set] -height 15
    ttk::scrollbar $w.vsb -orient vertical -command [list $w.text yview]
    $w.text configure -yscrollcommand [list $w.vsb set]

    $w.text tag configure tagAbout -foreground blue -font {Times 10 bold italic}
    pack $w.vsb -side right -fill y -in $w
    pack $w.text -padx 3 -pady {0 0} -side left -expand 0 -fill both
  } elseif {$i == 6} {
    page_asn1view .st.fr1.fr2_list$i
  } elseif {$i == 7} {
    page_objects .st.fr1.fr2_list$i
  } elseif {$i == 8} {
    page_pkcs12 .st.fr1.fr2_list$i
  } elseif {$i == 9} {
    .st.fr1.fr2_list$i configure  -height 300
    set pretext "Укажите кто будет владельцем сертификата, для каких целей он будет использоваться.
    Выберите тип ключевой пары (ГОСТ Р 34.10-2012-256/512 или RSA).
    Наименование вашего СКЗИ - СКЗИ \"ЛИРССЛ-CSP\"."

    label ".st.fr1.fr2_list$i.lab"  -bg #f5f5f5  -text $pretext -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue -justify left -anchor w
    .st.fr1.fr2_list$i.lab configure -font {Times 10 bold italic}

    pack ".st.fr1.fr2_list$i.lab" -expand 0 -fill x -anchor w

    set funcs [list create_csr_list1 create_csr_list2 create_csr_list3 create_csr_list4 create_csr_list5 create_csr_list6]
    set wiz .st.fr1.fr2_list$i
    set countp [llength $funcs]
    set ::pagescert [wizard "cert" $wiz $countp $funcs]
    #puts "PAGES_CERT=$::pagescert"
  } elseif {$i == 0} {
    #Заставка
    label ".st.fr1.fr2_list$i.lab" -bg white  -image logoLC
    pack ".st.fr1.fr2_list$i.lab" -anchor center -expand 1 -fill both
  } elseif {$i == 10} {
    #Получить дистрибутивы
    page_about .st.fr1.fr2_list$i
  }  elseif {$i == 11} {
    #Создать токены
    page_createtok .st.fr1.fr2_list$i
  } elseif {$i == 12} {
    #Конфигурирование токена
    page_token .st.fr1.fr2_list$i
  }
  if {$i > 12} {
    label ".st.fr1.fr2_list$i.lab" -text ".st.fr1.fra82.b$i"  -bg white
    pack ".st.fr1.fr2_list$i.lab" -expand 1 -fill both
  }

  pack .st.fr1.fra82.b$i -in .st.fr1.fra82.forbut -expand 1 -fill x -side top  -pady {0 0} -anchor w
  incr i
}
incr i -1
.st.fr1.fra82.b$i configure -image vgrlines_v
.st.fr1.fra82.b11 configure -image vgrlines_cloud

ttk::style configure TFrame -background  white
ttk::frame .st.fr1.fra82.stend -pad 0 -padding 0 -style TFrame

ttk::button .st.fr1.fra82.stend.bute -text "  Выход  "  -image exitCA_16x16 -compound left -command {exit} -style MyBorder.TButton -padding 0
ttk::label .st.fr1.fra82.stend.lab -image endfunc_24x24 -compound left  -borderwidth 0 -background white
pack .st.fr1.fra82.stend.lab -side left -pady 0 -padx {0 0}  -anchor w
pack .st.fr1.fra82.stend.bute -side left -pady {0 0} -padx {0 0} -anchor w
pack .st.fr1.fra82.forbut -side top  -padx {0 0} -pady {0 0} -anchor w
pack .st.fr1.fra82.stend -side top -padx {0 0} -anchor w -fill x

label .st.fr1.labLogo -image logoLC -compound center -height 385 -background white
pack .st.fr1.labLogo -in .st.fr1 -anchor center -expand 0 -fill none -side top  -padx {2 0}
labelframe .st.fr3 -relief flat -text "Выберите библиотеку PKCS#11 для токена" -font TkDefaultFontBold -bg snow -bd 3 -pady 3 -highlightthickness 2 -highlightbackground #5d8fc8  -highlightcolor #5d8fc8
label .st.fr3.lablib -relief flat -text "Библиотека PKCS#11:" -font TkDefaultFontBold -bg #eff0f1 -anchor w -padx 0
pack .st.fr3.lablib -in .st.fr3 -side left -expand 0 -fill none -padx 5 -ipady 4 -pady {0 4}
ttk::entry .st.fr3.ent -background snow -state readonly -textvariable ::pkcs11_module
pack .st.fr3.ent -in .st.fr3 -side left -expand 1 -fill x -padx {5 0} -pady {0 4}

proc dateLIC {} {
  global env
  set userpath $env(HOME)
  set filelic [file join $userpath ".LS11SW2016" "LIC.DAT"]

  if {[catch {set fl [open $filelic] } result]} {
    return ""
  }
  seek $fl 64 start
  set date [read $fl 8]
  close $fl
  set d [string range $date 0 1]
  set m [string range $date 2 3]
  set d [string range $date 0 1]
  set y [string range $date 4 end]
  return "$d.$m.$y"
}

proc cmdbrowser {} {
  #Переход на стартовую страницу
  firstgl

  .st.fr3.ent configure -state normal
  set new  [::selectLib . .st.fr3.ent "so" .st.fr1.fr2_list];
  if {$new != ""} {
    set old $::pkcs11_module
    set ::pkcs11_module $new
    if {$::handle != ""} {
      catch {::pki::pkcs11::unloadmodule  $::handle}
    }
    if {[catch {set ::handle [::pki::pkcs11::loadmodule  $::pkcs11_module]} ret]} {
#Уничтожаем объекты токенов для старой библиотеки
      for {set i 0} {$i < [array size ::tokenlist]} {incr i} {
	catch {tokenls11sw$i destroy}
      }
      if { [string first "TOKEN_NOT_RECOGNIZED" $ret] != -1} {
        #У Токена отсутствует лицензия
        tk_messageBox -title "Библиотека PKCS#11" -icon info -message "Отсутствует лицензия на программный токен\n$::pkcs11_module" -detail "Обратитесь к вкладке \"Создать токены\"\n$ret" -parent .
      } else {
        tk_messageBox -title "Библиотека PKCS#11" -icon error -message "Не могу загрузить библиотеку ($::handle):\n$::pkcs11_module" -detail $ret
      }
      set ::handle ""
      set selecttok ".st.fr1.fr2_tokens"
      set saveCert ".st.fr1.fr2_certs"
      set ::listtok [list ]
      $selecttok.tok configure -values $::listtok
      $selecttok.tok configure -state normal
      $selecttok.tok delete 0 end
      set ::listx509 [list ]
      $saveCert.listCert configure -values $::listx509
      $saveCert.listCert set [lindex $::listx509 0]
      set ::tokeninfo "Информация о токене:\nМетка: \nПроизводитель: \nТип: \nСерийный номер: \nНомер слота: "
      tk_messageBox -title "Библиотека PKCS#11" -icon error -message "Не могу создать объект токена" -detail $ret
      return 0
    }
    set ret [::updatetok]

    if {$::pkcs11_module == ""} {
      set ::pkcs11_module $old
      if {$old != ""} {
        set ret [::updatetok]
      };
    }
    switch -- $::pkcs11_status {
      -1 {
        tk_messageBox -title "Используемый токен"   -icon info -message "Отсутствует библиотека" -parent .
      }
      0 {
        set date [dateLIC]
        tk_messageBox -title "Используемый токен"   -icon info -message "Токен готов к использованию:\n$::slotid_teklab\nЛицензия до $date" -parent .
      }
      1 {
        tk_messageBox -title "Используемый токен"   -icon info -message "Отсутствует подключенный токен" -parent .
      }
      2 {
        tk_messageBox -title "Используемый токен"   -icon info -message "Требуется инициализация токена.\nДля инициализации токена перейдите\nна страницу\n\"Конфигурирование токена\"" -parent .
      }
      3 {
        tk_messageBox -title "Используемый токен"   -icon info -message "Нет лицензии на токен." \
        -detail "Необходимо получить и установить лицензию.\nОбратитесь к вкладке \"Создать токены\"" -parent .
      }
      4 {
        tk_messageBox -title "Используемый токен"   -icon info -message "Заблокирован USER-PIN.\nПопробуйте его разблокировать, перейдя\nна страницу\n\"Конфигурирование токена\"" -parent .
      }
    }
  }
  .st.fr3.ent configure -state readonly

}
button .st.fr3.browser -image icon_openfile_18x16  -compound center -bd 0 -command {cmdbrowser} -activebackground white

label .bh -text "Выберите библиотеку PKCS#11 для токена"
.bh config  -bg #ffe0a6
bind .st.fr3.browser <Enter> {.bh configure -text "Выберите библиотеку PKCS#11 для токена";place .bh -in .st.fr3.ent -relx 1.0 -rely -1.0 -anchor ne}
bind .st.fr3.browser <Leave> {place forget .bh}

pack .st.fr3.browser -in .st.fr3 -side left -padx {1mm 1mm} -pady {0 4}

label .st.labMain -bg #eff0f1 -font {System 14 {bold roman}} -foreground black -text " PKCS#11, x509v3, PKCS#10, PKCS#7, CMS, PKCS#12, ASN1" -image logoTok -compound left -height 0 -pady 0
pack .st.labMain -in .st  -side top -fill x -expand 0 -padx 5 -pady {5 0}
bind .st.labMain <ButtonPress-3> {showContextMenu %W %x %y %X %Y}

label  .st.labMain.blang -image ::img::ru_32x32 -compound left -bd 0 -background #eff0f1 -highlightthickness 0 -pady 0
pack .st.labMain.blang -in .st.labMain -side right -pady 0

pack .st.fr1 -in .st -side top -fill both -expand 1 -pady {15 0}
pack .st.fr3 -in .st -side top -pady {5 0} -fill x
.st.fr3.ent configure -state readonly
.st.fr3.browser configure -state normal

proc page_password {}  {
  set ::labpas  "PIN-код для токена"
  ttk::label .lforpas -text "PIN-код для токена"  -textvariable ::labpas

  #Widget for enter PIN or Password
  frame .topPinPw -relief flat -bd 3 -bg chocolate
  labelframe .topPinPw.labFrPw -borderwidth 4 -labelanchor nw -relief groove -labelwidget .lforpas -foreground black -height 120 -width 200  -bg #eff0f1
  pack .topPinPw.labFrPw -in .topPinPw  -anchor nw -padx 1mm -pady 1mm -fill both -expand 0
  entry .topPinPw.labFrPw.entryPw -background snow -show * -highlightbackground gray85 -highlightcolor skyblue -justify left -relief sunken
  entry .topPinPw.labFrPw.entryLb -background snow -highlightbackground gray85 -highlightcolor skyblue -justify left -relief sunken
  pack .topPinPw.labFrPw.entryPw -fill x -expand 1 -padx 1mm -ipady 2 -pady 2mm
  bind .topPinPw.labFrPw.entryPw <Key-Return> {readPw .topPinPw.labFrPw.entryPw}
  bind .topPinPw.labFrPw.entryLb <Key-Return> {readPw .topPinPw.labFrPw.entryLb}
  ttk::button .topPinPw.labFrPw.butPw  -command {global yespas;set yespas "no"; } -text "Отмена"
  ttk::button .topPinPw.labFrPw.butOk  -command {readPw .topPinPw.labFrPw.entryPw} -text "Готово"
  ttk::button .topPinPw.labFrPw.butLbOk  -command {readPw .topPinPw.labFrPw.entryLb} -text "Готово"
  pack .topPinPw.labFrPw.butPw .topPinPw.labFrPw.butOk -pady {0 5} -sid right -padx 5 -pady {0 2mm}
}

proc read_password {tit} {
  global yespas
  global pass
  set tit_orig "$::labpas"
  if {$tit != ""} {
    set ::labpas "$tit"
  }
  tk busy hold ".st.fr1"
  tk busy hold ".st.fr3"
  place .topPinPw -in .st.fr1.fr2_certs.labCert  -relx 1.0 -rely 3.0 -relwidth 3.5
  set yespas ""
  focus .topPinPw.labFrPw.entryPw
  vwait yespas
  tk busy forget ".st.fr1"
  tk busy forget ".st.fr3"
  if {$tit != ""} {
    set ::labpas "$tit_orig"
  }
  place forget .topPinPw
  return $yespas
}

proc ::selectLib { w ent  type list } {
  global typesys
  global p11conf
  global tclpkcs11
  global myHOME
          	
  set typesOth {
    {"Библиотеки"		{.dylib}	}
    {"Любые файлы"		*}
  }
  set typesX11 {
    {"Библиотеки"		{.so .so.*}	}
    {"Любые файлы"		*}
  }
  set typesWin32 {
    {"Библиотеки MS"		{.dll}}
    {"Любые файлы"		*}
  }
  set msk "*.so *.so* *.dll *.dylib *"
  switch [tk windowingsystem] {
    classic - aqua  {
      set  types $typesOth
      set msk "*.dylib *.so *.so* *.dll *"
    }
    x11 {
      set  types $typesX11
    }
    win32 {
      set  types $typesWin32
      set msk "*.dll *.so *.so* *.dylib *"
    }
    default {
      set  types $typesOth
    }
  }	
          	
  set start ""
  if { $type == "so"} {
    set lastdir $myHOME
    #	    puts "LIBFILE=$::pkcs11_module"
    set start $::pkcs11_module
    if {$::pkcs11_module != "" } {
      if {[tk windowingsystem] != "win32"} {
        set lastdir [file dirname $::pkcs11_module]
      }
    }
    #    set file [tk_getOpenFile -title "Выберите библиотеку PKCS#11"  -filetypes $types -parent $w -initialdir $lastdir]
    #FileExplorer FE
    #размещение в отдельном окне
    set typew window
    #Выбор катаалога
    set wfe ".fe"
    if {[tk windowingsystem] == "win32"} {
      #Перекодируем путь из кодировки ОС
      #Для MS Win это скорей всего cp1251
      set tekdir [encoding convertfrom cp1251 $lastdir ]
      #Заменяем обратную косую в пути на нормальную косую
      set lastdir [string map {"\\" "/"} $tekdir]
    }

    set vrr [FE::fe_getopenfile  $typew ".fe" $lastdir $msk]
    if {$typew == "frame"} {
      pack $w -fill both -expand 1
    } else {
      wm minsize ".fe" 400  400
    }
    $wfe.titul.lab configure -text "Выберите библиотеку PKCS11"
    wm iconphoto $wfe icon11_24x24

    #Ждем результата
    vwait $vrr
    set r ""
    #Записываем результат в переменную r
    set r [subst $$vrr]
    set file $r

    #	    puts "FILE=$file"
    if {$typesys == "win32" } {
      if { "after#" == [string range $file 0 5] } {
        set file ""
      }
    }

  } else {
    return ""
  }
  if {[string compare $file ""]} {
    $ent delete 0 end
    $ent insert 0 $file
    $ent xview end
    if {$type == "so"} {
      if {$start == "" } {
        if { $::pressBut == 0 } {
          pack forget .st.fr1.labLogo 		
          pack .st.fr1.fr2_tokens  -in .st.fr1 -anchor ne  -expand 0 -fill x -side top -padx {2 2} -pady {0 0}
          pack .st.fr1.fr2_certs  -in .st.fr1 -anchor ne  -expand 0 -fill x -side top -padx {2 2} -pady {0 0}
          pack .st.fr1.fr2_list0 -in .st.fr1 -anchor ne  -expand 1 -fill both -side top -padx {2 2} -pady {0 0}
        }
        for {set i 0} {$i < 13} {incr i} {
          .st.fr1.fra82.b$i configure -state normal
        }
      }
      return $file
    }
  } else {
    set file [$ent get]
    #	    puts "GET=$file"
    return $file
  }
}

#Список токенов со слотами
proc listts {handle} {
  if {[catch {set slots [pki::pkcs11::listslots $handle]} result]} {
    set cm [string first "CRYPTOKI_NOT_INITIALIZED" $result]
    if { $cm != -1} {
      #У Токена отсутствует лицензия
      set ::pkcs11_status 2
      tk_messageBox -title "Токен" -icon info -message "Токен не проинициализирован" -detail "$result" -parent .
      return ""
    }
    set ::pkcs11_status -1
    tk_messageBox -title "Библиотека PKCS#11" -icon error -message "Проблемы с библиотекой или токеном" -detail "$::pkcs11_module\n$result" -parent .
    return ""
  }

  set listtok {}
  foreach slotinfo $slots {
    set slotid [lindex $slotinfo 0]
    set slotlabel [lindex $slotinfo 1]
    set slotflags [lindex $slotinfo 2]
    set tokeninfo [lindex $slotinfo 3]

    if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} {
      lappend listtok $slotlabel
      lappend listtok $slotid
      lappend listtok $tokeninfo
      lappend listtok $slotflags
    }
  }
  #Список найденных токенов в слотах
  #    puts $listtok
  return $listtok
}

proc ::updatecert {} {
  set saveCert ".st.fr1.fr2_certs"
  $saveCert.listCert configure -state normal
  set ::listx509 [list ]
  #  set ::listx509 [listcerttok $::handle $::slotid_teklab $::slotid_tek]
  set ret [listcerttok]
  $saveCert.listCert configure -values $::listx509
  $saveCert.listCert set [lindex $::listx509 0]

  $saveCert.listCert configure -state readonly
  $saveCert.listCert configure -state readonly
  #puts "UpdateListTok END"
  #Автоматическое обновление токенов
  #after 5000 updatetok
  #  set wizDatacsr(keytok) 1
  #Все ОК
  set ::pkcs11_status $ret
  return $ret
}

proc ::updatetok {} {
  #Возвращает
  # 1 - все хорошо
  # -1 - нет библиотеки
  # 0 - нет подключенных токенов
  # Строка с инф-цией об ошибке
  global wizDatacsr
  global wizDatacert
  set wizDatacsr(keytok) 0
  set selecttok ".st.fr1.fr2_tokens"
  set saveCert ".st.fr1.fr2_certs"
  #puts "UpdateListTok"
  for {set i 0} {$i < [array size ::tokenlist]} {incr i} {
    catch {tokenls11sw$i destroy}
  }
  array unset ::tokenlist
  #tk_messageBox -title "Библиотека PKCS#11" -icon error -message "::updatok HANDLE:\"$::handle\""
  if {$::handle == ""} {
    tk_messageBox -title "Библиотека PKCS#11" -icon error -message "Отсутствует библиотека для токенов"
    return 0
  }
  if {0} {
    catch {::pki::pkcs11::unloadmodule  $::handle}
    if {[catch {set ::handle [::pki::pkcs11::loadmodule  $::pkcs11_module]} ret]} {
      tk_messageBox -title "Библиотека PKCS#11" -icon error -message "Не могу загрузить библиотеку:\n$::pkcs11_module" -detail $ret
      return 0
    }
  }
  ::pki::pkcs11::closesession  $::handle

  #Список найденных токенов в слотах и сертификатов
  set ::slotid_tek -1
  set lists [listts $::handle]

  set i 0
  set ::listtok {}
  set oldslot $::slotid_teklab
  set j 0
  array unset ::tokenlist
  array set ::tokenlist []
  foreach {lab slotid tokeninfo slotflags} $lists {
    #puts "FLAGS=$slotflags"
    #	    puts "Токен \"$lab\" находится в слоте \"$slotid\""
    lappend ::listtok $lab
    if {$i == 0} {
      set ::tokeninfo "Информация о токене:\nМетка: [lindex $tokeninfo 0]\nПроизводитель: [lindex $tokeninfo 1]\nТип: [lindex $tokeninfo 2]\nСерийный номер: [lindex $tokeninfo 3]\nНомер слота: $slotid"
    }
    if {$::slotid_tek == -1} {
      set ::slotid_tek $slotid
      set ::slotid_teklab $lab
      set ::sflags $slotflags
    }
    if {$oldslot == $lab } {
      set ::slotid_tek $slotid
      set ::slotid_teklab $lab
      set ::sflags $slotflags
      set j $i
    }
    if {1} {
      #tk_messageBox -title "Библиотека PKCS#11" -icon error -message "ФЛАГИ: $slotflags"  -parent .
      set cm [string first "USER_PIN_INITIALIZED" $slotflags]
      if { $cm == -1} {
        #Токен не инициализирован
        set ::pkcs11_status 2
        tk_messageBox -title "Библиотека PKCS#11" -icon error -message "Токен \"$lab\" не проинициализирован"  -parent .
        return $slotflags
      } elseif {[string first "USER_PIN_LOCKED" $slotflags] != -1} {
        #Заблокирован PIN пользователя
        set ::pkcs11_status 4
        tk_messageBox -title "Библиотека PKCS#11" -icon error -message "User-PIN заблокирован"  -parent .
        return $slotflags
      }
    }
    set ::tokenlist($lab) $slotid
    incr i
  }
  #Создаем объекты токенов
  set i 0
  foreach lab [array names ::tokenlist] {
    if {[catch {token create tokenls11sw$i $::handle  $lab $::tokenlist($lab)} res]} {
	tk_messageBox -title "Библиотека PKCS#11" -icon error -message "Не могу создать объект токена ($::tokenlist($lab))!" -detail $res
        continue
    }
    set ::tokenlist($lab) "tokenls11sw$i"
    incr i
  }
  if {$i == 0} {
    tk_messageBox -title "Библиотека PKCS#11" -icon error -message "Нет ни одного подключенного токена!"
  }
  $selecttok.tok configure -values $::listtok
  $selecttok.tok configure -state normal
  $selecttok.tok delete 0 end
  $selecttok.tok insert end $::slotid_teklab
  $selecttok.tok configure -state readonly
  #	puts "CountSlot=$i, $::listtok"
  #	puts "LEN_lists=[llength $lists]"
  #	puts "LISTS=$lists"
  if {[array size ::tokenlist] > 0} {
    set ::tokenls11sw0 $::tokenlist($::slotid_teklab)
  }
  set ret [::updatecert]
  if {$ret == 0} {
    $selecttok.tok configure -state normal
    $selecttok.tok delete 0 end
    $selecttok.tok configure -state readonly
    set ::pkcs11_status 1
  } else {
    set ::pkcs11_status 0
  }
  #Автоматическое обновление токенов если нет ниодного токена
  if {[array size ::tokenlist] == 0} {
    after 10000 ::updatetok
  }

  set wizDatacsr(keytok) 1
  #Все ОК
  return 1	
}

#Список сертификатов
proc listcerttok {} {
  #    puts "token_slotlabel=$token_slotlabel"
  #    puts "token_slotid=$token_slotid"
  set ::listx509 {}
  set listCer {}

  catch {array unset ::certs_p11}
  if {[catch {array set ::certs_p11 [$::tokenls11sw0 listcerts]} ret ]} {
    if {[string first "invalid command name" $ret] != -1} {
      return 0
    }
    tk_messageBox -title "Список сертификатов" -message "Проблемы с  токеном.\nПодключите токен или смените библиотеку\n" -detail "$ret" -icon error  -parent .
    return 0
  }

  if {[llength [array names ::certs_p11]] == 0} {
    return 1
  }
  #puts $certs

  array set ::arrayCer []
  foreach certinfo_list [array names ::certs_p11] {
    lappend listCer $certinfo_list
    continue
    unset -nocomplain certinfo
    array set certinfo $certinfo_list
    #parray certinfo
    set ::arrayCer($certinfo(pkcs11_label)) $certinfo(cert_der)
  }
  set ::listx509 $listCer

  return 1
}

proc savetext {w typetxt} {
  set tt [$w.frame2.text get 1.0 end]
  #    puts $tt
  set system_encoding [encoding system]
  saveCert $typetxt [encoding convertto $system_encoding $tt]
}

proc ::selectTok {w nametok} {
  set saveCert ".st.fr1.fr2_certs"
  set selecttok ".st.fr1.fr2_tokens"
  #    puts "selectTok=\"$nametok\""
  if {[array size ::tokenlist] == 0} {
    set ::tokeninfo "Нет токенов"
    tk_messageBox -title "Библиотека PKCS#11" -icon info -message "Нет подключенных токенов (0)\n"
    $saveCert.listCert configure -state normal
    $saveCert.listCert delete 0 end
    $saveCert.listCert configure -state readonly
    $selecttok.tok configure -state normal
    $selecttok.tok delete 0 end
    $selecttok.tok configure -state readonly

    return
  }
  set ::tokenls11sw0 $::tokenlist($nametok)
  set lists [listts $::handle]
  set ::tokeninfo "Информация о токене:\nМетка:\nПроизводитель:\nТип:\nСерийный номер:\nНомер слота:"
  foreach {lab slotid tokeninfo flags} $lists {
    if {$lab == $nametok } {
      set ::tokeninfo "Информация о токене:\nМетка: [lindex $tokeninfo 0]\nПроизводитель: [lindex $tokeninfo 1]\nТип: [lindex $tokeninfo 2]\nСерийный номер: [lindex $tokeninfo 3]\nНомер слота: $slotid"
      break
    }
  }
  $saveCert.listCert configure -state normal
  $saveCert.listCert delete 0 end
  set ::listx509 {}
  set ret [listcerttok]

  if {[llength $::listx509] == 0 && $ret == 1} {
    tk_messageBox -title "Выбор токена" \
    -icon info -message "Нет сертификатов на токене: " -detail "$lab"
  }
  set ::slotid_tek  $slotid
  set ::slotid_teklab  $lab
  $saveCert.listCert configure -values $::listx509
  $saveCert.listCert set [lindex $::listx509 0]
  $saveCert.listCert configure -state readonly
  if {$ret == 0} {
    tk_messageBox -title "Библиотека PKCS#11" -icon info -message "Нет подключенных токенов (1)\n"
  }
  return $ret
}

proc buildCRT {w parsecsr} {
  global yespas
  global pass
  global param3410
  variable csr_fn
  variable dir_crt
  array set pp $parsecsr
  parray pp

  #Выкуск сертификатов пользователя и SSL-сертификатов
  set capfx_f [file join $dir_crt rootCA.pfx]
  if {![file exists $capfx_f]} {
    tk_messageBox -title "Выпуск сертификат" -message "Отсутствует корневой сертификат:\n$capfx_f" -detail "Вы указали каталог:\n$dir_crt" -icon error  -parent .
    return ""
  }

  set userkey_hex $pp(pubkeyinfo)
  set userkey_bin [binary format H* $userkey_hex]
  set userkey_bin [::asn::asnSequence $userkey_bin]
  set userkey_hex
  binary scan  $userkey_bin H*  userkey_hex

  set fd [open $capfx_f]
  chan configure $fd -translation binary
  set capfx [read $fd]
  close $fd

  read_password "Введите пароль для \"[file tail $capfx_f]\""
  if { $yespas == "no" } {
    return ""
  }
  set yespas "no"
  set password $pass
  set pass ""


  set p12er [catch {array set dCertKey [::GostPfx::pfxGetSingleCertKey $capfx "$password" $::nomacver]} rp12]
  set password ""
  if {$p12er} {
    tk_messageBox -title "Выпуск сертификат" -icon error -message "Это не PKCS12 корневого сертификата или плохой пароль.(buildCRT)" -detail "$rp12"  -parent .
    return ""
  }
  if {![info exists dCertKey(certificate)]} {
    tk_messageBox -title "Выпуск сертификат" -icon error -message "В контейнере отсутствует корневой сертификат:\$capfx"  -parent .
    return ""
  }
  if {![info exists dCertKey(keyValue)]} {
    tk_messageBox -title "Выпуск сертификат" -icon error -message "В контейнере отсутствует закрытый ключ:\$capfx"  -parent .
    return ""
  }
  set cader $dCertKey(certificate)
  if {$cader == ""} {
    tk_messageBox -title "Выпуск сертификат" -message "В контейнере отсутствует сертификат:\n$capfx\n" -icon error  -parent .
    return;
  }
  set cacrt $dCertKey(certificate)
  binary scan $dCertKey(certificate) H* cacrt_hex


  set parkey $dCertKey(gost3410Paramset)
  set parkey_name $param3410($parkey)
  if {$dCertKey(keyAlg) == "1 2 643 7 1 1 1 1"} {
    set group [lcc_gost3410_2012_256_getGroupById "$parkey_name"]
    set sign_algo "1 2 643 7 1 1 3 2"
  } elseif {$dCertKey(keyAlg) == "1 2 643 7 1 1 1 2"} {
    set group [lcc_gost3410_2012_512_getGroupById "$parkey_name"]
    set sign_algo "1 2 643 7 1 1 3 3"
  } else {
    tk_messageBox -title "Выпуск сертификат" -message "Неподдерживаемый тип ключа:\n$dCertKey(keyAlg)" -icon error  -parent .
    return ""
  }
  array set parsecert [pki::x509::parse_cert $cacrt]
  array set extcert $parsecert(extensions)
  binary scan  $cader H* cacrt_hex
  array set infopk [pki::pkcs11::pubkeyinfo $cacrt_hex]
  array set retpk [parse_key_gost $infopk(pubkeyinfo)]
  #Идентификатор ключа УЦ
  set pk_bin [binary format H* $retpk(pubkey)]
  set pkcs11id_bin [lcc_sha1 $pk_bin]

  set key {}
  lappend key "group"
  lappend key $group
  lappend key "privkey"
  lappend key $dCertKey(keyValue)
  lappend key "pubkeyinfo"
  lappend key $userkey_hex
  lappend key "issuer"
  lappend key $parsecert(issuer)
  lappend key "issuer_id"
  lappend key $pkcs11id_bin
  #В сутках 86400 секунд
  set secday 86400
  # В году секунд
  set secyear [expr {$secday * 365}]
  set notbefor [clock seconds]
  set notafter [expr {$notbefor + ($::yearcert * $secyear) + ($::dayscert * $secday) }]
  set crt [::pki::x509::create_self_cert $parsecsr $key $::snforcert $notbefor $notafter [list ] $::formatCSR $sign_algo]
  if {$crt == ""} {
    tk_messageBox -title "Выпуск сертификат" -icon error -message "Невозможно создать сертификат из запроса" -parent .
    destroy $w
    return ""
  }
  incr ::snforcert
  set nameforcrt [file tail $csr_fn]
  set nameforcrt "$nameforcrt.crt"
  set namecrt [file join $dir_crt $nameforcrt]
  set fd [open $namecrt w]
  chan configure $fd -translation binary
  puts -nonewline $fd $crt
  close $fd
  destroy $w
  tk_messageBox -title "Выпуск сертификат" -message "Сертификат сохранён в файле:\n$namecrt"  -icon info  -parent .
}

proc createpointCA {point} {

  set pointca [::asn::asnSequence \
  [::asn::asnObjectIdentifier "1 3 6 1 5 5 7 1 1"] \
  [::asn::asnOctetString  \
  [::asn::asnSequence \
  [::asn::asnSequence \
  [::asn::asnObjectIdentifier "1 3 6 1 5 5 7 48 2"] \
  [::asn::asnContext 6 $point] \
  ] \
  ] \
  ] \
  ]
  return $pointca
}

proc createIdKind {typeid} {
  set idkind [::asn::asnSequence \
  [::asn::asnObjectIdentifier "1 2 643 100 114"] \
  [::asn::asnOctetString  \
  [::asn::asnInteger $typeid] \
  ] \
  ]
  return $idkind
}

# openURL:
#    Sends a command to the user's web browser to view a webpage given
#    its URL.
#
proc openURL {url} {
  global typesys
  global macos
  #  global windowsOS
  set windowsOS 0
  if {$typesys == "win32"} {
    set windowsOS 1
  }
  #  busyCursor .
  if {$windowsOS} {
    # On Windows, use the "start" command:
    regsub -all " " $url "%20" url
    if {[string match $::tcl_platform(os) "Windows NT"]} {
      catch {exec $::env(COMSPEC) /c start $url &}
    } else {
      catch {exec start $url &}
    }
  } elseif {$macos} {
    # On Mac OS X use the "open" command:
    catch {exec open $url &}
  } else {
    # First, check if xdg-open works:
    if {! [catch {exec xdg-open $url &}] } {
      #lauch default browser seems ok, nothing more to do
    } elseif {[file executable [auto_execok firefox]]} {
      # Mozilla seems to be available:
      # First, try -remote mode:
      if {[catch {exec /bin/sh -c "$::auto_execs(firefox) -remote 'openURL($url)'"}]} {
        # Now try a new Mozilla process:
        catch {exec /bin/sh -c "$::auto_execs(firefox) '$url'" &}
      }
    } elseif {[file executable [auto_execok iceweasel]]} {
      # First, try -remote mode:
      if {[catch {exec /bin/sh -c "$::auto_execs(iceweasel) -remote 'openURL($url)'"}]} {
        # Now try a new Mozilla process:
        catch {exec /bin/sh -c "$::auto_execs(iceweasel) '$url'" &}
      }
    } elseif {[file executable [auto_execok mozilla]]} {
      # First, try -remote mode:
      if {[catch {exec /bin/sh -c "$::auto_execs(mozilla) -remote 'openURL($url)'"}]} {
        # Now try a new Mozilla process:
        catch {exec /bin/sh -c "$::auto_execs(mozilla) '$url'" &}
      }
    } elseif {[file executable [auto_execok www-browser]]} {
      # Now try a new Mozilla process:
      catch {exec /bin/sh -c "$::auto_execs(www-browser) '$url'" &}
    } elseif {[file executable [auto_execok netscape]]} {
      # OK, no Mozilla (poor user) so try Netscape (yuck):
      # First, try -remote mode to avoid starting a new netscape process:
      if {[catch {exec /bin/sh -c "$::auto_execs(netscape) -raise -remote 'openURL($url)'"}]} {
        # Now just try starting a new netscape process:
        catch {exec /bin/sh -c "$::auto_execs(netscape) '$url'" &}
      }
    } else {
      foreach executable {iexplorer opera lynx w3m links epiphan galeon
      konqueror mosaic amaya browsex elinks} {
        set executable [auto_execok $executable]
        if [string length $executable] {
          # Is there any need to give options to these browsers? how?
          set command [list $executable $url &]
          catch {exec /bin/sh -c "$executable '$url'" &}
          break
        }
      }
    }
  }
  #  unbusyCursor .
}

proc readdistr {urldistr w} {
  global typesys
  global myHOME
  set dir [tk_chooseDirectory -initialdir $myHOME -title "Каталог для дистрибутива" -parent $w]
  if {$typesys == "win32" } {
    if { "after#" == [string range $dir 0 5] } {
      set dir ""
    }
  }
  if {$dir == ""} {
    return
  }
  .topclock.lclock configure -text "Начался процесс загрузки\n\nдистрибутива\n\n[file tail $urldistr]\n\nПодождите некоторое время!"
  .topclock configure -text "Идет процесс загрузки"
  place .topclock -in .st.fr1.fr2_certs.labCert  -relx 1.0 -rely 0.0 -relwidth 3.5
  tk busy hold ".st.fr1"
  tk busy hold ".st.fr3"

  set filedistr [readca $urldistr]
  if {$filedistr != ""} {
    set f [file join $dir [file tail $urldistr]]
    set fd [open $f w]
    chan configure $fd -translation binary
    puts -nonewline $fd $filedistr
    close $fd
    tk_messageBox -title "Загрузить дистрибутив" -icon info -message "Дистрибутив сохранен в файле\n$f"  -parent .topclock
  } else {
    tk_messageBox -title "Загрузить дистрибутив" -icon info -message "Не удалось загрузить дистрибутив \n$urldistr"  -parent .topclock
  }
  tk busy forget ".st.fr1"
  tk busy forget ".st.fr3"
  place forget .topclock
}

proc rect2window {w tw th} {
  #Считываем размеры главного окна в пикселях
  set rw [winfo screenwidth $w]
  set rh [winfo screenheight $w]
  set geometr $tw
  append geometr "x"
  append geometr $th
  if { $rw <= $rh } {
    append geometr "+0+0"
  } else {
    #Координаты главного окна
    set rgeom [wm geometry $w]
    set rgf [string first "x" $rgeom]
    set rw [string range $rgeom 0 $rgf-1]
    set rg [string first "+" $rgeom]
    set xx [string range $rgeom $rgf+1 $rg-1]
    set rg1 [string range $rgeom $rg+1 end]
    if {$rw <= $tw} {
      append geometr +$rg1
    } else {
      set off [expr ($rw - $tw) / 2]
      set rg2 [string first "+" $rg1]
      incr rg
      incr rg2 -1
      set offw [string range $rg1 0 $rg2]
      set offw1 [expr $offw + $off]
      incr rg2 2
      set offw2 [string range $rg1 $rg2  end]
      set offw2 [expr $offw2 + ($xx - $th)/2]
      append geometr "+$offw1+$offw2"

    }
  }
  #Возвращаем геометрию дляцентрируемого окна
  return $geometr
}

proc aboutUtil {w type parse_csr} {
  variable asnraw
  global typesys
  global dn_fields_ru

  if {$type == 0 } {
    set title {Об утилите cryptoarmpkcs}
  } elseif {$type == 2} {
    set title "Криптографические механизмы токена"
  } elseif {$type == 1} {
    array set csr_parse $parse_csr
    set title "Запрос: \"$csr_parse(filecsr)\""
    set titlecrt "Просмотр запроса на сертификат: \"[file tail $csr_parse(filecsr)]\""
    unset csr_parse(filecsr)
    #	parray csr_parse
  } elseif {$type == 7} {
    set title {Выпуск сертификата}
    array set csr_parse $parse_csr
#Точка распространения корневого сертификата
    if {$::pointca != ""} {
      append csr_parse(extensions_bin) [createpointCA $::pointca]
    }
#Тип идентификации владельца сертификата
    set ::typeIdKind [lsearch $::listkind $::tekIdKind]
    if {$::typeIdKind >= 0 && $::typeIdKind < 4} {
      append csr_parse(extensions_bin) [createIdKind $::typeIdKind]
    }
    #	parray csr_parse
  } elseif {$type == 3 || $type == 5} {
    set title "Cертификат: \"$parse_csr\""
    set titlecrt "Просмотр сертификата: \"[file tail $parse_csr]\""
  } elseif {$type == 6 } {
    set title "Просмотр сертификата (PKCS12)"
  } elseif {$type == 8 || $type == 9} {
    set title "Просмотр ASN1-структуры"
  } elseif {$type == 4} {
    set title "Сертификат подписанта"
  } else {
    puts "Неизвестный объект"
    return
  }
  catch {destroy $w}
  toplevel $w -bg skyblue -bd 3

  #Центрируем справочное окно в основном окне
  update idletasks
  set geometr [rect2window "." "530" "470" ]
  wm geometry $w $geometr
  #Окно не может перекрываться (yes)
  wm attributes $w -topmost yes   ;# stays on top - needed for Linux
  wm geometry $w $geometr
  if {$type == 0 } {
    wm minsize $w 80 33
  } else {
    wm minsize $w 80 30
  }
  wm title $w $title
  wm iconphoto $w icon11_24x24
  frame $w.txt -bg skyblue -bd 0
  pack $w.txt -side top -expand 1 -fill both
  #Для Win32, почему-то не видит сверху
  ttk::style layout RoundedFrame {
    RoundedFrame -sticky nsew
  }

  ttk::frame  $w.txt.frame1 -style RoundedFrame -padding 10
  pack $w.txt.frame1  -fill x
  if {$type == 3 || $type == 5 || $type == 1} {
    label $w.txt.frame1.label1 -text $titlecrt -bg white -font TkDefaultFontBold
  } else {
    label $w.txt.frame1.label1 -text $title -bg white -font TkDefaultFontBold
  }
  pack $w.txt.frame1.label1 -fill none -pady {0 1mm}

  ttk::frame  $w.butt -style RoundedFrame -padding 10
  pack $w.butt -expand 0 -fill x -side bottom
  ttk::button $w.butt.ok -text "Ok" -command "destroy $w" -style MyBorder.TButton
  if {$type == 7} {
    ttk::button $w.butt.save -text "Выпуск сертификата" -command "destroy $w;buildCRT $w [list [array get csr_parse]]" -style MyBorder.TButton
  } else {
    if {$type == 8 || $type == 9} {
      ttk::button $w.butt.save -text "Сохранить" -command "savetext $w.txt 4" -style MyBorder.TButton
    } else {
      ttk::button $w.butt.save -text "Сохранить" -command "savetext $w.txt 4" -style MyBorder.TButton
    }
    if {$type == 0} {
      set ::entryd ""
      entry $w.butt.lab -textvariable ::entryd -highlightthickness 1 -highlightbackground skyblue -highlightcolor skyblue
      pack $w.butt.lab -side top  -pady {0 0} -fill x -expand 1  -padx {0 5}
    }
  }

  pack $w.butt.ok -side right -padx {4 5} -pady 2
  pack $w.butt.save -side right  -pady 2

  set worig $w
  ttk::frame  $w.txt.frame2 -style RoundedFrame -padding 10
  pack $w.txt.frame2 -fill both -expand 1
  set w $w.txt.frame2

  text $w.text -setgrid true -autosep 1  -width 60 -height 20 -wrap word -bg #fcfefc -highlightthickness 0 -highlightbackground skyblue -highlightcolor skyblue -relief flat
  if {$type == 1 || $type == 7 || $type == 3 || $type == 4 || $type == 5  || $type == 6 } {

    $w.text tag configure bold -font TkDefaultFontBold
    $w.text tag configure super -offset 4p -font TkDefaultFont
    $w.text tag configure sub -offset -2p -font TkDefaultFont
    $w.text tag configure margins -lmargin1 4m -lmargin2 12m -rmargin 10m
    $w.text tag configure margins1 -lmargin1 2m -lmargin2 2.2i -rmargin 2m -spacing1 1p -spacing2 1p -spacing3 1p
    $w.text tag configure margins11 -lmargin1 2m -lmargin2 2.2i -rmargin 2m -spacing1 1p -spacing2 1p -spacing3 1p -font TkFixedFont
    $w.text tag configure margins2 -lmargin1 6m -lmargin2 2.2i -rmargin 2m -spacing1 1p -spacing2 1p -spacing3 1p
    $w.text tag configure spacing -spacing1 10p -spacing2 2p -lmargin1 12m -lmargin2 6m -rmargin 10m
    $w.text configure -tabs {1m 2.2i}
  }
  bind $w.text <ButtonPress-3> {showTextMenu %W %x %y %X %Y}

  ttk::scrollbar $w.vsb -orient vertical -command [list $w.text yview]
  pack $w.vsb -side right -fill y  -in $w
  pack $w.text -padx {1 1} -pady {2 0} -side left -fill both -expand 1
  $w.text configure -yscrollcommand [list $w.vsb set]

  $w.text tag configure tagAbout -foreground blue -font {Times 10 bold italic}

  if {$type == 3} {
    ::fileWithCert $w.text $parse_csr "" $type
    $w.text configure -state disabled
    return
  }
  if {$type == 4 || $type == 6} {
    ::fileWithCert $w.text $parse_csr $parse_csr $type
    $w.text configure -state disabled
    return
  }
  if {$type == 5} {
    ::fileWithCert $w.text "" $parse_csr $type
    $w.text configure -state disabled
    return
  }
  if {$type == 0 } {
    contentabout $w
  } elseif {$type == 2} {
    $w.text configure -background white
    $w.text insert end "\tКриптографические механизмы токена $::slotid_teklab\n\n" tagAbout
    #puts "HANDLE:ID:LAB=$::handle : $::slotid_tek : $::slotid_teklab"
    set llmech [pki::pkcs11::listmechs $::handle $::slotid_tek]
    foreach mech $llmech {
      $w.text insert end $mech
      $w.text insert end "\n"
    }
  } elseif {$type == 8 || $type == 9} {
    #type = 8 или 9 - разбор ASN1-структуры, 8 - полный (код для tag-ов) , 9 - без кода
    $w.text configure -background white
    if {$asnraw} {
      $w.text insert end "\t\tASN1-структура в расширенном формате\n\n" tagAbout
    } else {
      $w.text insert end "\t\tASN1-структура\n\n" tagAbout
    }
    #Должно быть так
    if {$type == 8} {
      set raw 1
    } else {
      set raw 0
    }
    #	update

    set ret [DER_PrettyPrint $w.text $parse_csr $raw]
    if {$ret < 0} {
      catch {$w.text tag configure rawAsn -foreground red}
      catch {$w.text insert end "\n\t\tРазбор прекращен.\n\n\tВ файле находится плохая ASN1-структура.\n\tВ полне возможно вы ошиблись с форматом файла\n\tПроверьте путь к файлу или содержимое файла.\n" rawAsn}
    }

  } else {
    #puts "Содержимое запроса"
    #parray csr_parse
    set lsub [split $csr_parse(subject) ","]
    set lsub [del_comma $lsub]
    #    puts $lsub

    $w.text insert end [mc "Subject Name"] bold
    $w.text insert end "\n"
    foreach a $lsub {
      set ind [string first "=" $a]
      if {$ind == -1 } { continue }
                              	
      set oidsub [string trim [string range $a 0 $ind-1]]
      #puts "oidsub=$oidsub"
      #puts "DN_oidsub=$dn_fields($oidsub)"
      if {[info exists dn_fields_ru($oidsub)]} {
        #		set nameoid " ($dn_fields_ru($oidsub))"
        set nameoid "$dn_fields_ru($oidsub)"
      } else {
        set nameoid ""
      }

      #	puts $nameoid
      set oidval "[mc [string trim [string range $a $ind+1 end]]]"

      if {$oidsub == "GIVENNAME"} {
        set oidsub "GV"
      }
      set oidsub "$nameoid ($oidsub)"
      $w.text insert end "\t$oidsub\t$oidval\n"  margins1
    }
    unset csr_parse(subject)
    $w.text insert end [mc "Public Key Info"] bold
    $w.text insert end "\n"
    if {[string range $csr_parse(pubkey_algo) 0 7] == "1.2.643." || [string range $csr_parse(pubkey_algo) 0 7] == "1 2 643 " || [string range $csr_parse(pubkey_algo) 0 7] == "ГОСТ Р 3" || [string range $csr_parse(pubkey_algo) 0 7] == "GOST R 3"} {
      set nalgo [::pki::_oid_number_to_name $csr_parse(pubkey_algo)]
      $w.text insert end "\t[mc "Key Algorithm"]:\t$nalgo\n"  margins1
      $w.text insert end "\t[mc "Key Parameters"]:\n"  margins1
      array set ret [parse_key_gost $csr_parse(pubkeyinfo)]
      #	parray ret
      $w.text insert end "\t[mc "sign param"]:\t[mc $ret(paramkey)]\n"  margins2
      if {$ret(hashkey) != ""} {
        $w.text insert end "\t[mc "hash param"]:\t[mc $ret(hashkey)]\n"  margins2
      }
      set sek 4
      if {[string range $ret(pubkey) 2 3] != 40} {
        set sek 6
      }
      set pk [edithex [string range $ret(pubkey) $sek end]]
      $w.text insert end "\t[mc "Public Key"]:\t$pk\n"  margins11
    } else {
      if {[string range $csr_parse(pubkey_algo) 0 2] == "rsa" } {
        $w.text insert end "\t[mc "Key Algorithm"]:\tRSA\n"  margins1
        $w.text insert end "\t[mc "Key Size"]:\t$csr_parse(l)\n"  margins2
        $w.text insert end "\t[mc "Public Key"]:\t[edithex $csr_parse(pubkey)]\n"  margins11
      } else {
        $w.text insert end "\t[mc "Key Algorithm"]:\t$csr_parse(pubkey_algo)\n"  margins1
        $w.text insert end "\t[mc "Key Info"]:\t[edithex $csr_parse(pubkeyinfo)]\n" margins11
      }
    }
    unset csr_parse(pubkey_algo)
    unset csr_parse(pubkeyinfo)	
    array set extcert $csr_parse(extensions)
    if {[info exists extcert(1.2.643.100.111)]} {
      #subjectSignTools
      #puts "SUBJECTSINGT=$extcert(1.2.643.100.111)"

      array set pol [subjectpol [lindex $extcert(1.2.643.100.111) 1]]
      $w.text insert end [mc "subjectSignTool"] bold
      $w.text insert end "\n"
      $w.text insert end "\t[mc "User CKZI"]:\t$pol(isspol1)\n"  margins1
      #	parray pol
      unset extcert(1.2.643.100.111)
    }
    if {[info exists extcert(id-ce-keyUsage)]} {
      $w.text insert end [mc "Key Usage"] bold
      $w.text insert end "\n"

      set ku [extku [lindex $extcert(id-ce-keyUsage) 1]]
      $w.text insert end "\t[mc "Usages"]:\t[mc [lindex $ku 0]]\n"  margins1
      for {set i 1 } { $i < [llength $ku] } {incr i} {
        $w.text insert end "\t\t[lindex $ku $i]\n"  margins1
      }
      #	puts $ku
      if {[lindex $extcert(id-ce-keyUsage) 0] == 1} {
        set critcert [mc "Yes"]
      } else {
        set critcert [mc "No"]
      }
      $w.text insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
      unset extcert(id-ce-keyUsage)
    }
    if {[info exists extcert(2.5.29.37) ]} {
      $w.text insert end [mc "Extended Key Usage"] bold
      $w.text insert end "\n"
      set listusage [extkeyuse [lindex $extcert(2.5.29.37) 1]]
      set oidt [string map {" " "."} [lindex $listusage 0]]
      if {[info exists ::payoid($oidt) ]} {
        set poid " ($::payoid($oidt))"
      } else {
        set poid ""
      }
      $w.text insert end "\t[mc "Allowed Purposes"]:\t$oidt$poid\n"  margins1
      for {set i 1 } { $i < [llength $listusage] } {incr i} {
        set oidt [string map {" " "."} [lindex $listusage $i]]
        if {[info exists ::payoid($oidt) ]} {
          set poid " ($::payoid($oidt))"
        } else {
          set poid ""
        }
        $w.text insert end "\t\t$oidt$poid\n"  margins1
      }
      if {[lindex $extcert(2.5.29.37) 0] == 1} {
        set critcert [mc "Yes"]
      } else {
        set critcert [mc "No"]
      }
      $w.text insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
      unset extcert(2.5.29.37)
    }

    set listext [array get extcert]
    foreach {a b} $listext {
      $w.text insert end [mc "Extension"] bold
      $w.text insert end "\n"
      $w.text insert end "\t[mc "Identifier"]:\t$a\n"  margins1
      $w.text insert end "\t[mc "Value"]:\t[edithex [lindex $b 1]]\n"  margins1
      if {[lindex $b 0] == 1} {
        set critcert [mc "Yes"]
      } else {
        set critcert [mc "No"]
      }
      $w.text insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
    }
    unset csr_parse(extensions)
    catch {unset csr_parse(extensions_bin)}
    set sign_algo $csr_parse(signature_algo)
    unset csr_parse(signature_algo)
    set signat $csr_parse(signature)
    unset csr_parse(signature)
    unset csr_parse(verify)
    set attrms [array get csr_parse]
    puts "ATTRMS=$attrms"
    foreach {a b} $attrms {
      $w.text insert end [mc "Attribute"] bold
      $w.text insert end "\n"
      $w.text insert end "\t[mc "Identifier"]:\t$a\n"  margins1
      $w.text insert end "\t[mc "Value"]:\t[edithex $b]\n"  margins1
    }	
    parray csr_parse
    $w.text insert end [mc "Signature"] bold
    $w.text insert end "\n"
    $w.text insert end "\t[mc "Signature Algorithm"]\t[mc "$sign_algo)"]\n"  margins1
    $w.text insert end "\t[mc "Signature"]:\t[edithex $signat]\n"  margins11


  }

  #    wm protocol $w WM_DELETE_WINDOW ";"
  $w.text configure -state disabled
  set w $worig
  catch {grab set $w}
  catch {tkwait window $w}
}

proc chainocsp {chain_hex} {
  set chain [binary format H* $chain_hex]
  set ret {}
  ::asn::asnGetSequence chain c_par_first
  while {[string length $c_par_first] > 0 } {
    #Выбираем очередную последовательность (sequence)
    ::asn::asnGetSequence c_par_first c_par
    #Выбираем oid из последовательности
    ::asn::asnGetObjectIdentifier c_par c_type
    set tas1 [::pki::_oid_number_to_name $c_type]
    #Выбираем установленное значение
    ::asn::asnGetContext c_par c_par_two
    #Ищем oid с адресом корневого сертификата
    if {$tas1 == "1.3.6.1.5.5.7.48.2" } {
      #Читаем очередной корневой сертификат
      lappend ret "CA Issuers"
      lappend ret $c_par
      #	    puts "CA (oid=$tas1)=$c_par"
    } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } {
      lappend ret "OCSP"
      lappend ret $c_par
      #	    puts "OCSP server (oid=$tas1)=$c_par"
    }
  }
  # Цепочка закончилась
  return $ret
}

proc crlpoints {crl_hex} {
  set crl [binary format H* $crl_hex]
  set ret {}
  ::asn::asnGetSequence crl p_crl_first
  set lencontspec 4
  while {[string length $p_crl_first] > 0 } {
    #Выбираем очередную последовательность (sequence)
    ::asn::asnGetSequence p_crl_first c_par
    #Пропускаем contextspecific - 0xA0
    ::asn::asnGetContext c_par context_0xa0
    ::asn::asnPeekByte c_par peek_tag
    while {$peek_tag == 0xA0} {
      ::asn::asnGetContext c_par context_0xa0
      ::asn::asnPeekByte c_par peek_tag
    }
    ::asn::asnGetContext c_par ux
    #	puts $c_par
    lappend ret $c_par
  }
  return $ret
}

proc idkind {idkind_hex} {
  set ret ""
  set kind [binary format H* $idkind_hex]
  ::asn::asnGetInteger kind idk
  switch $idk {
    0 { set ret [lindex $::listkind 0]}
    1 { set ret [lindex $::listkind 1]}
    2 { set ret [lindex $::listkind 2]}
    3 { set ret [lindex $::listkind 3]}
    default {
	set ret "$idk - неизвестный тип идентификации"
    }
  }
  return $ret
}

proc altname {alt_hex} {
  set ret {}
  set listname [binary format H* $alt_hex]
  ::asn::asnGetSequence listname names
  while {[string length $names] > 0 } {
    ::asn::asnGetByte names tag
    if {$tag == 0x82 || $tag == 0x81 || $tag == 0x87} {
      #0x82 DNS Name ; 0x81 - RFC 822
      #	    puts "0x82"
      ########################
      ::asn::asnGetByte names taglen
      set len82 [format "%i" $taglen]
      #	    puts $len82
      incr len82 -1
      if {$tag == 0x82 } {
        #Читаем очередной корневой сертификат
        lappend ret "DNS Name"
      } elseif {$tag == 0x81 } {
        #		lappend ret "RFC822 Name"
        lappend ret "Email"
      } elseif {$tag == 0x87 } {
        lappend ret "IP-Address"
      } else {
        lappend ret [format "0x%2x" $tag]
      }
      if {$tag != 0x87 } {
        lappend ret [string range $names 0 $len82]
      } else {
        set ip_b [string range $names 0 $len82]
        lappend ret [ip::ToString $ip_b]
      }
      #	    puts $ret
      incr len82
      set a [string range $names $len82 end]
      set names $a
    }
  }
  return $ret
}

proc keyperiod {per_hex} {
  set per [binary format H* $per_hex]
  array set ret [list]
  ::asn::asnGetSequence per validaty
  ::asn::asnGetByte validaty tag
  if {$tag == 0x80} {
    ::asn::asnGetByte validaty tag
    set len80 [format "%i" $tag]
    incr len80 -1
    set ret(notBefore) [string range $validaty 0 $len80]
    incr len80
    set a [string range $validaty $len80 end]
    set validaty $a
    ::asn::asnGetByte validaty tag
  } else {
    set ret(notBefore) ""
  }
  if {$tag != 0x81} {
    set ret(After) ""
    return [array get ret]
  }
  ::asn::asnGetByte validaty tag
  set len81 [format "%i" $tag]
  incr len81 -1
  set ret(notAfter) [string range $validaty 0 $len81]
  incr len81
  return [array get ret]
}


proc autkeyid {autkey_hex} {
  set autkey [binary format H* $autkey_hex]
  array set ret [list]
  #########################################
  set autkey [binary format H* $autkey_hex]
  array set ret [list]
  ::asn::asnGetSequence autkey fullkey
  #Чтение KEY ID
  ::asn::asnGetContext fullkey - cont
  #    puts "LEN=[string length $fullkey]"
  binary scan $cont H* ret(authKeyID)
  while {[string length $fullkey]} {
    ::asn::asnGetByte fullkey tag1
    ::asn::asnGetLength fullkey tag
    set len80 [format "0x%x" $tag]
    set ee [string range $fullkey 0 0]
    if { $ee == 0} {
      ::asn::asnGetSequence fullkey autdn
      set ret(issuer) [::pki::x509::_dn_to_string $autdn]
      ::asn::asnGetContext fullkey - sernum
      binary scan $sernum H* ret(sernum)
      break
    }
  }

  return [array get ret]
}

proc parse_key_gost {pubkeyinfo_hex} {
  array set ret [list]

  set pubkeyinfo [binary format H* $pubkeyinfo_hex]

  ::asn::asnGetSequence pubkeyinfo pubkey_algoid
  ::asn::asnGetObjectIdentifier pubkey_algoid ret(pubkey_algo)
  ::asn::asnGetBitString pubkeyinfo pubkey

  #		"1.2.643.2.2.19" -
  #		"1.2.643.7.1.1.1.1" -
  #		"1.2.643.7.1.1.1.2"
  #	gost2001, gost2012-256,gost2012-512
  set pubkey [binary format B* $pubkey]
  binary scan $pubkey H* ret(pubkey)
  ::asn::asnGetSequence pubkey_algoid pubalgost
  #OID - параметра
  ::asn::asnGetObjectIdentifier pubalgost ret(paramkey)
  if {$pubalgost != ""} {
    #OID - Функция хэша
    ::asn::asnGetObjectIdentifier pubalgost ret(hashkey)
  } else {
    set ret(hashkey) ""
  }
  #puts "ret(paramkey)=$ret(paramkey)\n"
  #puts "ret(hashkey)=$ret(hashkey)\n"
  #parray ret
  return [array get ret]

}
proc parse_anykey_gost {fullasnkey} {
  array set ret [list]
  ::asn::asnGetSequence fullasnkey prkey
  #У закрытого? ключа есть/может быть версия
  ::asn::asnPeekByte prkey peek_tag
  if {$peek_tag == 0x02} {
    # Version number is optional, if missing assumed to be value of 0
    ::asn::asnGetInteger prkey version
  }

  ::asn::asnGetSequence prkey pubkey_algoid
  ::asn::asnGetObjectIdentifier pubkey_algoid ret(pubkey_algo)
  if {[string first "1 2 643 " $ret(pubkey_algo)] == -1} {
    return [array get ret]
  }
  ::asn::asnGetSequence pubkey_algoid key_param
  ::asn::asnGetObjectIdentifier key_param ret(par_sign)
  ::asn::asnGetObjectIdentifier key_param ret(par_hash)
  #У открытого ключа может быть еще bitstring
  ::asn::asnPeekByte prkey peek_tag
  if {$peek_tag == 0x03} {
    # Version number is optional, if missing assumed to be value of 0
    ::asn::asnGetBitString prkey ret(key_value)
    set ret(key_value) [binary format B* $ret(key_value)]
  } else {
    ::asn::asnGetOctetString prkey ret(key_value)
  }
  ::asn::asnGetOctetString ret(key_value) ret(key_value)
  binary scan $ret(key_value) H* ret(key_value_hex)
  return [array get ret]
}


proc issuerpol {iss_hex} {
  array set ret [list]
  set iss [binary format H* $iss_hex]
  ::asn::asnGetSequence iss iss_pol
  for {set i 1} {[string length $iss_pol] > 0}  {incr i} {
    ::asn::asnGetUTF8String iss_pol ret(isspol$i)
  }
  return [array get ret]
}
proc subjectpol {iss_hex} {
  puts "SUBJECTPOL=$iss_hex"
  set iss [binary format H* $iss_hex]
  array set ret [list]
  #    ::asn::asnGetSequence iss iss_pol
  #Из-за того, что длина раньше попадала не в байтах, а в символах, то обрабатывалось не все
  set i 1
  #set ret(isspol$i) [encoding convertfrom utf-8 [string range $iss 2 end]]
  #    for {set i 1} {[string length $iss] > 0}  {incr i} {
  ::asn::asnGetUTF8String iss ret(isspol$i)
  #    }
  return [array get ret]
}

proc extku {ku_hex} {
  #set ::ku_options {"Digital signature" "Non-Repudiation" "Key encipherment" "Data encipherment" "Key agreement" "Certificate signature" "CRL signature" "Encipher Only" "Decipher Only" "Revocation list signature"}
  #puts "KU_hex=$ku_hex"
  set ku [binary format H* $ku_hex]
  ::asn::asnGetBitString ku ku_bin
  set ret {}
  #puts "KU=$ku_bin"
  #puts "KU len=[string length $ku_bin]"
  for {set i 0} {$i < [string length $ku_bin]}  {incr i} {
    #	puts "I=$i"
    if {[string range $ku_bin $i $i] > 0 } {
      lappend ret [lindex $::ku_options $i]
    }
  }
  #    puts $ret
  return $ret
}

proc extpol {pol_hex} {
  set pol [binary format H* $pol_hex]
  set ret {}
  ::asn::asnGetSequence pol oid_pol
  for {set i 1} {[string length $oid_pol] > 0}  {incr i} {
    ::asn::asnGetSequence oid_pol oid_pol1
    ::asn::asnGetObjectIdentifier oid_pol1 ret1
    lappend ret $ret1
  }
  #    puts $ret
  return $ret
}

proc extkeyuse {keyuse_hex} {
  set use [binary format H* $keyuse_hex]
  set ret {}
  ::asn::asnGetSequence use oid_use
  for {set i 1} {[string length $oid_use] > 0}  {incr i} {
    ::asn::asnGetObjectIdentifier oid_use ret1
    lappend ret $ret1
  }
  #    puts "EXTKEYUSE=$ret"
  return $ret
}

proc edithex {hex} {
  set c ""
  set l [string length $hex]
  #    puts $l
  for {set j 0 } { $j < $l} {incr j +2} {
    set c "$c[string range $hex $j $j+1] "
  }
  return [string toupper [string trimright $c]]
}


proc del_comma {ldn} {
  set lret {}
  set ff ""
  foreach el $ldn {
    if {[string first "=" $el] != -1} {
      if {$ff != ""} {
        lappend lret $ff
      }
      set ff $el
    } else {
      set ff "$ff,$el"
    }
  }
  lappend lret $ff
  return $lret
}

proc cert2der {data} {
  if {[string first "-----BEGIN CERTIFICATE-----" $data] != -1} {
    #	set data [string map {"\015\012" "\n"} $data]
    set data [string map {"\r\n" "\n"} $data]
  }
  array set parsed_cert [::pki::_parse_pem $data "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]
  set asnblock $parsed_cert(data)
  return $asnblock
}

proc ::fileWithCert {w nick cert_hex typecert} {
  global home
  global loadfile
  global dn_fields_ru
  set ::dercert ""
  set ::parsecert ""
  $w delete 0.0 end
  puts "fileWithCert=$typecert"
  #Файл с сертификатм из командной строки
  set comline 1
  ###############
  array set cert_parse []
  if {$cert_hex != "" && $nick == $cert_hex} {
    set asndata [binary  format H* $cert_hex]
    if {[catch {array set cert_parse [::pki::x509::parse_cert $asndata]} rc]} {
      wm state ".about" withdraw
      tk_messageBox -title "Разбор сертификата" -icon error -message "$file" -detail "Выбранный файл не содержит сертификата"
      return
    }
    set ::dercert $asndata
    array set cert_parse [pki::x509::parse_cert $asndata]
    #Читаем публичный ключ
    #puts "CERT_PARSE_filewith=$certinfo_list"
    array set infopk [pki::pkcs11::pubkeyinfo $cert_hex ]

    set cert_parse(pubkeyinfo) $infopk(pubkeyinfo)
    if {$typecert == 6} {
      set ::tekcert "pkcs12"
    } else {
      set ::tekcert "pkcs7"
    }
  } elseif {$nick == "" } {
    unset -nocomplain cert_parse
    set file $cert_hex
                    	
    set fd [open $file]
    chan configure $fd -translation binary
    set data [read $fd]
    close $fd
    set asndata [cert2der $data]
    if {$asndata == "" } {
      wm state ".about" withdraw
      tk_messageBox -title "Разбор сертификата" -icon error -message "$file" -detail "Выбранный файл не содержит сертификата"
      return
    }

    if {[catch {array set cert_parse [::pki::x509::parse_cert $asndata]} rc]} {
      wm state ".about" withdraw
      tk_messageBox -title "Разбор сертификата" -icon error -message "$file" -detail "Выбранный файл не содержит сертификата"
      return
    }
    set ::dercert $asndata
    binary scan  $asndata H*  cert_hex
    #	array set infopk [pki::pkcs11::pubkeyinfo $cert_hex [list pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]]
    array set infopk [pki::pkcs11::pubkeyinfo $cert_hex]

    set cert_parse(pubkeyinfo) $infopk(pubkeyinfo)
    set ::tekcert "file"
  } else {

    ############
    set ::dercert [binary format H* [lindex $::certs_p11($nick) 0]]
    array set cert_parse [pki::x509::parse_cert $::dercert]
    #Читаем публичный ключ
    #puts "CERT_PARSE_filewith=$certinfo_list"
    array set infopk [pki::pkcs11::pubkeyinfo [lindex $::certs_p11($nick) 0]]

    set cert_parse(pubkeyinfo) $infopk(pubkeyinfo)

    #Экспорт в текстовом виде	.saveCert.labExp.but.butSave configure -text [mc "Export"]
    set ::tekcert "pkcs11"
  }

  #  parray cert_parse
  $w insert end [mc "Issued Certificate"] bold
  $w insert end "\n"
  $w insert end "\t[mc "Version"]:\t$cert_parse(version)\n"  margins1
  set ::sncert "$cert_parse(serial_number)"
  set sn_bin [::asn::asnBigInteger [math::bignum::fromstr $cert_parse(serial_number)]]
  set sn_bin [string range $sn_bin 2 end]
  binary scan $sn_bin H* sn_hex

  $w insert end "\t[mc "Serial Number"] (hex):\t[edithex $sn_hex]\n"  margins1
  $w insert end "\t[mc "Serial Number"] (dec):\t$cert_parse(serial_number)\n"  margins1
  set ::notafter  $cert_parse(notAfter)
  set t $cert_parse(notAfter)
  #puts "T=$t"
  set notafter [clock format $t -format "%d/%m/%Y %R %Z"]
  set ::notbefore $cert_parse(notBefore)
  set t $cert_parse(notBefore)
  #puts "T=$t"

#  $w insert end [mc "Validity"] bold
#  $w insert end "\n"
  set notbefore [clock format $t -format "%d/%m/%Y %R %Z"]
  $w insert end "\t[mc "Not Valid Before"]:\t$notbefore\n"  margins1
  $w insert end "\t[mc "Not Valid After"]:\t$notafter\n"  margins1
  set ver [mc "Expires"]
  #    puts  $cert_parse(subject)
  set ::subjectcert "$cert_parse(subject)"
  set lsub [split $cert_parse(subject) ","]
  set lsub [del_comma $lsub]
  #    puts $lsub

  $w insert end [mc "Subject Name"] bold
  $w insert end "\n"
  foreach a $lsub {
    set ind [string first "=" $a]
    if {$ind == -1 } { continue }
                    	
    set oidsub [string trim [string range $a 0 $ind-1]]
    if {[info exists dn_fields_ru($oidsub)]} {
      set nameoid "$dn_fields_ru($oidsub)"
    } else {
      set nameoid ""
    }

    #	puts $nameoid
    set oidval "[mc [string trim [string range $a $ind+1 end]]]"
    if {$oidsub == "CN"} {
      set ::cn_subject  $oidval
    }

    if {$oidsub == "GIVENNAME"} {
      set oidsub "GV"
    }
    set oidsub "$nameoid ($oidsub)"
    #	set oidsub "$oidsub$nameoid"
    $w insert end "\t$oidsub\t$oidval\n"  margins1
  }
  $w insert end [mc "Issuer Name"] bold
  $w insert end "\n"
  #    puts  $cert_parse(issuer)
  set ::issuercert "$cert_parse(issuer)"
  set liss [split $cert_parse(issuer) ","]
  set liss [del_comma $liss]
  #    puts $liss

  foreach a $liss {
    set ind [string first "=" $a]
    if {$ind == -1 } { continue }
    set oidsub [string trim [string range $a 0 $ind-1]]
    if {[info exists dn_fields_ru($oidsub)]} {
      set nameoid "$dn_fields_ru($oidsub)"
    } else {
      set nameoid ""
    }

    set oidval "[mc [string trim [string range $a $ind+1 end]]]"
    if {$oidsub == "CN"} {
      set ::cn_issuer  $oidval
    }

    set oidsub "$nameoid ($oidsub)"
    #	set oidsub "$oidsub$nameoid"
    $w insert end "\t$oidsub\t$oidval\n"  margins1
  }
  $w insert end [mc "Public Key Info"] bold
  $w insert end "\n"
  if {[string range $cert_parse(pubkey_algo) 0 7] == "1.2.643." || [string range $cert_parse(pubkey_algo) 0 7] == "ГОСТ Р 3" || [string range $cert_parse(pubkey_algo) 0 7] == "GOST R 3"} {
    $w insert end "\t[mc "Key Algorithm"]:\t[mc $cert_parse(pubkey_algo)]\n"  margins1
    $w insert end "\t[mc "Key Parameters"]:\n"  margins1
    array set ret [parse_key_gost $cert_parse(pubkeyinfo)]
    #	parray ret
    $w insert end "\t[mc "sign param"]:\t[mc $ret(paramkey)]\n"  margins2
    if {$ret(hashkey) != ""} {
      $w insert end "\t[mc "hash param"]:\t[mc $ret(hashkey)]\n"  margins2
    }
    set sek 4
    if {[string range $ret(pubkey) 2 3] != 40} {
      set sek 6
    }
    set pk [edithex [string range $ret(pubkey) $sek end]]
    $w insert end "\t[mc "Public Key"]:\t$pk\n"  margins11
    #Идентификатор ключа получателя
    set pk_bin [binary format H* $ret(pubkey)]
    set pkcs11id_bin [lcc_sha1 $pk_bin]
    binary scan $pkcs11id_bin H* ::pkcs11id
  } else {
    if {[string range $cert_parse(pubkey_algo) 0 2] == "rsa" } {
      set pkcs11id_bin [lcc_sha1 [binary format H* $cert_parse(pubkey)]]
      binary scan $pkcs11id_bin H* ::pkcs11id
      $w insert end "\t[mc "Key Algorithm"]:\tRSA\n"  margins1
      $w insert end "\t[mc "Key Size"]:\t$cert_parse(l)\n"  margins2
      $w insert end "\t[mc "Public Key"]:\t[edithex $cert_parse(pubkey)]\n"  margins11
    } else {
      $w insert end "\t[mc "Key Algorithm"]:\t$cert_parse(pubkey_algo)\n"  margins1
      $w insert end "\t[mc "Key Info"]:\t[edithex $cert_parse(pubkeyinfo)]\n" margins11
    }
  }
#UniqueID
  if {[info exists cert_parse(subjectUniqueID)]} {
	$w insert end [mc "Subject Unique ID:"] bold
	$w insert end "\t\t$cert_parse(subjectUniqueID)\n"  margins1
  }
  if {[info exists cert_parse(issuerUniqueID)]} {
	$w insert end [mc "Issuer Unique ID:"] bold
	$w insert end "\t\t$cert_parse(issuerUniqueID)\n"  margins1
  }
  array set extcert $cert_parse(extensions)
    $w insert end [mc "          Расширения сертификата (Extensions)\n"] bold
  #    parray extcert
  if {[info exists extcert(id-ce-basicConstraints)]} {
    $w insert end [mc "Basic Constraints (2.5.29.19)"] bold
    $w insert end "\n"
    set basic $extcert(id-ce-basicConstraints)
    #	puts $basic
    if {[lindex $basic 1] == 1} {
      set typecert [mc "Yes"]
    } else {
      set typecert [mc "No"]
    }
    $w insert end "\t[mc "Certificate Authority"]:\t$typecert\n"  margins1
    if {[lindex $basic 2] == -1} {
      set lencert [mc "Unlimited"]
    } else {
      set lencert [lindex $basic 2]
    }
    $w insert end "\t[mc "Max Path Length"]:\t$lencert\n"  margins1
    if {[lindex $basic 0] == 1} {
      set critcert [mc "Yes"]
    } else {
      set critcert [mc "No"]
    }
    $w insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
    unset extcert(id-ce-basicConstraints)
  }
  #  1 false -1
  # первое поле критичность 1 - Да, false - нет
  # второе поле УЦ 1 - Да, false - нет
  #Третье поле - длина пути : -1 - неограниченный, или значение 0 и т.д.
  if {[info exists extcert(1.2.643.100.112)]} {
    #issuerSignTools
    array set pol [issuerpol [lindex $extcert(1.2.643.100.112) 1]]
    $w insert end [mc "issuerSignTool (1.2.643.100.112)"] bold
    $w insert end "\n"
    $w insert end "\t[mc "Name CKZI"]:\t$pol(isspol1)\n"  margins1
    $w insert end "\t[mc "Name CA"]:\t$pol(isspol2)\n"  margins1
    $w insert end "\t[mc "Certificate SKZI CA"]:\t$pol(isspol3)\n"  margins1
    $w insert end "\t[mc "Certificate CA"]:\t$pol(isspol4)\n"  margins1
    #	parray pol
    unset extcert(1.2.643.100.112)
  }
  if {[info exists extcert(1.2.643.100.111)]} {
    #subjectSignTools
    array set pol [subjectpol [lindex $extcert(1.2.643.100.111) 1]]
    $w insert end [mc "subjectSignTool (1.2.643.100.111)"] bold
    $w insert end "\n"
    $w insert end "\t[mc "User CKZI"]:\t$pol(isspol1)\n"  margins1
    #	parray pol
    unset extcert(1.2.643.100.111)
  }
  if {[info exists extcert(id-ce-keyUsage)]} {
    $w insert end [mc "Key Usage (2.5.29.15)"] bold
    $w insert end "\n"

    set ku [extku [lindex $extcert(id-ce-keyUsage) 1]]
    $w insert end "\t[mc "Usages"]:\t[mc [lindex $ku 0]]\n"  margins1
    for {set i 1 } { $i < [llength $ku] } {incr i} {
      $w insert end "\t\t[lindex $ku $i]\n"  margins1
    }
    #	puts $ku
    if {[lindex $extcert(id-ce-keyUsage) 0] == 1} {
      set critcert [mc "Yes"]
    } else {
      set critcert [mc "No"]
    }
    $w insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
    unset extcert(id-ce-keyUsage)
  }
  if {[info exists extcert(id-ce-certificatePolicies)]} {
    $w insert end [mc "Certificate Policies (2.5.29.32)"] bold
    $w insert end "\n"
    set lpol [extpol [lindex $extcert(id-ce-certificatePolicies) 1]]
    $w insert end "\t[mc "Policy Name"]:\t[mc [::pki::_oid_number_to_name [lindex $lpol 0]]]\n"  margins1
    for {set i 1 } { $i < [llength $lpol] } {incr i} {
      $w insert end "\t\t[mc [::pki::_oid_number_to_name [lindex $lpol $i]]]\n"  margins1
    }
    #	puts $ku
    if {[lindex $extcert(id-ce-certificatePolicies) 0] == 1} {
      set critcert [mc "Yes"]
    } else {
      set critcert [mc "No"]
    }
    $w insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
    unset extcert(id-ce-certificatePolicies)
  }
  if {[info exists extcert(id-ce-subjectKeyIdentifier)]} {
    $w insert end [mc "Subject Key Identifier (2.5.29.14)"] bold
    $w insert end "\n"
    $w insert end "\t[mc "Key ID"]:\t[edithex [string range [lindex $extcert(id-ce-subjectKeyIdentifier) 1] 4 end]]\n"  margins1
    #	set ::pkcs11id [string range [lindex $extcert(id-ce-subjectKeyIdentifier) 1] 4 end]
    unset extcert(id-ce-subjectKeyIdentifier)
  }
  if {[info exists extcert(id-ce-privateKeyUsagePeriod) ]} {
    $w insert end [mc "Key Usage Period (2.5.29.16)"] bold
    $w insert end "\n"
    array set keyperiod [keyperiod [lindex $extcert(id-ce-privateKeyUsagePeriod) 1]]
    #	parray keyperiod
    set t $keyperiod(notBefore)
    set year [string range $t 0 3]
    set month [string range $t 4 5]
    set day [string range $t 6 7]
    set hour [string range $t 8 9]
    set minute [string range $t 10 11]

    #	puts  "$day $month $year $hour $minute"
    set notbefore "$day/$month/$year $hour:$minute"

    set t $keyperiod(notAfter)
    set notafter "[string range $t 6 7]/[string range $t 4 5]/[string range $t 0 3] [string range $t 8 9]:[string range $t 10 11]"
    $w insert end "\t[mc "Not Valid Before"]:\t$notbefore\n"  margins1
    $w insert end "\t[mc "Not Valid After"]:\t$notafter\n"  margins1

    if {[lindex $extcert(id-ce-privateKeyUsagePeriod) 0] == 1} {
      set critcert [mc "Yes"]
    } else {
      set critcert [mc "No"]
    }
    $w insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
    unset extcert(id-ce-privateKeyUsagePeriod)
  }
  if {[info exists extcert(id-ce-authorityKeyIdentifier) ]} {
    $w insert end [mc "Certificate Authority Key Identifier (2.5.29.35)"] bold
    $w insert end "\n"
    array set autkey [autkeyid [lindex $extcert(id-ce-authorityKeyIdentifier) 1]]
    $w insert end "\t[mc "Key ID"]:\t[edithex $autkey(authKeyID)]\n"  margins1
    if {[info exists autkey(issuer) ] } {
      $w insert end "\t[mc "Directory Name"]:\t$autkey(issuer)\n"  margins1
    }
    if {[info exists autkey(sernum) ]} {
      $w insert end "\t[mc "Serial Number"]:\t[edithex $autkey(sernum)]\n"  margins1
    }
    unset extcert(id-ce-authorityKeyIdentifier)
  }
  if {[info exists extcert(2.5.29.37) ]} {
    $w insert end [mc "Extended Key Usage (2.5.29.37)"] bold
    $w insert end "\n"
    set listusage [extkeyuse [lindex $extcert(2.5.29.37) 1]]
    set oidt [string map {" " "."} [lindex $listusage 0]]
    if {[info exists ::payoid($oidt) ]} {
      set poid " ($::payoid($oidt))"
    } else {
      set poid ""
    }
    $w insert end "\t[mc "Allowed Purposes"]:\t$oidt$poid\n"  margins1
    for {set i 1 } { $i < [llength $listusage] } {incr i} {
      set oidt [string map {" " "."} [lindex $listusage $i]]
      if {[info exists ::payoid($oidt) ]} {
        set poid " ($::payoid($oidt))"
      } else {
        set poid ""
      }
      $w insert end "\t\t$oidt$poid\n"  margins1
    }
    if {[lindex $extcert(2.5.29.37) 0] == 1} {
      set critcert [mc "Yes"]
    } else {
      set critcert [mc "No"]
    }
    $w insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
    unset extcert(2.5.29.37)
  }
  set ::chaincert ""
  if {[info exists extcert(1.3.6.1.5.5.7.1.1)]} {
    $w insert end [mc "Authority information Accesss (1.3.6.1.5.5.7.1.1)"] bold
    $w insert end "\n"
    set listchain [chainocsp [lindex $extcert(1.3.6.1.5.5.7.1.1) 1]]
    #	puts $listchain
    foreach {a b} $listchain {
      $w insert end "\t[mc $a]:\tURI:$b\n"  margins1
    }
    set ::chaincert [lindex $extcert(1.3.6.1.5.5.7.1.1) 1]
    #	puts "CHAIN=[lindex $extcert(1.3.6.1.5.5.7.1.1) 1]"
    unset extcert(1.3.6.1.5.5.7.1.1)
  }

  set ::crlfile ""
  if {[info exists extcert(2.5.29.31)]} {
    $w insert end "CRL Distribution Points (2.5.29.31)" bold
    $w insert end "\n"
    #	puts "CRL=$extcert(2.5.29.31)"
    set listcrl [crlpoints [lindex $extcert(2.5.29.31) 1]]
    #	puts $listcrl
    foreach {crlp} $listcrl {
      $w insert end "\tDistribution Point:\tURI:$crlp\n"  margins1
    }
    set ::crlfile  $listcrl
    unset extcert(2.5.29.31)
  }
  #extcert(id-ce-issuerAltName)          = false 3000
  #extcert(id-ce-subjectAltName)
  if {[info exists extcert(id-ce-issuerAltName)]} {
    $w insert end [mc "Issuer Alt Name (2.5.29.18)"] bold
    $w insert end "\n"
    #	puts "ALT ISSUER=$extcert(id-ce-issuerAltName)"
    set listalt [altname [lindex $extcert(id-ce-issuerAltName) 1]]
    foreach {a b} $listalt {
      $w insert end "\t[mc $a]:\tURI:$b\n"  margins1
    }
    unset extcert(id-ce-issuerAltName)
  }
  if {[info exists extcert(id-ce-subjectAltName)]} {
    $w insert end [mc "Subject Alt Name (2.5.29.17)"] bold
    $w insert end "\n"
    #	puts "ALT=$extcert(id-ce-subjectAltName)"
    set listalt [altname [lindex $extcert(id-ce-subjectAltName) 1]]
    foreach {a b} $listalt {
      $w insert end "\t[mc $a]:\tURI:$b\n"  margins1
    }
    unset extcert(id-ce-subjectAltName)
  }
  if {[info exists extcert(1.2.643.100.114)]} {
#IdentificationKind - как выдавался сертификат
    $w insert end "Identification Kind (1.2.643.100.114)" bold
    $w insert end "\n"
    #	puts "CRL=$extcert(2.5.29.31)"
    set ikind [idkind [lindex $extcert(1.2.643.100.114) 1]]
#    set crit [lindex $extcert(1.2.643.100.114) 0]
    if {[lindex $extcert(1.2.643.100.114) 0] == 1} {
      set crit [mc "Yes"]
    } else {
      set crit [mc "No"]
    }
    $w insert end "\tType Identification Kind:\t$ikind\n"  margins1
    $w insert end "\t[mc "Critical"]:\t$crit\n"  margins1
    unset extcert(1.2.643.100.114)
  }

  set listext [array get extcert]
  foreach {a b} $listext {
    $w insert end [mc "Extension ($a)"] bold
    $w insert end "\n"
#    $w insert end "\t[mc "Identifier"]:\t$a\n"  margins1
    $w insert end "\t[mc "Value"]:\t[edithex [lindex $b 1]]\n"  margins1
    if {[lindex $b 0] == 1} {
      set critcert [mc "Yes"]
    } else {
      set critcert [mc "No"]
    }
#    set critcert [lindex $b 0]
    $w insert end "\t[mc "Critical"]:\t$critcert\n"  margins1
  }
  $w insert end [mc "          Расширения сертификата (Extensions) исчерпаны\n"] bold

  $w insert end [mc "Signature"] bold
  $w insert end "\n"
  $w insert end "\t[mc "Signature Algorithm"]\t[mc "$cert_parse(signature_algo)"]\n"  margins1
  $w insert end "\t[mc "Signature"]:\t[edithex $cert_parse(signature)]\n"  margins11

  $w insert end [mc "Certificate Fingerprints"] bold
  $w insert end "\n"

  set fingerprint_sha256 [::sha2::sha256 $::dercert]
  #    set fingerprint_sha1 [::sha1::sha1  $::dercert]
  set fingerprint_sha1_bin [lcc_sha1  $::dercert]
  binary scan $fingerprint_sha1_bin H* fingerprint_sha1

  $w insert end "\t[mc "SHA1"]:\t[edithex $fingerprint_sha1]\n"  margins11
  $w insert end "\t[mc "SHA256"]:\t[edithex $fingerprint_sha256]\n"  margins11

  set ::parsecerttxt [$w get 1.0 end]
}

# Parse a PKCS#10 CSR
proc ::pki::pkcs::parse_csr_gost {csr} {
  array set ret [list]
  set data $csr
  set headcsr "-----BEGIN NEW CERTIFICATE REQUEST-----"
  set tailcsr "-----END NEW CERTIFICATE REQUEST-----"
  if {[string first "-----BEGIN " $data] != -1} {
    #	set data [string map {"\015\012" "\n"} $data]
    set data [string map {"\r\n" "\n"} $data]
    if {[string first "-----BEGIN CERTIFICATE REQUEST-----" $data] != -1} {
      set headcsr "-----BEGIN CERTIFICATE REQUEST-----"
      set tailcsr "-----END CERTIFICATE REQUEST-----"
    } elseif {[string first "-----BEGIN NEW CERTIFICATE REQUEST-----" $data] != -1} {
      set headcsr "-----BEGIN NEW CERTIFICATE REQUEST-----"
      set tailcsr "-----END NEW CERTIFICATE REQUEST-----"
    } else {
      return -code error "not csr"
    }
    #puts "HEAD=$headcsr\nTAIL=$tailcsr"
    #puts "CERT=$data"
  } elseif {[string range $data 0 0] != "0"} {
    return -code error "not csr"
  }

  array set parsed_csr [::pki::_parse_pem $data $headcsr $tailcsr]
  set csr $parsed_csr(data)

  ::asn::asnGetSequence csr cert_req_seq
  ::asn::asnGetSequence cert_req_seq cert_req_info

  set cert_req_info_saved [::asn::asnSequence $cert_req_info]
  ::asn::asnGetInteger cert_req_info version
  ::asn::asnGetSequence cert_req_info name
  ::asn::asnGetSequence cert_req_info pubkeyinfo
  binary scan $pubkeyinfo H* ret(pubkeyinfo)
  ::asn::asnGetSequence pubkeyinfo pubkey_algoid
  ::asn::asnGetObjectIdentifier pubkey_algoid ret(pubkey_algo)

  ################Extensi
  set extensions_list [list]

  if {$cert_req_info != ""} {
    ::asn::asnGetContext cert_req_info - extensions_ctx
    while {$extensions_ctx != ""} {
      ::asn::asnGetSequence extensions_ctx extensions
      ::asn::asnGetObjectIdentifier extensions extensions4
      #puts "parse_cert_gost: extensions4=$extensions4"
      if {$extensions4 != "1 2 840 113549 1 9 14"} {
        #Различные атрибуты, например от CAPICOM
        ::asn::asnPeekByte extensions peek_tag
        if {$peek_tag == 0x1} {
          ::asn::asnGetBoolean extensions ext_critical
        } else {
          set ext_critical false
        }
        ::asn::asnGetSet extensions ext_value_seq
        binary scan $ext_value_seq H* ext_value_seq_hex

        set ret($extensions4) $ext_value_seq_hex
        continue
      }
      ::asn::asnGetSet extensions extensions1
      #puts "parse_cert_gost: extensions4=$extensions4 1"
                              			
      if {$extensions4 == "1 2 840 113549 1 9 14"} {
        #puts "parse_cert_gost: extensions4=РАСШИРЕНИЕ"
        ::asn::asnGetSequence extensions1 extensions
        #Запоминаем расширение для подстановки в сертификат
        set ret(extensions_bin) $extensions

        while {$extensions != ""} {
          ::asn::asnGetSequence extensions extension
          ::asn::asnGetObjectIdentifier extension ext_oid
          ::asn::asnPeekByte extension peek_tag
          if {$peek_tag == 0x1} {
            ::asn::asnGetBoolean extension ext_critical
          } else {
            set ext_critical false
          }
          ::asn::asnGetOctetString extension ext_value_seq

          set ext_oid [::pki::_oid_number_to_name $ext_oid]

          set ext_value [list $ext_critical]

          switch -- $ext_oid {
            id-ce-basicConstraints {
              ::asn::asnGetSequence ext_value_seq ext_value_bin

              if {$ext_value_bin != ""} {
                ::asn::asnGetBoolean ext_value_bin allowCA
              } else {
                set allowCA "false"
              }

              if {$ext_value_bin != ""} {
                ::asn::asnGetInteger ext_value_bin caDepth
              } else {
                set caDepth -1
              }
                                                                      						
              lappend ext_value $allowCA $caDepth
            }
            default {
              binary scan $ext_value_seq H* ext_value_seq_hex
              lappend ext_value $ext_value_seq_hex
            }
          }

          lappend extensions_list $ext_oid $ext_value
        }
        #puts "parse_cert_gost: extensions4=РАСШИРЕНИЕ END"
      }
    }
  }
  set ret(extensions) $extensions_list

  ###########Ext end
  ::asn::asnGetSequence cert_req_seq signature_algo_seq
  ::asn::asnGetObjectIdentifier signature_algo_seq signature_algo
  ::asn::asnGetBitString cert_req_seq signature_bitstring

  # Convert parsed fields to native types
  set signature [binary format B* $signature_bitstring]
  set ret(subject) [::pki::x509::_dn_to_string $name]
  binary scan $signature H* ret(signature)
  #puts "SIGN_ALGO=$signature_algo"
  if {$signature_algo == "1 2 643 7 1 1 3 3"} {
    set stribog stribog512
  } elseif {$signature_algo == "1 2 643 7 1 1 3 2"} {
    set stribog stribog256
  } elseif {$signature_algo == "1 2 643 2 2 3"} {
    set stribog gostr3411
  } else {
    set ret(signature_algo) [::pki::_oid_number_to_name $signature_algo]
    return -code error "CSR Signature not GOST"
  }
  #puts "STRIBOG=$stribog"
  set ret(signature_algo) [::pki::_oid_number_to_name $signature_algo]
  set ret(verify) 0
  if {$::pkcs11_module == ""} {
    set llmech ""
    set err -1
    tk_messageBox -title "Просмотр запроса на сертификат" -message "Нету подключенных токенов" -detail "Проверка подписи запроса невозможна" -icon info  -parent .
    set vercrs 0
    return [array get ret]
  } else {
    set llmech [pki::pkcs11::listmechs $::handle $::slotid_tek]
    #puts  "MECH=$llmech"
    set vercrs 1
    switch -- $stribog {
      stribog256 {
        set err [string first "0xD4321012" $llmech]
      }
      stribog512 {
        set err [string first "0xD4321013" $llmech]
      }	
      gostr3411 {
        set err [string first "0x1210" $llmech]
      }	
      default {
        set err -1
      }
    }
    if {$err == -1} {
      tk_messageBox -title "Просмотр запроса на сертификат" -message "Токен $::slotid_teklab\nне поддерживает алгоритм\n\t $stribog" -detail "Проверка подписи запроса невозможна" -icon info  -parent .
      set vercrs 0
    }
  }

  if {$vercrs} {
    set digest_hex    [$::tokenls11sw0 digest $stribog $cert_req_info_saved]
    set ret(verify) [$::tokenls11sw0  verify $digest_hex $ret(signature) $ret(pubkeyinfo)]
  }
  #parray ret
  return [array get ret]
}

proc ::viewCert {type nick} {
  #tk_messageBox -title "Просмотр сертификата PKCS7" -icon info -message "type=$type NICK=$nick"
  if {$type == "pkcs11"} {
    if {$nick == ""} {
      tk_messageBox -title "Просмотр сертификата с токена" -icon info -message "Отсутствует сертификат"  -parent .
      return
    }
    #    puts "arrayCer=$::arrayCer($nick)"
    set saveCert ".st.fr1.fr2_certs"
    set ind [$saveCert.listCert current]
    set nick  [lindex $::listx509 $ind]
    aboutUtil .about 3 $nick
    return
  }
  set certp7 ""
  if {$type == "pkcs7"} {
    if {$nick == "" } {
      tk_messageBox -title "Просмотр сертификата" -icon info -message "Не выбран файл с электронной подписью"
      return
    }
    #    puts "View from PKCS7=$nick"
    foreach p7t $::lp7 {
      #puts "P7=$p7t"
      array set p7 $p7t
      #parray p7
      #Ищем подписанта
      if {$p7(nickcert) == $nick} {
        set certp7 $p7(cert_hex)
      }
    }
    if {$certp7 == ""} {
      tk_messageBox -title "Просмотр сертификата" -icon info -message "Не нашли сертификата для \n$nick"
      return
    }
    aboutUtil .about 4 $certp7
    return
  }
  set fcert ""
  if {$type == "file"} {
    aboutUtil .about 5 $nick
    return
  }
  if {$type == "pkcs12"} {
    if {$nick == ""} {
      tk_messageBox -title "Просмотр сертификата из PKCS12" -icon info -message "Не выбран файл с контейнером PKCS12"  -parent .
      return
    }
    aboutUtil .about 6 $nick
    return
  }
}

proc ::viewCSR {file type} {
  #type 1 - view csr; 7 - create certificate
  variable dir_crt
  if {$file == ""} {
    tk_messageBox -title "Просмотр запроса на сертификат" -icon info -message "Не выбран файл с запросом на сертификат"  -parent .
    return
  }
  set mes ""
  if {$type == 7 } {
    if {$dir_crt == ""} {
      tk_messageBox -title "Выпуск сертификата" -message "Не выбран каталог для хранения сертификатов и ключей." -icon error  -parent .
      return
    }
    set mes "\nСертификат не может быть создан\n"
  }
  set fd [open $file]
  chan configure $fd -translation binary
  set data [read $fd]
  close $fd

  if {[catch {array set csr_parse [::pki::pkcs::parse_csr_gost $data]} rc]} {
    tk_messageBox -title "Просмотр запроса на сертификат" -icon error -message "$file" -detail "Выбранный файл не содержит запроса (parse_csr_gost) на сертификат\n$rc"  -parent .
    return
  }
  #    parray csr_parse
  if {$csr_parse(verify) != 1} {
    tk_messageBox -title "Просмотр запроса на сертификат" -icon error -message "Запрос:\n$file $mes" -detail "Подпись запроса (parse_csr_gost) на сертификат не верна или не проверялась"  -parent .
    if {$type == 7 } {
      return
    }
  }

  set loadfile $file
  if {$type == 1} {
    set csr_parse(filecsr) $file
  }
  aboutUtil .about $type [array get csr_parse]

}

proc showTextMenu {w x y rootx rooty} {
  catch {destroy .contextMenu}
  menu .contextMenu -tearoff false
  .contextMenu add command -label "Копировать в буфер обмена" -command {clipboard clear;clipboard append [selection get]}
  .contextMenu add command -label "Просмотреть выделенный блок" -command {::viewasn1 2;}

  tk_popup .contextMenu $rootx $rooty
  .contextMenu configure -activebackground #39b5da
  .contextMenu configure -background #e0e0da
}


proc showContextMenu {w x y rootx rooty} {
  catch {destroy .contextMenu}
  menu .contextMenu -tearoff false
  if {$::pkcs11_module != ""} {
    .contextMenu add command -label "Список криптомеханизмов" -command {aboutUtil .about 2 ""}
  }
  .contextMenu add command -label "О программе" -command {aboutUtil .about 0 ""}

  tk_popup .contextMenu $rootx $rooty
  .contextMenu configure -activebackground #39b5da
  .contextMenu configure -background #e0e0da
}

proc showMenuCert {w x y rootx rooty} {
  catch {destroy .menuCert}
  menu .menuCert -tearoff false
  .menuCert configure -title "Сертификат"
  if {$::pkcs11_module != ""} {
    .menuCert add command -label "Просмотреть сертификат" -command {variable nickCert;if {[info exists nickCert]} {::viewCert "pkcs11" $nickCert}}
    .menuCert add command -label "Проверить подпись" -command {workOpCertP11 0}
    .menuCert add command -label "Валидность по СОС/CRL" -command {workOpCertP11 1}
    .menuCert add command -label "Экспорт сертификата (PEM)" -command {workOpCertP11 2}
    .menuCert add command -label "Экспорт сертификата (DER)" -command {workOpCertP11 3}
    .menuCert add command -label "Удалить" -command {workOpCertP11 4}
    .menuCert add command -label "Переименовать" -command {workOpCertP11 5}
  }
  .menuCert add separator
  .menuCert add command -label "О программе" -command {aboutUtil .about 0 ""}

  tk_popup .menuCert $rootx $rooty
  .menuCert configure -activebackground #39b5da
  .menuCert configure -background #e0e0da
}

proc ::setTekFrame {tekFr newTekFr i} {
  global yespas
  global pass
  set prez 0
  if {[.st.fr1.fra82.b$i cget -state] == "disabled"} {
    return
  }
  if {$i != 0 && $i != 4 && $i != 6 && $i != 8 && $i != 9 && $i != 10 && $i < 11} {
    #    set prez [::updatetok]
  }
  #  if {$::pressBut == $i} {}
  if {$::pressBut == $i && $i == 0} {
    return
  }
  if {$i == 0} {
    pack forget .st.fr1.fr2_tokens
    pack forget .st.fr1.fr2_certs
    pack forget .st.fr1.labLogo 		
  }

  #puts "setTekFrame_0=$::pressBut"
  #puts "setTekFrame_i=$i"
  #puts "setTekFrame_1=$tekFr"
  #puts "setTekFrame_2=$newTekFr"
  #puts "setTekFrame_3=$tekFr$::pressBut"

  if {$i == 1 || $i == 2 || $i == 3 || $i == 4 || $i == 5 || $i == 6 || $i == 7 || $i == 8 || $i == 9 || $i == 10 || $i == 11 || $i == 12} {
    pack forget .st.fr1.labLogo 		
    pack .st.fr1.fr2_tokens  -in .st.fr1 -anchor ne  -expand 0 -fill x -side top -padx {2 2} -pady {0 0}
    pack .st.fr1.fr2_certs  -in .st.fr1 -anchor ne  -expand 0 -fill x -side top -padx {2 2} -pady {0 0}
    .st.fr1.fra82.b0 configure -state normal
  }
  pack forget $tekFr$::pressBut
  pack $newTekFr -in .st.fr1 -anchor ne -expand 1 -fill both -side top -padx {2 2} -pady {0 0} -ipadx 0 -ipady 0
  #puts "$::pressBut"
  if {$i == 3 && $::wizpagecsr == 0} {
    #puts "MOVE wizpage=$::wizpagecsr"
    move "csr" [lindex $::pagescsr 0]
  } elseif {$i == 9 && $::wizpagecert == 0} {
    #puts "MOVE wizpage=$::wizpagecsr"
    move "cert" [lindex $::pagescert 0]
  } elseif {$i == 5} {
    $newTekFr.text delete 1.0 end
    $newTekFr.text configure -background white
    if {[array size ::tokenlist] < 1} {
      tk_messageBox -title "Библиотека PKCS#11" -icon info -message "Нет подключенных токенов (0)\n"
      return
    }
    if {[catch {set llmech [$::tokenls11sw0 listmechs]} ret]} {
      if {$ret == ""} {
        tk_messageBox -title "Механизмы токена" -icon info -message "Нет токена. Вставьте токен и\nобновите список токенов" -parent .
      } else {
        tk_messageBox -title "Механизмы токена" -icon info -message "Нет токена. Вставьте токен и\nобновите библиотеку" -detail $ret -parent .
      }
      set ::pressBut  $i
      return
    }
    $newTekFr.text insert end "\tФлаги токена $::slotid_teklab\n" tagAbout
    if {[info exists ::sflags]} {
      $newTekFr.text insert end "$::sflags\n"
    }

    if {[info exists ::slotid_teklab]} {
      $newTekFr.text insert end "\tМеханизмы токена $::slotid_teklab\n" tagAbout
    }
    foreach mech $llmech {
      $newTekFr.text insert end $mech
      $newTekFr.text insert end "\n"
    }
  } elseif {$i == 7} {
    #puts "PAGE_I=$i"
    if {[array size ::tokenlist] == "0"} {
      tk_messageBox -title "Список объектов" -icon info -message "Нет подключенных токенов\n"
      set ::pressBut  $i
      return
    }
    set lo [::updateobj]
  }
  set ::pressBut  $i
}

proc keyParam {w tpage key} {
  global wizDatacsr
  global wizDatacert
  variable opts
  global profile_options
  #Ключ генерится на токене keytok = 1
  if {$tpage == "csr" } {
    set keytok $wizDatacsr(keytok)
    set defaultkey $wizDatacsr(typekey)
    set defaultpar $wizDatacsr(parkey)
  } else {
    set keytok $wizDatacert(keytok)
    set defaultkey $wizDatacert(typekey)
    set defaultpar $wizDatacert(parkey)
  }
  #tk_messageBox -title "Тип ключа" -icon info -message "defaultkey=$defaultkey\ndefaultpar=$defaultpar\nw=$w"  -parent .
  #Ключ генерится на Lcc и хранится в файле keytok = 0
  if {$keytok == 1 } {
    set lists [listts $::handle]
    if {[llength $lists] == 0 } {
      tk_messageBox -title "Тип ключа" -icon info -message "Токены отсутствуют" -detail "Установлена генерация ключей в Lcc\nКлюч будет сохранен в файле" -parent .
      set wizDatacsr(keytok) 0
      set wizDatacert(keytok) 0
      return
    }
  }
  array set opts [array get profile_options]
  set a [string last "." $w ]
  set a [expr {$a - 1}]
  set f [string range $w 0 $a]

  #puts "keyParam f=$f"
  #puts "keyParam tpage =$tpage"
  #puts "keyParam key=$key"
  set listBits {}
  $f.c4 delete 0 end
  set key1 [$f.c3 get]

  if {$tpage == "csr" && $keytok == 1} {
    set llmech [pki::pkcs11::listmechs $::handle $::slotid_tek]
    #puts "key=$key1"
    #puts  "MECH=$llmech"
    set err -1
    switch -- $key1 {
      gost2001 {
        set err [string first "0x1200" $llmech]
        if {$err != -1 } {
          set err [string first "0x1210" $llmech]
        }
      }
      gost2012_256 {
        set err [string first "0x1200" $llmech]
        if {$err != -1 } {
          set err [string first "0xD4321012" $llmech]
        }
      }
      gost2012_512 {
        set err [string first "0xD4321005" $llmech]
      }	
      default {
        set err -1
      }
    }
    if {$err == -1} {
      tk_messageBox -title "Ключевая пара" -message "" -detail "$::tokeninfo\n[mc {Unsupported key type for certificate request}]\n\t$key1" -icon error  -parent $w
      return
    }
  }

  if {$key1 == "gost2012_512"} {
    #    $f.l4 configure -text "Параметры для ГОСТ-12-512"
    set listBits {1.2.643.7.1.2.1.2.1 1.2.643.7.1.2.1.2.2 1.2.643.7.1.2.1.2.3}
    if {[lsearch $listBits $defaultpar] == -1 } {
      set defaultpar [lindex $listBits 1]
    }
    $f.c4 insert end $defaultpar
  } elseif {$key1 == "gost2012_256"} {
    #    $f.l4 configure -text "Параметры для ГОСТ-12-256"
    set listBits {1.2.643.2.2.35.1 1.2.643.2.2.35.2  1.2.643.2.2.35.3  1.2.643.2.2.36.0 1.2.643.2.2.36.1 1.2.643.7.1.2.1.1.1 1.2.643.7.1.2.1.1.2 1.2.643.7.1.2.1.1.3 1.2.643.7.1.2.1.1.4}
    if {[lsearch $listBits $defaultpar] == -1 } {
      if {$key1 == "gost2012_256"} {
        set defaultpar [lindex $listBits 3]
      } else {
        set defaultpar [lindex $listBits 0]
      }
    }
    $f.c4 insert end $defaultpar
  } elseif {$key1 == "gost2001"} {
    #    $f.l4 configure -text "Параметры для ГОСТ-12-256"
    set listBits {1.2.643.2.2.35.1 1.2.643.2.2.35.2  1.2.643.2.2.35.3  1.2.643.2.2.36.0 1.2.643.2.2.36.1}
    if {[lsearch $listBits $defaultpar] == -1 } {
      if {$key1 == "gost2001"} {
        set defaultpar [lindex $listBits 3]
      } else {
        set defaultpar [lindex $listBits 0]
      }
    }
    $f.c4 insert end $defaultpar
  } else {
    #    $f.l4 configure -text "Параметры для неизвестного ключа"
    set listBits {A B C XA XB}
    $f.c4 insert 0 A
    set defaultpar ""
  }
  set defaultkey $key1
  $f.c4 configure -values $listBits
}

proc doneGet {token} {
  #    puts "doneGet"
  set res1 ""
  switch -- [http::status $token] {
    error {
      puts "ERROR: [http::error $token]"
    }
    eof {
      puts "EOF reading response"
    }
    ok {
      puts "OK; code: [http::ncode $token]"
      puts " Size: [http::size $token]"
      puts " Data:"
      #               puts [http::data $token]
      set res [http::data $token]
    }
  }
  http::cleanup $token
  return $res
}

proc ::create_tsq {content oidhash} {
  #Проверяем хэш контента
  switch -- $oidhash {
    "1.2.643.7.1.1.2.2" - "1 2 643 7 1 1 2 2" {
      #    "GOST R 34.11-2012-256"
      set digest_algo "stribog256"
    }
    "1.2.643.7.1.1.2.3" - "1 2 643 7 1 1 2 3" {
      #     "GOST R 34.11-2012-512"
      set digest_algo "stribog512"
    }
    "1.2.643.2.2.9" - "1 2 643 2 2 9" {
      #    "GOST R 34.10-2001 with GOST R 34.11-94"
      set digest_algo "gostr3411"
    }
    default {
      return ""
    }
  }
  set digest_hex    [pki::pkcs11::dgst $digest_algo $content ]
  #    puts "TST=$digest_hex"
  set digest_bin [binary format H* $digest_hex]

  set tsq [::asn::asnSequence \
  [::asn::asnInteger 1] \
  [::asn::asnSequence \
  [::asn::asnSequence [::asn::asnObjectIdentifier $oidhash] \
  ] \
  [::asn::asnOctetString $digest_bin] \
  ] \
  [::asn::asnBoolean true] \
  ]
  return $tsq
  #true - включить сертификат подписанта
  #		    [::asn::asnNull]
}

proc parse_crl {crl_der} {
  ::asn::asnGetSequence crl_der crl_seq
  ::asn::asnGetSequence crl_seq crl_base
  ::asn::asnPeekByte crl_base peek_tag
  if {$peek_tag == 0x02} {
    # Version number is optional, if missing assumed to be value of 0
    ::asn::asnGetInteger crl_base ret(version)
    incr ret(version)
  } else {
    set ret(version) 1
  }

  ::asn::asnGetSequence crl_base crl_full
  ::asn::asnGetObjectIdentifier crl_full ret(signtype)
  ::::asn::asnGetSequence crl_base crl_issue
  set ret(issue) [::pki::x509::_dn_to_string $crl_issue]
  binary scan $crl_issue H* ret(crl_issue_hex)
  set ret(crl_issue) [::pki::x509::_dn_to_string $crl_issue]

  ::asn::asnGetUTCTime crl_base ret(publishDate)
  return [array get ret]
}

proc parse_basic {basic_der} {
  ::asn::asnGetSequence basic_der crl_seq
  ::asn::asnGetSequence crl_seq crl_base
  ::asn::asnPeekByte crl_base peek_tag
  if {$peek_tag != 0xA1 && $peek_tag != 0xA2} {
    #0xA2 - infoteks
    puts "parse_basic Bad OCSP basic"
    return ""
  }
  set ret(typeocsp) [format {0x%2x} $peek_tag]
  ::asn::asnGetContext crl_base - bc
  binary scan $bc H* ret(ocsp_issue_hex)
  ::asn::asnGetGNTTime crl_base ret(ocspDate)
  return [array get ret]
}

proc loadocsp {urls reqoc} {
  #puts "loadocsp"
  foreach url $urls {
    set tt 0
    #Проверяем тип протокола
    if { "https://" == [string range $url 0 7]} {
      #      puts "HTTPS=$url"
      #      http::unregister https
      http::register https 443 ::tls::socket
      set tt 1
    }
    set res ""
    set token ""
    if {[catch {
      #puts "loadocsp=$url"
      if {$tt == 0} {
        set token [http::geturl $url  -type  "application/ocsp-request" -query  $reqoc]
        #      set token [http::geturl $url  -type  "application/ocsp-response" -query  $reqoc]
      } else {
        set token [http::geturl $url  -type  "application/ocsp-request" -query  $reqoc]
      }
      #	http::wait $token

    } error]} {
      puts stderr "Error while getting URL: $error"
      continue
    }
    #puts "GETURL END 3"
    #    puts [http::status $token]
    set res [doneGet $token]
    if {$res == "" } {
      continue
    }
    if {[catch { ::asn::asnGetSequence res res1 } ret] } {
      #	puts "BEDA=$res"
      tk_messageBox -title "Load OCSP" -icon info -message "Не могу получить OCSP-ответ\n$res" -detail "$ret" -parent .
      return ""
    }
    #    ::asn::asnGetSequence res res1
    set res [::asn::asnSequence $res1]
    #Читаем основной ответ
    ::asn::asnGetSequence res res1
    ::asn::asnGetEnumeration res1 succesfull
    if {$succesfull != 0} {
      puts "Error succesfull=$succesfull"
      continue
    }
    ::asn::asnGetContext res1 - resc0
    ::asn::asnGetSequence resc0 res3
    ::asn::asnGetObjectIdentifier res3 oiddata
    #puts "OIDDATA_OCSP=$oiddata"
    set oidobr  "1 3 6 1 5 5 7 48 1 1"
    #obr OCSP Basic Response
    if {$oiddata != $oidobr} {
      puts "Error oid=$oiddata"
      tk_messageBox -title "Load OCSP" -icon info -message "Плохой oid=$oiddate\n" -detail "OK=$oidobr" -parent .
      continue
    }
    ::asn::asnGetOctetString res3 derdata
    return $derdata
  }
  return ""
}


proc create_unsignattrs {certs_hex digest_algo} {
  variable createescTS
  variable chainca
  variable chaincerts
  set peekocsp1 ""
  #puts "create_unsignattrs=[llength $certs_hex]"
  set lchain ""
  set lchainref ""
  set lcrlref ""
  set lcrls ""
  set revokeRefs ""
  set certValuesFull [binary format H* [lindex $certs_hex 0]]
  if {$digest_algo == "stribog256"} {
    set digest_oid "1 2 643 7 1 1 2 2"
  } elseif {$digest_algo == "stribog512"} {
    set digest_oid "1 2 643 7 1 1 2 3"
  } else {
    #Bad digest
    return -1
  }
  set ocsp 0
  set jj 0
  #Убрать
  set certtst1 [binary  format H* [lindex $certs_hex 1]]
  #Получаем все сертификаты в виде списка
  set chainca [list ]
  set listcafull [list ]
  #puts "CREAT_UNS_INCERT=[llength $certs_hex]"
  set n 0
  set chaincerts ""
  set ee 0
  foreach cert_hex $certs_hex {
    if {$cert_hex == "" } {
      break
    }
    if {$ee == 1 } {
      break
    } else {
      incr ee
    }
                    	
    set chainca [list ]
    set cert [binary  format H* $cert_hex]
    append chaincerts $cert
    lappend listcafull $cert
    set listca1 [list ]
    set listca1 [chaincafromcert $cert]
    if {$listca1 == ""} {
      return [list "" "" "" ""]
    }
    #puts "CREAT_UNS_LISTCA=[llength $listca1]"
    foreach certf $listca1 {
      set c 0
      set lcafull $listcafull
      foreach certa $lcafull {
        #puts "certf=[string length $certf]"
        #puts "certa=[string length $certa]"
        if {$certf == $certa} {
          #puts "set c 1"
          set c 1
          break
        }
      }
      #puts "set c=$c"
                                  	
      if { $c == 0 } {
        lappend listcafull $certf
        append chaincerts $certf
      }
    }
  }
  #    puts "CREAT_UNS_ALLCERT=[llength $listcafull]"

  set lcrl ""
  #Цепочка сертификатов
  # ::oidcertValues             "1 2 840 113549 1 9 16 2 23"
  set chaincerts ""
  #	append certValuesFull $chaincerts

  #::revocationValues       "1 2 840 113549 1 9 16 2 24"
  #puts "revokREF"
  set revokValues [list ]
  set lrev [list ]
  set lcrl ""
  foreach certValue [reverse $listcafull] {
    if {$certtst1 == $certValue} {
      #puts "create_unsigner CERTTST"
      continue
    }
    #puts "create_unsign len_cert=[string length $certValue]"
    binary scan $certValue H* certhex
    foreach {caissuer servocsp} [ocspfromcert $certhex] {}
    #		puts "create_unsign caissuer=$caissuer"
    #		puts "create_unsign servocsp=$servocsp"
    if {[llength $servocsp ] > 0 } {
      #Работаем с ocsp
      #puts "create_unsign OCSP len_cert=[string length $certValue]"
      set ocsp 1
      set cert_ca [cafromlist $caissuer]
      binary scan $cert_ca H* cert_ca_hex
      set reqoc [create_req_ocsp $certhex $cert_ca_hex]
      set lcrlca [loadocsp $servocsp $reqoc]
      #Проблемы с OCSP-севрером
      if {$lcrlca == ""} {
        return -2
      }
      set basiccore $lcrlca
      #Выбираем сертификаты
      ::asn::asnGetSequence basiccore bc
      ::asn::asnGetSequence bc bc1
      ::asn::asnGetSequence bc bc2
      ::asn::asnGetObjectIdentifier bc2 oidbc
      ::asn::asnGetBitString bc bc3
      if {[string length $bc] > 0} {
        ::asn::asnPeekByte bc peek_tag
        if {$peek_tag == 0xA0} {
          #Сертификаты сервера OCSP
          ::asn::asnGetContext bc certsbc
          while {[string length $bc] > 0} {
            ::asn::asnGetSequence bc certbc
            ::asn::asnGetSequence certbc bc1
            set bc2 [::asn::asnSequence $bc1]
            set c 0
            set lcafull $listcafull
            foreach certa $lcafull {
              if {$bc2 == $certa} {
                set c 1
                break
              }
            }

            if { $c == 0 } {
              #################
              if {0} {
                array set crt_parse [pki::x509::parse_cert $bc2]
                array set extcert $crt_parse(extensions)
                if {[info exists extcert(2.5.29.37) ]} {
                  set listusage [extkeyuse [lindex $extcert(2.5.29.37) 1]]
                  set oc 0
                  set i 0
                  #		    for {set i 0 } { $i < [llength $listusage] } {incr i} {}
                  if {[llength $listusage] == 1} {
                    set oidt [string map {" " "."} [lindex $listusage $i]]
                    #puts "OIDT=$oidt"
                    if {"1.3.6.1.5.5.7.3.9" == $oidt} {
                      set oc 1
                    }
                  }
                  if {$oc == 0} {
                    lappend listcafull $bc2
                  }
                }
              }
              lappend listcafull $bc2
              ###############

              #puts "create_unsign BC len_cert=[string length $bc2]"
            }
          }
        }
      }

      #puts "create_unsignattrs=Whis OCSP=$oidbc"
    } else {
      set ocsp 0
      set lcrlca [loadcrl $certhex 1]
      #puts "create_unsignattrs=loadCRL 2"
      if { [string range $lcrlca 0 9 ] == "-----BEGIN" } {
        array set parsed_crl [::pki::_parse_pem $lcrlca "-----BEGIN X509 CRL-----" "-----END X509 CRL-----"]
        set lcrlca $parsed_crl(data)
      }
    }
    #puts "create_unsignattrs=loadCRL 2_1"
    if {$lcrlca != ""} {
      set y 0
      foreach rev $lrev {
        if {$rev == $lcrlca} {
          set y 1
          break
        }
      }
      if {$y == 1} {
        continue
      }
      lappend lrev $lcrlca
      set lcrlca1 [::asn::asnContextConstr $ocsp \
      [::asn::asnSequence \
      $lcrlca \
      ] \
      ]
      append lcrl $lcrlca1
      #ЭТО ПРОВЕРИТЬ
      lappend revokValues $lcrlca1
      if {$certtst1 == ""} {
        break
      }
    }
  }
  set lcrls $lcrl
  # ::oidrevocationRefs         "1 2 840 113549 1 9 16 2 22"
  #puts "revokREF1"
  foreach revokValue1 $revokValues {
    set peekocsp ""

    asn::asnPeekByte revokValue1 tag
    set ocsp 0
    if {$tag == 0xA1} {
      #			puts "Это OCSP"
      ::asn::asnGetContext revokValue1 -- revokValue2
      ::asn::asnGetSequence revokValue2 revokValue
      set ocsp 1
    } elseif {$tag == 0xA0} {
      #			puts "Это CRL"
      ::asn::asnGetContext revokValue1 -- revokValue2
      ::asn::asnGetSequence revokValue2 revokValue
      set ocsp 0
    } else {
      puts "Это не CRL и не OCSP=$tag"
      #Ошибка revokeValue
      return -3
    }

    set digcrl_hex [::pki::pkcs11::dgst $digest_algo $revokValue]
    set digcrl [binary format H* $digcrl_hex]
    if {$ocsp == 0} {
      #		    puts "Это CRL 1"
      array set pcrl [parse_crl $revokValue]
      #parray pcrl
      set name [binary format H* $pcrl(crl_issue_hex)]
      set revokeRef [asn::asnSequence \
      [::asn::asnSequence \
      [::asn::asnSequence \
      [::asn::asnObjectIdentifier $digest_oid] \
      ] \
      [::asn::asnOctetString $digcrl] \
      ] \
      [::asn::asnSequence \
      [::asn::asnSequence \
      $name \
      ] \
      [::asn::asnUTCTime $pcrl(publishDate)] \
      ] \
      ]
    } else {
      #			puts "Это OCSP 1"
      array set pocsp [parse_basic $revokValue]
      #parray pocsp
      set name [binary format H* $pocsp(ocsp_issue_hex)]
      set peekocsp $pocsp(typeocsp)
      set typeocsp $ocsp
      if {$pocsp(typeocsp) == "0xa2"} {
        #"0xa"2 - infoteks
        set peekocsp1 $pocsp(typeocsp)
        set typeocsp 2
      }
      set revokeRef [asn::asnSequence \
      [::asn::asnSequence \
      [::asn::asnContextConstr $typeocsp \
      $name \
      ] \
      [::asn::asnGNTTime $pocsp(ocspDate)] \
      ] \
      [::asn::asnSequence \
      [::asn::asnSequence \
      [::asn::asnObjectIdentifier $digest_oid] \
      ] \
      [::asn::asnOctetString $digcrl] \
      ] \
      ]
    }
    if {$peekocsp != "0xa2"} {
      set revokeR [::asn::asnSequence \
      [::asn::asnContextConstr $ocsp \
      [::asn::asnSequence \
      [::asn::asnSequence \
      $revokeRef \
      ] \
      ] \
      ] \
      ]
      append revokeRefs $revokeR

    } else {
      set revokeR [::asn::asnContextConstr $ocsp \
      [::asn::asnSequence \
      [::asn::asnSequence \
      $revokeRef \
      ] \
      ] \
      ]
      asn::asnGetSequence revokeRefs rrr
      append rrr $revokeR
      set revokeRefs [asn::asnSequence  $rrr]
    }
    #      append revokeRefs $revokeR
  }

  #Ссылка на сертификат подписанта не нужна?
  # ::oidCertificateRefs        "1 2 840 113549 1 9 16 2 21"
  foreach certValue $listcafull {
    if {$jj == 0} {
      incr jj
      continue
    }
    binary scan $certValue H* cert_hex
    set digcert_hex [::pki::pkcs11::dgst $digest_algo $certValue]
    set digcert [binary format H* $digcert_hex]
    #		array set infopk [pki::pkcs11::pubkeyinfo $cert_hex  [list pkcs11_handle $::handle pkcs11_slotid ::slotid_tek]]
    array set infopk [pki::pkcs11::pubkeyinfo $cert_hex ]
    set name [binary format H* $infopk(issuer)]
    set certref [::asn::asnSequence \
    [::asn::asnSequence \
    [::asn::asnSequence \
    [::asn::asnObjectIdentifier $digest_oid] \
    ] \
    [::asn::asnOctetString $digcert] \
    ] \
    [::asn::asnSequence \
    [::asn::asnSequence \
    [::asn::asnContextConstr 4 \
    $name \
    ] \
    ] \
    [binary format H* $infopk(serial_number)] \
    ] \
    ]
    append lchainref $certref
  }

  # ::oidcertValues             "1 2 840 113549 1 9 16 2 23"
  set certValuesFull ""
  set zz 0
  foreach cert $listcafull {
    if {$zz == 0 } {
      incr zz
      continue
    }
    append certValuesFull $cert
  }
  append certValuesFull [lindex $listcafull 0]

  set lchain [::asn::asnSequence \
  [::asn::asnObjectIdentifier $::oidcertValues] \
  [::asn::asnSet \
  [::asn::asnSequence $certValuesFull]
  ] \
  ]

  # ::oidCertificateRefs        "1 2 840 113549 1 9 16 2 21"
  set lchainref [::asn::asnSequence \
  [::asn::asnObjectIdentifier $::oidCertificateRefs] \
  [::asn::asnSet \
  [::asn::asnSequence $lchainref]
  ] \
  ]


  #::revocationValues       "1 2 840 113549 1 9 16 2 24"
  if {$createescTS == 2} {
    set lcrl [::asn::asnSequence \
    [::asn::asnObjectIdentifier $::revocationValues] \
    [::asn::asnSet \
    [::asn::asnSequence \
    $lcrl \
    ] \
    ] \
    ]

    # ::oidrevocationRefs         "1 2 840 113549 1 9 16 2 22"
    set lcrlref [::asn::asnSequence \
    [::asn::asnObjectIdentifier $::oidrevocationRefs] \
    [::asn::asnSet \
    [::asn::asnSequence \
    $revokeRefs \
    ] \
    ] \
    ]

  } else {
    set lcrl ""
    set lcrlref ""
  }

  return [list $lchain $lchainref $lcrl $lcrlref]
}

proc ::pkcs7_create_signeddata {content certs_hex typesign file_for_sign typekey} {
  set lcerts ""
  set listdigest ""
  set listsigner ""
  foreach cert_hex $certs_hex {
    set cert [binary  format H* $cert_hex]
    append lcerts $cert
    array set addsigner [create_new_signer $cert_hex $content $typekey]
    if {![info exists addsigner(listdigest)]} {
      #Что-то плохо с добавлением
      tk_messageBox -title "Подписание документа" -icon error -message "Невозможно подписать документ" -detail "Неподдерживаемый тип ключа"
      #      puts "Cannot add signer (digest)"
      return 0
    }
    if {![info exists addsigner(listsigner)]} {
      #Что-то плохо с добавлением
      tk_messageBox -title "Подписание документа" -icon error -message [mc "Cannot add signer (signer)"]
      #      puts "Cannot add signer (signer)"
      return 0
    }
    append listsigner $addsigner(listsigner)
    append listdigest $addsigner(listdigest)
  }

  if {$typesign == 0} {
    set context_for_sing [::asn::asnObjectIdentifier $::oidData]
  } else {
    set context_for_sing1 [::asn::asnObjectIdentifier $::oidData]
    set context_for_sing2     [::asn::asnContextConstr 0 \
    [::asn::asnOctetString $content] \
    ]
    set context_for_sing "$context_for_sing1$context_for_sing2"
  }

  set p7_signed [::asn::asnSequence \
  [::asn::asnObjectIdentifier $::oidSignedData] \
  [::asn::asnContextConstr 0 \
  [::asn::asnSequence \
  [::asn::asnInteger 1] \
  [::asn::asnSet $listdigest] \
  [::asn::asnSequence $context_for_sing] \
  [::asn::asnContextConstr 0 $lcerts] \
  [::asn::asnSet $listsigner] \
  ] \
  ] \
  ]

  set fd [open $file_for_sign w]
  chan configure $fd -translation binary
  puts -nonewline $fd $p7_signed
  close $fd
  #puts $cert
  return 1
}

proc validaty_cert_from_crl {crl sernum issuer} {
  #puts "SERN=$sernum"
  array set ret [list]
  if { [string range $crl 0 9 ] == "-----BEGIN" } {
    array set parsed_crl [::pki::_parse_pem $crl "-----BEGIN X509 CRL-----" "-----END X509 CRL-----"]
    set crl $parsed_crl(data)
  }
  ::asn::asnGetSequence crl crl_seq
  ::asn::asnGetSequence crl_seq crl_base
  ::asn::asnPeekByte crl_base peek_tag
  if {$peek_tag == 0x02} {
    # Version number is optional, if missing assumed to be value of 0
    ::asn::asnGetInteger crl_base ret(version)
    incr ret(version)
  } else {
    set ret(version) 1
  }

  ::asn::asnGetSequence crl_base crl_full
  ::asn::asnGetObjectIdentifier crl_full ret(signtype)
  ::::asn::asnGetSequence crl_base crl_issue
  set ret(issue) [::pki::x509::_dn_to_string $crl_issue]
  if {$ret(issue) != $issuer } {
    set ret(error) "Bad Issuer"
    return [array get ret]
  }
  binary scan  $crl_issue H*  ret(issue_hex)
  ::asn::asnGetUTCTime crl_base ret(publishDate)
  ::asn::asnGetUTCTime crl_base ret(nextDate)
  #puts "publishDate=$ret(publishDate)"
  #Список сертификатов отозванных
  ::asn::asnPeekByte crl_base peek_tag
  if {$peek_tag != 0x30} {
    #Список сертификатов отозванных пустой
    return [array get ret]
  }

  ::asn::asnGetSequence crl_base lcert
  while {$lcert != ""} {
    ::asn::asnGetSequence lcert lcerti
    #Разбираем i-й сертификат
    ::asn::asnGetBigInteger lcerti ret(sernumrev)
    set ret(sernumrev) [::math::bignum::tostr $ret(sernumrev)]
    #puts "$sernum $ret(sernumrev)"
    if {$ret(sernumrev) != $sernum} {
      continue
    }
    ::asn::asnGetUTCTime lcerti ret(revokeDate)
    if {$lcerti == ""} {
      puts "NO reasone"
    } else {
      ::asn::asnGetSequence lcerti lcertir
      ::asn::asnGetSequence lcertir reasone
      ::asn::asnGetObjectIdentifier reasone ret(reasone)
      ::asn::asnGetOctetString reasone reasone2
      ::asn::asnGetEnumeration reasone2 ret(reasoneData)
    }
    break;	
  }
  return [array get ret]
}


proc loadcrl {cert_hex type} {
  global typesys
  global macos
  #type 1 - вернуть CRL
  global count
  global loadfile
  global myHOME
  if {$cert_hex == "" } {
    return
  }
  set cert [binary format H* $cert_hex]
  array set cert_parse [::pki::x509::parse_cert $cert]
  array set extcert $cert_parse(extensions)
  #parray cert_parse
  #parray extcert
  set listcrl ""
  if {[info exists extcert(2.5.29.31)]} {
    set listcrl [crlpoints [lindex $extcert(2.5.29.31) 1]]
    set listcrl  $listcrl
    unset extcert(2.5.29.31)
  }
  #puts "listcrl=$listcrl"
  #CRL для подписи
  if {$type == 1} {
    set filecrl ""
    set pointcrl ""
    foreach pointcrl $listcrl {
      set filecrl [readca $pointcrl]
      if {$filecrl != ""} {
        #puts "listcrl point=$pointcrl"
        break
      }
      #Прочитать CRL не удалось. Берем следующую точку с CRL
    }
    return $filecrl
  }


  if {$listcrl == "" } {
    if {$cert_parse(issuer) == $cert_parse(subject)} {
      set ms [mc "This is a root self-signed certificate"]
      set dt [mc "The validity of a self-signed certificate is determined by the owner"]
      tk_messageBox -title [mc "Load chain CA"] -icon info -message $ms -detail $dt
      return
    }
    set message "[mc {Cannot load CRL}]\n[mc {You specify the file with the CRL}]?"
    set answer [tk_messageBox -icon question \
    -message $message \
    -title [mc "Load CRL"] \
    -detail [mc "Unable to verify certificate validity"] \
    -type yesno]

    if {$answer != "yes"} {
      return
    }
    set typeFile {
      {"CRL"    .crl}
      {"DER-формат]"    .cer}
      {"PEM-формат"    .pem}
      {"Любой тип"    *}
    }
    #	set typeFile [subst $typeFile]
    set titleS "Выберите файл с CRL"
    if {$macos} {
      set ft ""
    } else {
      set ft $typeFile
    }

    set filecrl [tk_getOpenFile -title $titleS -filetypes $ft -initialdir $::lastDoc]
    if {$filecrl == ""} {
      return
    }
    set ::lastDoc [file dirname $filecrl]

    set f [open $filecrl r]
    chan configure $f -translation binary
    set crl [read $f]
    close $f

    array set valcert [validaty_cert_from_crl $crl $cert_parse(serial_number) $cert_parse(issuer)]
    if {[info exists valcert(error)]} {
      tk_messageBox -title [mc "Load CRL"] -icon info -message "[mc {CRL from auther published}]\n$filecrl" -detail $valcert(issue)
      return
    }
    if {![info exists valcert(revokeDate)]} {
      #Сертификат не отозван
      set valc "[mc {Certificate valid}] \(N=$cert_parse(serial_number)\)"
    } else {
      set t [string trimright $valcert(revokeDate) "Z"]
      set year "20[string range $t 0 1]"
      set month [string range $t 2 3]
      set day [string range $t 4 5]
      set hour [string range $t 6 7]
      set minute [string range $t 8 9]
      set second [string range $t 10 11]
      #	puts  "$day $month $year $hour $minute"
      set revdate "$day/$month/$year $hour:$minute:$second"
      set valc "[mc {Certificate revoked}] \(N=$valcert(sernumrev)\): $revdate"
    }
    set t [string trimright $valcert(publishDate) "Z"]
    set year "20[string range $t 0 1]"
    set month [string range $t 2 3]
    set day [string range $t 4 5]
    set hour [string range $t 6 7]
    set minute [string range $t 8 9]
    set second [string range $t 10 11]
    set publishdate "$day/$month/$year $hour:$minute:$second"
    set t [string trimright $valcert(nextDate) "Z"]
    set year "20[string range $t 0 1]"
    set month [string range $t 2 3]
    set day [string range $t 4 5]
    set hour [string range $t 6 7]
    set minute [string range $t 8 9]
    set second [string range $t 10 11]
    set nextdate "$day/$month/$year $hour:$minute:$second"

    set valc "$valc\n[mc {CRL release date}]: $publishdate\n[mc {Next CRL issue date}]: $nextdate"
    tk_messageBox -title [mc "Load CRL"] -icon info -message "[mc {Load CRL from}]\n$filecrl" -detail $valc
    return
}
  set dir [tk_chooseDirectory -initialdir $myHOME -title [mc "Select a directory to save the CRL"]]
  if {$typesys == "win32" } {
    if { "after#" == [string range $dir 0 5] } {
      set dir ""
    }
  }
  if {$dir == ""} {
    return
  }
  set filecrl ""
  set pointcrl ""
  foreach pointcrl $listcrl {
    set filecrl [readca $pointcrl]
    if {$filecrl != ""} {
      set f [file join $dir [file tail $pointcrl]]
      set fd [open $f w]
      chan configure $fd -translation binary
      puts -nonewline $fd $filecrl
      close $fd
      set filecrl $f
      break
    }
    #Прочитать CRL не удалось. Берем следующую точку с CRL
  }
  if {$filecrl == ""} {
    set message "[mc {Cannot load CRL}]\n[mc {You specify the file with the CRL}]"
    set answer [tk_messageBox -icon question \
    -message $message \
    -title [mc "Load CRL"] \
    -detail [mc "Unable to verify certificate validity"] \
    -type yesno]

    if {$answer != "yes"} {
      return
    }
    set typeFile {
      {"CRL"    .crl}
      {"DER-формат"    .cer}
      {"PEM-формат"    .pem}
      {"Любой тип"    *}
    }
    set titleS "Выберите файл с CRL"
    if {$macos} {
      set ft ""
    } else {
      set ft $typeFile
    }

    set filecrl [tk_getOpenFile -title $titleS -filetypes $ft -initialdir $::lastDoc]
    if {$filecrl == ""} {
      return
    }
    set ::lastDoc [file dirname $filecrl]

    #	tk_messageBox -title [mc "Load CRL"] -icon error -message [mc "Cannot load CRL"] -detail [mc "Unable to verify certificate validity"]
}

  set ss "[mc {File with CRL}]:\n$filecrl"
  set f [open $filecrl r]
  chan configure $f -translation binary
  set crl [read $f]
  close $f

  array set valcert [validaty_cert_from_crl $crl $cert_parse(serial_number) $cert_parse(issuer)]
  if {[info exists valcert(error)]} {
    tk_messageBox -title [mc "Load CRL"] -icon info -message "[mc {CRL from auther published}]\n$filecrl" -detail $valcert(issue)
    return
  }
  #    parray valcert
  set revdate ""
  if {![info exists valcert(revokeDate)]} {
    #Сертификат не отозван
    set valc "[mc {Certificate valid}] \(N=$cert_parse(serial_number)\)"
  } else {
    set t [string trimright $valcert(revokeDate) "Z"]
    set year "20[string range $t 0 1]"
    set month [string range $t 2 3]
    set day [string range $t 4 5]
    set hour [string range $t 6 7]
    set minute [string range $t 8 9]
    set second [string range $t 10 11]
    #	puts  "$day $month $year $hour $minute"
    set revdate "$day/$month/$year $hour:$minute:$second"
    set valc "[mc {Certificate revoked}] \(N=$valcert(sernumrev)\): $revdate"
    if {[info exists valcert(reasone)]} {
      set valc "$valc\n[mc {Revocation reason code}]: $valcert(reasoneData)"
    }
  }
  set t [string trimright $valcert(publishDate) "Z"]
  set year "20[string range $t 0 1]"
  set month [string range $t 2 3]
  set day [string range $t 4 5]
  set hour [string range $t 6 7]
  set minute [string range $t 8 9]
  set second [string range $t 10 11]
  set publishdate "$day/$month/$year $hour:$minute:$second"
  set t [string trimright $valcert(nextDate) "Z"]
  set year "20[string range $t 0 1]"
  set month [string range $t 2 3]
  set day [string range $t 4 5]
  set hour [string range $t 6 7]
  set minute [string range $t 8 9]
  set second [string range $t 10 11]
  set nextdate "$day/$month/$year $hour:$minute:$second"

  set valc "$valc\n[mc {CRL release date}]: $publishdate\n[mc {Next CRL issue date}]: $nextdate"
  tk_messageBox -title [mc "Load CRL"] -icon info -message "[mc {Load CRL from}]\n$pointcrl \n$ss" -detail $valc
  }

proc ::parse_pkcs7 {type p7file sfile} {
  #puts "START parse_pkcs7=$type"
  variable typesig
  if {$type == "file"} {
    #puts "parse_pkcs7=$p7file, sfile=$sfile"
    if {$p7file == ""} {
      return -3
    }
    set fd [open $p7file]
    chan configure $fd -translation binary
    set p7 [read $fd]
    close $fd
    if {$p7 == "" } {
      puts "Bad file with p7=$p7file"
      return -3
    }
    set p7_seq ""
    if { [string range $p7 0 9 ] == "-----BEGIN" } {
      set p7_1 [string map {"\r\n" "\n"} $p7]
      array set parsed_p7 [::pki::_parse_pem $p7_1 "-----BEGIN PKCS7-----" "-----END PKCS7-----"]
      set p7_seq $parsed_p7(data)
    } else {
      #FORMAT DER
      if {[string range $p7 0 0] != "0"} {
        return -2
      }
      set p7_seq $p7
    }
  } elseif {$type == "der" } {
    set p7_seq $p7file
    if {$p7_seq == "" } {
      puts "Bad pkcs7=NULL"
      return -3
    }
  } else {
    puts "Bad type=$type"
    return -3
  }
  #Файл p7s der в hex-е
  binary scan $p7_seq  H* p7s_hex

  array set ret [list]
  asn::asnGetSequence p7_seq pkcs7
  ::asn::asnGetObjectIdentifier pkcs7 oidpkcs7
  if {$oidpkcs7 != "1 2 840 113549 1 7 2" && $oidpkcs7 != "1.2.840.113549.1.7.2"} {
    puts "oid != \"1.2.840.113549.1.7.2\"\n$oidpkcs7"
    return ""
  }

  #puts $oidpkcs7

  ::asn::asnGetContext pkcs7 - asn_cont
  asn::asnGetSequence asn_cont asn_cont1
  ::asn::asnPeekByte asn_cont1 peek_tag
  if {$peek_tag == 0x02} {
    # Version number is optional, if missing assumed to be value of 0
    ::asn::asnGetInteger asn_cont1 ret(version)
    #puts "VAR=$ret(version)"		
  } else {
    set ret(version) 1
    #puts "def VAR=$ret(version)"		
  }
  asn::asnGetSet asn_cont1 asn_cont2
  #p7b
  if {[string length $asn_cont2] > 0} {

    asn::asnGetSequence asn_cont2 asn_cont3
    ::asn::asnGetObjectIdentifier asn_cont3 oidhash
    #puts "OIDHASH=$oidhash"
    asn::asnGetSequence asn_cont1 asn_cont4
    ::asn::asnGetObjectIdentifier asn_cont4 oiddata
    #puts "OIDDATA=$oiddata"
    set lc [string length $asn_cont4]
    set lc_hex ""
    if {$lc == 2 } {
      #Переводим два файта в HEX (проверяем BER-кодировку)
      binary scan $asn_cont4  H* lc_hex
      #puts "CONTEXT=\"$lc_hex\""
    }
    if {[string length $asn_cont4] > 0 && $lc_hex != "0000"} {
      set ret(attached) 1

      ::asn::asnGetContext asn_cont4 - octcontext
      ##############
      ::asn::asnPeekByte octcontext peek_tag
      ::asn::asnPeekByte octcontext peek_tag1 1
      if {$peek_tag == 0x24 && $peek_tag1 == 0x80} {
        set contextVar1 $octcontext
        ::asn::asnGet24OctetString contextVar1 octcontext
        #		puts "p7dParse=0x240x80"
      }
      #################

      ::asn::asnGetOctetString octcontext context
      binary scan $context  H* ret(context_hex)
      #	puts "attached signature, len context=$lll "

    } else {
      #	puts "detached signature"
      set ret(attached) 0
      set context ""
      if {$sfile != ""} {
        if {![file exists $sfile]} {
          puts "Content File $sfile not exist"
          set ret(context_hex) ""
        } else {
          #		puts "Loading content file: $sfile"
          set fd [open $sfile]
          chan configure $fd -translation binary
          set data [read $fd]
          close $fd
          if {$data == "" } {
            puts "Bad file with certificate=$file"
            set ret(context_hex) ""
            set context $data
          } else {
            set context $data
            binary scan $context  H* ret(context_hex)
          }
        }
      }
    }
    #Проверяем хэш контента
    switch -- $oidhash {
      "1.2.643.7.1.1.2.2" - "1 2 643 7 1 1 2 2" {
        #    "GOST R 34.11-2012-256"
        set digest_algo "stribog256"
      }
      "1.2.643.7.1.1.2.3" - "1 2 643 7 1 1 2 3" {
        #     "GOST R 34.11-2012-512"
        set digest_algo "stribog512"
      }
      "1.2.643.2.2.9" - "1 2 643 2 2 9" {
        #    "GOST R 34.10-2001 with GOST R 34.11-94"
        set digest_algo "gostr3411"
      }
      default {
        puts "Cannot veridy content\nUnknown digestalgo=$oidhash"
        #		return -1
      }
    }
    #    set aa [dict create pkcs11_handle $::handle pkcs11_slotid $::slotid_tek]
    if {$context != ""} {
      if {[info command $::tokenls11sw0] == ""} {
        set digest_mes_hex    [pki::pkcs11::dgst $digest_algo $context]
      } else {
        set digest_mes_hex    [$::tokenls11sw0 digest $digest_algo $context ]
      }
    } else {
      set digest_mes_hex ""
    }
    #p7b
  } else {
    #puts "YES P7B"
    asn::asnGetSequence asn_cont1 p7data
    ::asn::asnGetObjectIdentifier p7data oiddata
    #puts "OIDDATA_P7B=$oiddata"
  }

  set i 0
  ::asn::asnPeekByte asn_cont1 peek_tag
  set lcerts [list]
  if {$peek_tag == 0xA0} {
    ::asn::asnGetContext asn_cont1 - listcert
    while {[string length $listcert] > 0 } {
      #Проверка BER-кодировки
      if {[string length $listcert] == 2 } {
        break
      }

      asn::asnGetSequence listcert cert
      set cert [asn::asnSequence $cert]
      binary scan $cert  H* cert_hex
      lappend lcerts  $cert_hex
      incr i
    }
  }
  #puts "LCERTS=$lcerts"
  ::asn::asnPeekByte asn_cont1 peek_tag
  set lcrls [list]
  if {$peek_tag == 0xA1} {
    ::asn::asnGetContext asn_cont1 - listcrl
    while {[string length $listcrl] > 0 } {
      asn::asnGetSequence listcrl crl
      set crl [asn::asnSequence $crl]
      lappend lcrls [::pki::_encode_pem $crl "-----BEGIN CRL-----" "-----END CRL-----"]
      incr i
    }
  }
  #puts "LCRLS=$lcrls"

  asn::asnGetSet asn_cont1 signerinfos
  set i1 0

  set linfos {}
  while {[string length $signerinfos] > 0 } {
    asn::asnGetSequence signerinfos signerinfo
    ::asn::asnGetInteger signerinfo ret(versigninfo)
    #puts "ret(versigninfo)=$ret(versigninfo)"		
    asn::asnGetSequence signerinfo sid
    asn::asnGetSequence sid	name
    set ret(issuer_str) [::pki::x509::_dn_to_string $name]
    set name [asn::asnSequence $name]
    binary scan $name  H* ret(issuer)
    ::asn::asnGetBigInteger sid ret(serial_number_dec)
    set ret(serial_number) [asn::asnBigInteger $ret(serial_number_dec)]
    binary scan $ret(serial_number)  H* ret(serial_number)
    #Добавляем nick для сертификата CN_Subject from CN_issuer
    set yescert 0
    foreach cert $lcerts {
      #puts "CERT=$cert"
      array set infopk [pki::pkcs11::pubkeyinfo $cert ]
      #		parray infopk
      if {$infopk(issuer) == $ret(issuer) && $infopk(serial_number) == $ret(serial_number)} {
        set yescert 1
        set ret(cert_hex) $cert
        break
      }
    }
    if {$yescert != 1} {
      #      puts "Not found certificate:issuer=$ret(issuer_str)\nSN=$ret(serial_number_dec)"
      set ret(nickcert) ""
      set ret(cert_hex) ""
    } else {
      #		puts "Found certificate:issuer=$ret(issuer_str)\nSN=$ret(serial_number_dec)"
      set subject [binary format H* $infopk(subject)]
      ::asn::asnGetSequence subject sub1
      set subject_str [pki::x509::_dn_to_string $sub1]
      #		puts "subject=$subject_str\nSN=$ret(serial_number_dec)"
      set ret(nickcert) [createnick $ret(issuer_str) $subject_str]
      #		puts "ret(nickcert)=$ret(nickcert)"
    }

    asn::asnGetSequence signerinfo digestalgo
    ::asn::asnGetObjectIdentifier digestalgo oiddigestalgo
    #puts "ISSUER=$ret(issuer)"
    #puts "SERIAL_NUMBER=[lindex $ret(serial_number) 2]"
    #puts "OIDDIGESTALGO=$oiddigestalgo"
    set ret(digestalgo) $oiddigestalgo
    ::asn::asnPeekByte signerinfo peek_tag
    if {$peek_tag == 0xA0} {
      #Для подсчета хэша 0xA0 надо заменить на 0x31 в 0-ой позиции

      ::asn::asnGetContext signerinfo - signedattrs
      #!!!!
      set signerinfoMy [::asn::asnContext 0 $signedattrs]
      binary scan $signerinfoMy  H* ret(signerinfo)

      set i2 0
      while {$signedattrs != ""} {
        asn::asnGetSequence signedattrs signedattr
        ::asn::asnGetObjectIdentifier signedattr oidtypeattr
        # ESS signing-certificate-v2
        switch -- $oidtypeattr {
          "1 2 840 113549 1 9 3" {
            asn::asnGetSet signedattr typedate
            ::asn::asnGetObjectIdentifier typedate oidtypedate
            #puts "oidtypedate=$oidtypedate"
          }
          "1 2 840 113549 1 9 4" {
            asn::asnGetSet signedattr messagedigest
            ::asn::asnGetOctetString messagedigest messagedigest
            binary scan $messagedigest  H* ret(messageDigest)
            set ret(messageDigestTek) $digest_mes_hex
            #puts "messageDigest=$ret(messageDigest)"
            #puts "digest_mes_hex=$digest_mes_hex"
          }
          "1 2 840 113549 1 9 5" {
            asn::asnGetSet signedattr signedtime
            binary scan $signedtime  H* ret(signedtime_derhex)
            ::asn::asnGetUTCTime signedtime ret(signedTime)
            #puts "ret(signedTine)=$ret(signedTime)"
          }
          "1 2 840 113549 1 9 16 2 47" {
            asn::asnGetSet signedattr signedcertv2
            binary scan $signedcertv2  H* ret(signedtcertv2)
            #puts "signedtcertv2=$ret(signedtcertv2)"

          }
          "1 2 840 113549 1 9 16 2 12" {
            asn::asnGetSet signedattr signingCertificate
            binary scan $signingCertificate  H* ret(signingCertificate)
            #puts "signingCertificate=$ret(signingCertificate)"

          }

          default {
            puts "DEFAULT signer oidtypeattr=$oidtypeattr"
            asn::asnGetSet signedattr signeddefault
            binary scan $signeddefault  H* ret(signeddefault)
            #puts "DEFAULT Value=$ret(signeddefault)"
          }
        }
        #puts "oidtypeattr=$oidtypeattr"
        incr i2
      }
      #puts "I2=$i2"
    }
    asn::asnGetSequence signerinfo signaturealgo
    ::asn::asnGetObjectIdentifier signaturealgo oidsignaturealgo
    #puts "OIDSignatureALGO=$oidsignaturealgo"
    ::asn::asnGetOctetString signerinfo ret(signature)
    binary scan $ret(signature)  H* ret(signature)
    #puts "Signature=$ret(signature)"
    incr i1
    set ret(esctimeStamp) 0
    set ret(timeStamp) 0
    if {[string length $signerinfo] == 0} {
      lappend linfos [array get ret]
      continue
    }
    ::asn::asnPeekByte signerinfo peek_tag

    if {$peek_tag == 0xA1} {
      ::asn::asnGetContext signerinfo - unsignedattrs
      #puts "unsignedattrs"
      set i3 0
      while {$unsignedattrs != ""} {
        asn::asnGetSequence unsignedattrs signedattr
        set signedattr2save $signedattr
        ::asn::asnGetObjectIdentifier signedattr oidtypeattr
        switch -- $oidtypeattr {
          "1 2 840 113549 1 9 16 2 14" {
            #puts "id-aa-timeStampToken=$oidtypeattr"
            set ret(tst_der) $signedattr2save
            asn::asnGetSet signedattr timestamp
            binary scan $timestamp  H* ret(p7timestamp_hex)
            set  ret(timeStamp) 1
            set tst [parse_pkcs7 "der" "$timestamp" ""]
            foreach {tstcert tstcrls tstp7} $tst {}
            foreach tstp7t $tstp7 {
              #puts "P7=$p7t"
              array set tp7 $tstp7t
              set ret(tstdigest) $tp7(digestalgo)
              set ret(tstinfo) $tp7(context_hex)
              #puts "TST"
              #parray tp7
            }

          }
          "1 2 840 113549 1 9 16 2 21" {
            #puts "id-aa-ets-CertificateRefs=$oidtypeattr"
            set ret(certRefs_der) $signedattr2save
          }
          "1 2 840 113549 1 9 16 2 22" {
            #puts "id-aa-ets-revocationRefs=$oidtypeattr"
            set ret(revokeRefs_der) $signedattr2save
          }
          "1 2 840 113549 1 9 16 2 23" {
            #puts "id-aa-ets-certValues=$oidtypeattr"
            asn::asnGetSet signedattr certValues
            set i4 0
            asn::asnGetSequence certValues certValues1
            while {$certValues1 != ""} {
              asn::asnGetSequence certValues1 certValue
              set certValue [asn::asnSequence $certValue]
              binary scan $certValue  H* cert_hex
              lappend lcerts  $cert_hex
              incr i4
              #timeStampToken
              set yescert 0
              array set infopk [pki::pkcs11::pubkeyinfo $cert_hex ]
              #		parray infopk
              if {$infopk(issuer) == $ret(issuer) && $infopk(serial_number) == $ret(serial_number)} {
                set yescert 1
                set ret(cert_hex) $cert_hex
              }
              if {$yescert == 1 && $ret(nickcert) == ""} {
                set ret(nickcert) "Server TSP"
              }

            }
            set ret(lcerts) $lcerts
            #				puts "I4=$i4"
          }
          "1 2 840 113549 1 9 16 2 24" {
            #puts "id-aa-ets-revocationValues=$oidtypeattr"
          }
          "1 2 840 113549 1 9 16 2 25" {
            #puts "id-aa-ets-esctimeStamp=$oidtypeattr"
            set ret(esctimeStamp) 1
            asn::asnGetSet signedattr esctimestamp
            binary scan $esctimestamp  H* ret(p7esctimestamp_hex)
            set esctst [parse_pkcs7 "der" "$esctimestamp" ""]
            foreach {tstcert tstcrls tstp7} $esctst {}
            foreach tstp7t $tstp7 {
              #puts "P7esc=$tstp7t"
              array set tp7 $tstp7t
              set ret(tstdigest) $tp7(digestalgo)
              set ret(esctstinfo) $tp7(context_hex)
              #puts "escTST"
              #parray tp7
            }

          }
          default {
            puts "DEFAULT oidtypeattr=$oidtypeattr"
            asn::asnGetSet signedattr signeddefault
            binary scan $signeddefault  H* ret(signeddefault)
            puts "DEFAULT Value=$oidtypeattr"
          }
        }
        incr i3
        incr ::I
      }
      #puts "I3=$i3"
                              	
    } else {
      puts "BEDA UNSIGN"

    }
    #parray ret
    #puts "LINFIS_RET=$linfos"
    lappend linfos [array get ret]
                    	
  }
  #puts "I1=$i1"
  #puts "LINFOS=$linfos"
  #puts "LCERTS=$lcerts"
  #puts "LCRLS=$lcrls"
  set ::p7s_hex $p7s_hex
  return [list $lcerts $lcrls $linfos]
}

proc pscale { pixels } {
  return [expr {round(double($pixels)*[tk scaling]/1.388888888)}]
}

proc drawhand { tag v count doffset color width \
lenmult neglenmult capstyle } {
  variable vars

  set deg [expr {(360.0/$count) * (double($v)-$doffset)}]
  set x0 [expr {-(round(double($vars(radius))*$neglenmult * \
  cos($deg*0.0174533)))+$vars(center)}]
  set y0 [expr {-(round(double($vars(radius))*$neglenmult * \
  sin($deg*0.0174533)))+$vars(center)}]
  set x [expr {round(double($vars(radius))*$lenmult * \
  cos($deg*0.0174533))+$vars(center)}]
  set y [expr {round(double($vars(radius))*$lenmult * \
  sin($deg*0.0174533))+$vars(center)}]
  if { [info exists vars($tag)] } {
    $vars(canvas) delete $vars($tag)
  }
  set vars($tag) [$vars(canvas) create line \
  $x0 $y0 $x $y \
  -fill $color \
  -width $width \
  -capstyle $capstyle \
  -smooth true \
  ]
}

proc hour { } {
  variable vars

  set sz [expr {round(9.0*$vars(scaling))}]
  set v [expr {[clock format $vars(tm) -format %l]}]
  regsub {^0*(.)} $v {\1} v
  set vm [expr {[clock format $vars(tm) -format %M]}]
  regsub {^0*(.)} $vm {\1} vm
  set v [expr {double($v)+double($vm)/60.0}]
  drawhand hourhand $v 12.0 3.0 $vars(fgcol) [pscale $sz] 0.5 0.1 butt
}

proc minute { } {
  variable vars

  set sz [expr {round(4.0*$vars(scaling))}]
  set v [expr {[clock format $vars(tm) -format %M]}]
  regsub {^0*(.)} $v {\1} v
  drawhand minutehand $v 60.0 15.0 $vars(fgcol) [pscale $sz] 0.6 0.2 round
}

proc second { } {
  variable vars

  set sz [expr {round(2.0*$vars(scaling))}]
  set v [expr {[clock format $vars(tm) -format %S]}]
  regsub {^0*(.)} $v {\1} v
  drawhand secondhand $v 60.0 15.0 red [pscale $sz] 0.9 0.05 round
}

proc ::tick { } {
  global ttt
  variable vars

  set vars(tm) [clock seconds]
  hour
  minute
  second
  after 200 ::tick
  set ttt [clock seconds]
}

proc reconfigure { w args } {
  variable vars
  # windows sends many reconfigure .c events
  if { $w ne ".topclock" } {
    return
  }
  after cancel $vars(afterid)
  set vars(afterid) [after 100 _reconfigure]
}

proc _reconfigure { } {
  global ttt
  variable vars

  bind .topclock.fclock <Configure> {}
  set sz [expr {min([winfo width .topclock.fclock],[winfo height .topclock.fclock])}]
  set t [expr {round(double($sz)/[tk scaling]*1.388888888)}]
  set r [expr {round($t/2.2)}]
  if { $vars(oldr) != $r } {
    drawClock $r
    set vars(oldr) $r
    #    update
  }
  update
  set ttt $r
  bind .topclock <Configure> [list ::reconfigure %W]
}

proc drawClock { basesz } {
  variable vars

  set vars(radius) [pscale $basesz]
  set vars(border) [pscale [expr {round(double($basesz)/10.0)}]]
  set vars(center) [expr {$vars(radius)+$vars(border)}]

  if { ! [winfo exists .topclock.fclock.c] } {
    set vars(canvas) [canvas .topclock.fclock.c \
    -background white \
    -highlightthickness 0 \
    ]
    pack $vars(canvas) -fill both -expand 1
  } else {
    $vars(canvas) delete all
  }
  $vars(canvas) configure \
  -height [expr {$vars(radius)*2+$vars(border)*2}] \
  -width [expr {$vars(radius)*2+$vars(border)*2}]
  #      -height 150 \
  #      -width 150

  set vars(scaling) [expr {double($vars(radius))/100.0}]
  set sz [expr {round(12.0*$vars(scaling))}]
  font configure clockfont -size [expr {round([pscale $sz])}]

  font configure labelfont -size [expr {round([pscale $sz])} + 4]
  #  .topclock.lclock configure -font labelfont

  $vars(canvas) create oval \
  $vars(border) $vars(border) \
  [expr {$vars(radius)*2+$vars(border)}] \
  [expr {$vars(radius)*2+$vars(border)}] \
  -fill grey95 \
  -width 0
  set inset [expr {round(15.0*$vars(radius)/100.0)}]
  for {set i 1} {$i <= 12} {incr i} {
    set deg [expr {(360.0/12.0) * (double($i)-3.0)}]
    set x [expr {round((double($vars(radius))-[pscale $inset]) * \
    cos($deg*0.0174533))+$vars(center)}]
    set y [expr {round((double($vars(radius))-[pscale $inset]) * \
    sin($deg*0.0174533))+$vars(center)}]
    set vars(lab.$i) [$vars(canvas) create text $x $y \
    -text $i \
    -font clockfont \
    -fill $vars(fgcol) \
    ]
  }
}

proc guiclock { } {
  global typesys
  variable opts
  variable vars
  set w ".topclock"
  catch {destroy $w}
  set vars(program.tag) clock

  set vars(fgcol) black
  set vars(oldr) 0
  labelframe .topclock -text "Идет процесс подписания" -bg white -relief groove -bd 3 -bg white  -highlightbackground chocolate -highlightcolor skyblue  -highlightthickness 5

  font create clockfont
  font create labelfont
  set c [font actual TkDefaultFont]
  regsub -- {-size\s*\d+\s*} $c {} c
  font configure clockfont {*}$c
  font configure labelfont {*}$c
  font configure labelfont -family helvetica

  label $w.lclock -text "Начался процесс подписания\n\nдокумента из файла\n\nXAXAXA\n\nПодождите некоторое время!" -bg snow  -fg blue
  #   -font labelfont
  #   -font {Times 11 bold italic}
  pack $w.lclock -side left -pady 5 -padx 5 -fill x
  frame $w.fclock  -bg snow
  pack $w.fclock -side left -fill both -expand 1

  set vars(afterid) {}
  drawClock 100
  update

  _reconfigure ; # does the initial bind

  ::tick
}

page_password

guiclock
#Главное окно неизменяемое
wm resizable . 0 0
.st.labMain.blang configure -image  ::img::ru_32x32 -compound left
